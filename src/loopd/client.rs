// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `client.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LoopOutRequest {
    // message fields
    pub amt: i64,
    pub dest: ::std::string::String,
    pub max_swap_routing_fee: i64,
    pub max_prepay_routing_fee: i64,
    pub max_swap_fee: i64,
    pub max_prepay_amt: i64,
    pub max_miner_fee: i64,
    pub loop_out_channel: u64,
    pub outgoing_chan_set: ::std::vec::Vec<u64>,
    pub sweep_conf_target: i32,
    pub htlc_confirmations: i32,
    pub swap_publication_deadline: u64,
    pub label: ::std::string::String,
    pub initiator: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoopOutRequest {
    fn default() -> &'a LoopOutRequest {
        <LoopOutRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoopOutRequest {
    pub fn new() -> LoopOutRequest {
        ::std::default::Default::default()
    }

    // int64 amt = 1;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // string dest = 2;


    pub fn get_dest(&self) -> &str {
        &self.dest
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::string::String) {
        self.dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::string::String {
        &mut self.dest
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dest, ::std::string::String::new())
    }

    // int64 max_swap_routing_fee = 3;


    pub fn get_max_swap_routing_fee(&self) -> i64 {
        self.max_swap_routing_fee
    }
    pub fn clear_max_swap_routing_fee(&mut self) {
        self.max_swap_routing_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_routing_fee(&mut self, v: i64) {
        self.max_swap_routing_fee = v;
    }

    // int64 max_prepay_routing_fee = 4;


    pub fn get_max_prepay_routing_fee(&self) -> i64 {
        self.max_prepay_routing_fee
    }
    pub fn clear_max_prepay_routing_fee(&mut self) {
        self.max_prepay_routing_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_prepay_routing_fee(&mut self, v: i64) {
        self.max_prepay_routing_fee = v;
    }

    // int64 max_swap_fee = 5;


    pub fn get_max_swap_fee(&self) -> i64 {
        self.max_swap_fee
    }
    pub fn clear_max_swap_fee(&mut self) {
        self.max_swap_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_fee(&mut self, v: i64) {
        self.max_swap_fee = v;
    }

    // int64 max_prepay_amt = 6;


    pub fn get_max_prepay_amt(&self) -> i64 {
        self.max_prepay_amt
    }
    pub fn clear_max_prepay_amt(&mut self) {
        self.max_prepay_amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_prepay_amt(&mut self, v: i64) {
        self.max_prepay_amt = v;
    }

    // int64 max_miner_fee = 7;


    pub fn get_max_miner_fee(&self) -> i64 {
        self.max_miner_fee
    }
    pub fn clear_max_miner_fee(&mut self) {
        self.max_miner_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_miner_fee(&mut self, v: i64) {
        self.max_miner_fee = v;
    }

    // uint64 loop_out_channel = 8;


    pub fn get_loop_out_channel(&self) -> u64 {
        self.loop_out_channel
    }
    pub fn clear_loop_out_channel(&mut self) {
        self.loop_out_channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_out_channel(&mut self, v: u64) {
        self.loop_out_channel = v;
    }

    // repeated uint64 outgoing_chan_set = 11;


    pub fn get_outgoing_chan_set(&self) -> &[u64] {
        &self.outgoing_chan_set
    }
    pub fn clear_outgoing_chan_set(&mut self) {
        self.outgoing_chan_set.clear();
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_set(&mut self, v: ::std::vec::Vec<u64>) {
        self.outgoing_chan_set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outgoing_chan_set(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.outgoing_chan_set
    }

    // Take field
    pub fn take_outgoing_chan_set(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.outgoing_chan_set, ::std::vec::Vec::new())
    }

    // int32 sweep_conf_target = 9;


    pub fn get_sweep_conf_target(&self) -> i32 {
        self.sweep_conf_target
    }
    pub fn clear_sweep_conf_target(&mut self) {
        self.sweep_conf_target = 0;
    }

    // Param is passed by value, moved
    pub fn set_sweep_conf_target(&mut self, v: i32) {
        self.sweep_conf_target = v;
    }

    // int32 htlc_confirmations = 13;


    pub fn get_htlc_confirmations(&self) -> i32 {
        self.htlc_confirmations
    }
    pub fn clear_htlc_confirmations(&mut self) {
        self.htlc_confirmations = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_confirmations(&mut self, v: i32) {
        self.htlc_confirmations = v;
    }

    // uint64 swap_publication_deadline = 10;


    pub fn get_swap_publication_deadline(&self) -> u64 {
        self.swap_publication_deadline
    }
    pub fn clear_swap_publication_deadline(&mut self) {
        self.swap_publication_deadline = 0;
    }

    // Param is passed by value, moved
    pub fn set_swap_publication_deadline(&mut self, v: u64) {
        self.swap_publication_deadline = v;
    }

    // string label = 12;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string initiator = 14;


    pub fn get_initiator(&self) -> &str {
        &self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator.clear();
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        &mut self.initiator
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initiator, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LoopOutRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dest)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_swap_routing_fee = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_prepay_routing_fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_swap_fee = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_prepay_amt = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_miner_fee = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.loop_out_channel = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.outgoing_chan_set)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sweep_conf_target = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.htlc_confirmations = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.swap_publication_deadline = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initiator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.dest.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dest);
        }
        if self.max_swap_routing_fee != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_swap_routing_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_prepay_routing_fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_prepay_routing_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_swap_fee != 0 {
            my_size += ::protobuf::rt::value_size(5, self.max_swap_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_prepay_amt != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_prepay_amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_miner_fee != 0 {
            my_size += ::protobuf::rt::value_size(7, self.max_miner_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_out_channel != 0 {
            my_size += ::protobuf::rt::value_size(8, self.loop_out_channel, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.outgoing_chan_set {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.sweep_conf_target != 0 {
            my_size += ::protobuf::rt::value_size(9, self.sweep_conf_target, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_confirmations != 0 {
            my_size += ::protobuf::rt::value_size(13, self.htlc_confirmations, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.swap_publication_deadline != 0 {
            my_size += ::protobuf::rt::value_size(10, self.swap_publication_deadline, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.label);
        }
        if !self.initiator.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.initiator);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt != 0 {
            os.write_int64(1, self.amt)?;
        }
        if !self.dest.is_empty() {
            os.write_string(2, &self.dest)?;
        }
        if self.max_swap_routing_fee != 0 {
            os.write_int64(3, self.max_swap_routing_fee)?;
        }
        if self.max_prepay_routing_fee != 0 {
            os.write_int64(4, self.max_prepay_routing_fee)?;
        }
        if self.max_swap_fee != 0 {
            os.write_int64(5, self.max_swap_fee)?;
        }
        if self.max_prepay_amt != 0 {
            os.write_int64(6, self.max_prepay_amt)?;
        }
        if self.max_miner_fee != 0 {
            os.write_int64(7, self.max_miner_fee)?;
        }
        if self.loop_out_channel != 0 {
            os.write_uint64(8, self.loop_out_channel)?;
        }
        for v in &self.outgoing_chan_set {
            os.write_uint64(11, *v)?;
        };
        if self.sweep_conf_target != 0 {
            os.write_int32(9, self.sweep_conf_target)?;
        }
        if self.htlc_confirmations != 0 {
            os.write_int32(13, self.htlc_confirmations)?;
        }
        if self.swap_publication_deadline != 0 {
            os.write_uint64(10, self.swap_publication_deadline)?;
        }
        if !self.label.is_empty() {
            os.write_string(12, &self.label)?;
        }
        if !self.initiator.is_empty() {
            os.write_string(14, &self.initiator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoopOutRequest {
        LoopOutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &LoopOutRequest| { &m.amt },
                |m: &mut LoopOutRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dest",
                |m: &LoopOutRequest| { &m.dest },
                |m: &mut LoopOutRequest| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_swap_routing_fee",
                |m: &LoopOutRequest| { &m.max_swap_routing_fee },
                |m: &mut LoopOutRequest| { &mut m.max_swap_routing_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_prepay_routing_fee",
                |m: &LoopOutRequest| { &m.max_prepay_routing_fee },
                |m: &mut LoopOutRequest| { &mut m.max_prepay_routing_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_swap_fee",
                |m: &LoopOutRequest| { &m.max_swap_fee },
                |m: &mut LoopOutRequest| { &mut m.max_swap_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_prepay_amt",
                |m: &LoopOutRequest| { &m.max_prepay_amt },
                |m: &mut LoopOutRequest| { &mut m.max_prepay_amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_miner_fee",
                |m: &LoopOutRequest| { &m.max_miner_fee },
                |m: &mut LoopOutRequest| { &mut m.max_miner_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "loop_out_channel",
                |m: &LoopOutRequest| { &m.loop_out_channel },
                |m: &mut LoopOutRequest| { &mut m.loop_out_channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_chan_set",
                |m: &LoopOutRequest| { &m.outgoing_chan_set },
                |m: &mut LoopOutRequest| { &mut m.outgoing_chan_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sweep_conf_target",
                |m: &LoopOutRequest| { &m.sweep_conf_target },
                |m: &mut LoopOutRequest| { &mut m.sweep_conf_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "htlc_confirmations",
                |m: &LoopOutRequest| { &m.htlc_confirmations },
                |m: &mut LoopOutRequest| { &mut m.htlc_confirmations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "swap_publication_deadline",
                |m: &LoopOutRequest| { &m.swap_publication_deadline },
                |m: &mut LoopOutRequest| { &mut m.swap_publication_deadline },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &LoopOutRequest| { &m.label },
                |m: &mut LoopOutRequest| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initiator",
                |m: &LoopOutRequest| { &m.initiator },
                |m: &mut LoopOutRequest| { &mut m.initiator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoopOutRequest>(
                "LoopOutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoopOutRequest {
        static instance: ::protobuf::rt::LazyV2<LoopOutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoopOutRequest::new)
    }
}

impl ::protobuf::Clear for LoopOutRequest {
    fn clear(&mut self) {
        self.amt = 0;
        self.dest.clear();
        self.max_swap_routing_fee = 0;
        self.max_prepay_routing_fee = 0;
        self.max_swap_fee = 0;
        self.max_prepay_amt = 0;
        self.max_miner_fee = 0;
        self.loop_out_channel = 0;
        self.outgoing_chan_set.clear();
        self.sweep_conf_target = 0;
        self.htlc_confirmations = 0;
        self.swap_publication_deadline = 0;
        self.label.clear();
        self.initiator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoopOutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoopOutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LoopInRequest {
    // message fields
    pub amt: i64,
    pub max_swap_fee: i64,
    pub max_miner_fee: i64,
    pub last_hop: ::std::vec::Vec<u8>,
    pub external_htlc: bool,
    pub htlc_conf_target: i32,
    pub label: ::std::string::String,
    pub initiator: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoopInRequest {
    fn default() -> &'a LoopInRequest {
        <LoopInRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoopInRequest {
    pub fn new() -> LoopInRequest {
        ::std::default::Default::default()
    }

    // int64 amt = 1;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int64 max_swap_fee = 2;


    pub fn get_max_swap_fee(&self) -> i64 {
        self.max_swap_fee
    }
    pub fn clear_max_swap_fee(&mut self) {
        self.max_swap_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_fee(&mut self, v: i64) {
        self.max_swap_fee = v;
    }

    // int64 max_miner_fee = 3;


    pub fn get_max_miner_fee(&self) -> i64 {
        self.max_miner_fee
    }
    pub fn clear_max_miner_fee(&mut self) {
        self.max_miner_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_miner_fee(&mut self, v: i64) {
        self.max_miner_fee = v;
    }

    // bytes last_hop = 4;


    pub fn get_last_hop(&self) -> &[u8] {
        &self.last_hop
    }
    pub fn clear_last_hop(&mut self) {
        self.last_hop.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_hop(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_hop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_hop(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.last_hop
    }

    // Take field
    pub fn take_last_hop(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.last_hop, ::std::vec::Vec::new())
    }

    // bool external_htlc = 5;


    pub fn get_external_htlc(&self) -> bool {
        self.external_htlc
    }
    pub fn clear_external_htlc(&mut self) {
        self.external_htlc = false;
    }

    // Param is passed by value, moved
    pub fn set_external_htlc(&mut self, v: bool) {
        self.external_htlc = v;
    }

    // int32 htlc_conf_target = 6;


    pub fn get_htlc_conf_target(&self) -> i32 {
        self.htlc_conf_target
    }
    pub fn clear_htlc_conf_target(&mut self) {
        self.htlc_conf_target = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_conf_target(&mut self, v: i32) {
        self.htlc_conf_target = v;
    }

    // string label = 7;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string initiator = 8;


    pub fn get_initiator(&self) -> &str {
        &self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator.clear();
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        &mut self.initiator
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initiator, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LoopInRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_swap_fee = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_miner_fee = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.last_hop)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.external_htlc = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.htlc_conf_target = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initiator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_swap_fee != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_swap_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_miner_fee != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_miner_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.last_hop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.last_hop);
        }
        if self.external_htlc != false {
            my_size += 2;
        }
        if self.htlc_conf_target != 0 {
            my_size += ::protobuf::rt::value_size(6, self.htlc_conf_target, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.label);
        }
        if !self.initiator.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.initiator);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt != 0 {
            os.write_int64(1, self.amt)?;
        }
        if self.max_swap_fee != 0 {
            os.write_int64(2, self.max_swap_fee)?;
        }
        if self.max_miner_fee != 0 {
            os.write_int64(3, self.max_miner_fee)?;
        }
        if !self.last_hop.is_empty() {
            os.write_bytes(4, &self.last_hop)?;
        }
        if self.external_htlc != false {
            os.write_bool(5, self.external_htlc)?;
        }
        if self.htlc_conf_target != 0 {
            os.write_int32(6, self.htlc_conf_target)?;
        }
        if !self.label.is_empty() {
            os.write_string(7, &self.label)?;
        }
        if !self.initiator.is_empty() {
            os.write_string(8, &self.initiator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoopInRequest {
        LoopInRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &LoopInRequest| { &m.amt },
                |m: &mut LoopInRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_swap_fee",
                |m: &LoopInRequest| { &m.max_swap_fee },
                |m: &mut LoopInRequest| { &mut m.max_swap_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_miner_fee",
                |m: &LoopInRequest| { &m.max_miner_fee },
                |m: &mut LoopInRequest| { &mut m.max_miner_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "last_hop",
                |m: &LoopInRequest| { &m.last_hop },
                |m: &mut LoopInRequest| { &mut m.last_hop },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "external_htlc",
                |m: &LoopInRequest| { &m.external_htlc },
                |m: &mut LoopInRequest| { &mut m.external_htlc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "htlc_conf_target",
                |m: &LoopInRequest| { &m.htlc_conf_target },
                |m: &mut LoopInRequest| { &mut m.htlc_conf_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &LoopInRequest| { &m.label },
                |m: &mut LoopInRequest| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initiator",
                |m: &LoopInRequest| { &m.initiator },
                |m: &mut LoopInRequest| { &mut m.initiator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoopInRequest>(
                "LoopInRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoopInRequest {
        static instance: ::protobuf::rt::LazyV2<LoopInRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoopInRequest::new)
    }
}

impl ::protobuf::Clear for LoopInRequest {
    fn clear(&mut self) {
        self.amt = 0;
        self.max_swap_fee = 0;
        self.max_miner_fee = 0;
        self.last_hop.clear();
        self.external_htlc = false;
        self.htlc_conf_target = 0;
        self.label.clear();
        self.initiator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoopInRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoopInRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SwapResponse {
    // message fields
    pub id: ::std::string::String,
    pub id_bytes: ::std::vec::Vec<u8>,
    pub htlc_address: ::std::string::String,
    pub htlc_address_np2wsh: ::std::string::String,
    pub htlc_address_p2wsh: ::std::string::String,
    pub server_message: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwapResponse {
    fn default() -> &'a SwapResponse {
        <SwapResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwapResponse {
    pub fn new() -> SwapResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bytes id_bytes = 3;


    pub fn get_id_bytes(&self) -> &[u8] {
        &self.id_bytes
    }
    pub fn clear_id_bytes(&mut self) {
        self.id_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.id_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id_bytes
    }

    // Take field
    pub fn take_id_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id_bytes, ::std::vec::Vec::new())
    }

    // string htlc_address = 2;


    pub fn get_htlc_address(&self) -> &str {
        &self.htlc_address
    }
    pub fn clear_htlc_address(&mut self) {
        self.htlc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlc_address(&mut self, v: ::std::string::String) {
        self.htlc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htlc_address(&mut self) -> &mut ::std::string::String {
        &mut self.htlc_address
    }

    // Take field
    pub fn take_htlc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.htlc_address, ::std::string::String::new())
    }

    // string htlc_address_np2wsh = 4;


    pub fn get_htlc_address_np2wsh(&self) -> &str {
        &self.htlc_address_np2wsh
    }
    pub fn clear_htlc_address_np2wsh(&mut self) {
        self.htlc_address_np2wsh.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlc_address_np2wsh(&mut self, v: ::std::string::String) {
        self.htlc_address_np2wsh = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htlc_address_np2wsh(&mut self) -> &mut ::std::string::String {
        &mut self.htlc_address_np2wsh
    }

    // Take field
    pub fn take_htlc_address_np2wsh(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.htlc_address_np2wsh, ::std::string::String::new())
    }

    // string htlc_address_p2wsh = 5;


    pub fn get_htlc_address_p2wsh(&self) -> &str {
        &self.htlc_address_p2wsh
    }
    pub fn clear_htlc_address_p2wsh(&mut self) {
        self.htlc_address_p2wsh.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlc_address_p2wsh(&mut self, v: ::std::string::String) {
        self.htlc_address_p2wsh = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htlc_address_p2wsh(&mut self) -> &mut ::std::string::String {
        &mut self.htlc_address_p2wsh
    }

    // Take field
    pub fn take_htlc_address_p2wsh(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.htlc_address_p2wsh, ::std::string::String::new())
    }

    // string server_message = 6;


    pub fn get_server_message(&self) -> &str {
        &self.server_message
    }
    pub fn clear_server_message(&mut self) {
        self.server_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ::std::string::String) {
        self.server_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_message(&mut self) -> &mut ::std::string::String {
        &mut self.server_message
    }

    // Take field
    pub fn take_server_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server_message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SwapResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id_bytes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.htlc_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.htlc_address_np2wsh)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.htlc_address_p2wsh)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.id_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id_bytes);
        }
        if !self.htlc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.htlc_address);
        }
        if !self.htlc_address_np2wsh.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.htlc_address_np2wsh);
        }
        if !self.htlc_address_p2wsh.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.htlc_address_p2wsh);
        }
        if !self.server_message.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.server_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.id_bytes.is_empty() {
            os.write_bytes(3, &self.id_bytes)?;
        }
        if !self.htlc_address.is_empty() {
            os.write_string(2, &self.htlc_address)?;
        }
        if !self.htlc_address_np2wsh.is_empty() {
            os.write_string(4, &self.htlc_address_np2wsh)?;
        }
        if !self.htlc_address_p2wsh.is_empty() {
            os.write_string(5, &self.htlc_address_p2wsh)?;
        }
        if !self.server_message.is_empty() {
            os.write_string(6, &self.server_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwapResponse {
        SwapResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &SwapResponse| { &m.id },
                |m: &mut SwapResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id_bytes",
                |m: &SwapResponse| { &m.id_bytes },
                |m: &mut SwapResponse| { &mut m.id_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "htlc_address",
                |m: &SwapResponse| { &m.htlc_address },
                |m: &mut SwapResponse| { &mut m.htlc_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "htlc_address_np2wsh",
                |m: &SwapResponse| { &m.htlc_address_np2wsh },
                |m: &mut SwapResponse| { &mut m.htlc_address_np2wsh },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "htlc_address_p2wsh",
                |m: &SwapResponse| { &m.htlc_address_p2wsh },
                |m: &mut SwapResponse| { &mut m.htlc_address_p2wsh },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_message",
                |m: &SwapResponse| { &m.server_message },
                |m: &mut SwapResponse| { &mut m.server_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwapResponse>(
                "SwapResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwapResponse {
        static instance: ::protobuf::rt::LazyV2<SwapResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwapResponse::new)
    }
}

impl ::protobuf::Clear for SwapResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.id_bytes.clear();
        self.htlc_address.clear();
        self.htlc_address_np2wsh.clear();
        self.htlc_address_p2wsh.clear();
        self.server_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwapResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwapResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorRequest {
    fn default() -> &'a MonitorRequest {
        <MonitorRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorRequest {
    pub fn new() -> MonitorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MonitorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorRequest {
        MonitorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorRequest>(
                "MonitorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorRequest {
        static instance: ::protobuf::rt::LazyV2<MonitorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorRequest::new)
    }
}

impl ::protobuf::Clear for MonitorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SwapStatus {
    // message fields
    pub amt: i64,
    pub id: ::std::string::String,
    pub id_bytes: ::std::vec::Vec<u8>,
    pub field_type: SwapType,
    pub state: SwapState,
    pub failure_reason: FailureReason,
    pub initiation_time: i64,
    pub last_update_time: i64,
    pub htlc_address: ::std::string::String,
    pub htlc_address_p2wsh: ::std::string::String,
    pub htlc_address_np2wsh: ::std::string::String,
    pub cost_server: i64,
    pub cost_onchain: i64,
    pub cost_offchain: i64,
    pub label: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwapStatus {
    fn default() -> &'a SwapStatus {
        <SwapStatus as ::protobuf::Message>::default_instance()
    }
}

impl SwapStatus {
    pub fn new() -> SwapStatus {
        ::std::default::Default::default()
    }

    // int64 amt = 1;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bytes id_bytes = 11;


    pub fn get_id_bytes(&self) -> &[u8] {
        &self.id_bytes
    }
    pub fn clear_id_bytes(&mut self) {
        self.id_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.id_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id_bytes
    }

    // Take field
    pub fn take_id_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id_bytes, ::std::vec::Vec::new())
    }

    // .looprpc.SwapType type = 3;


    pub fn get_field_type(&self) -> SwapType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SwapType::LOOP_OUT;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SwapType) {
        self.field_type = v;
    }

    // .looprpc.SwapState state = 4;


    pub fn get_state(&self) -> SwapState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = SwapState::INITIATED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: SwapState) {
        self.state = v;
    }

    // .looprpc.FailureReason failure_reason = 14;


    pub fn get_failure_reason(&self) -> FailureReason {
        self.failure_reason
    }
    pub fn clear_failure_reason(&mut self) {
        self.failure_reason = FailureReason::FAILURE_REASON_NONE;
    }

    // Param is passed by value, moved
    pub fn set_failure_reason(&mut self, v: FailureReason) {
        self.failure_reason = v;
    }

    // int64 initiation_time = 5;


    pub fn get_initiation_time(&self) -> i64 {
        self.initiation_time
    }
    pub fn clear_initiation_time(&mut self) {
        self.initiation_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_initiation_time(&mut self, v: i64) {
        self.initiation_time = v;
    }

    // int64 last_update_time = 6;


    pub fn get_last_update_time(&self) -> i64 {
        self.last_update_time
    }
    pub fn clear_last_update_time(&mut self) {
        self.last_update_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update_time(&mut self, v: i64) {
        self.last_update_time = v;
    }

    // string htlc_address = 7;


    pub fn get_htlc_address(&self) -> &str {
        &self.htlc_address
    }
    pub fn clear_htlc_address(&mut self) {
        self.htlc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlc_address(&mut self, v: ::std::string::String) {
        self.htlc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htlc_address(&mut self) -> &mut ::std::string::String {
        &mut self.htlc_address
    }

    // Take field
    pub fn take_htlc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.htlc_address, ::std::string::String::new())
    }

    // string htlc_address_p2wsh = 12;


    pub fn get_htlc_address_p2wsh(&self) -> &str {
        &self.htlc_address_p2wsh
    }
    pub fn clear_htlc_address_p2wsh(&mut self) {
        self.htlc_address_p2wsh.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlc_address_p2wsh(&mut self, v: ::std::string::String) {
        self.htlc_address_p2wsh = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htlc_address_p2wsh(&mut self) -> &mut ::std::string::String {
        &mut self.htlc_address_p2wsh
    }

    // Take field
    pub fn take_htlc_address_p2wsh(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.htlc_address_p2wsh, ::std::string::String::new())
    }

    // string htlc_address_np2wsh = 13;


    pub fn get_htlc_address_np2wsh(&self) -> &str {
        &self.htlc_address_np2wsh
    }
    pub fn clear_htlc_address_np2wsh(&mut self) {
        self.htlc_address_np2wsh.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlc_address_np2wsh(&mut self, v: ::std::string::String) {
        self.htlc_address_np2wsh = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htlc_address_np2wsh(&mut self) -> &mut ::std::string::String {
        &mut self.htlc_address_np2wsh
    }

    // Take field
    pub fn take_htlc_address_np2wsh(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.htlc_address_np2wsh, ::std::string::String::new())
    }

    // int64 cost_server = 8;


    pub fn get_cost_server(&self) -> i64 {
        self.cost_server
    }
    pub fn clear_cost_server(&mut self) {
        self.cost_server = 0;
    }

    // Param is passed by value, moved
    pub fn set_cost_server(&mut self, v: i64) {
        self.cost_server = v;
    }

    // int64 cost_onchain = 9;


    pub fn get_cost_onchain(&self) -> i64 {
        self.cost_onchain
    }
    pub fn clear_cost_onchain(&mut self) {
        self.cost_onchain = 0;
    }

    // Param is passed by value, moved
    pub fn set_cost_onchain(&mut self, v: i64) {
        self.cost_onchain = v;
    }

    // int64 cost_offchain = 10;


    pub fn get_cost_offchain(&self) -> i64 {
        self.cost_offchain
    }
    pub fn clear_cost_offchain(&mut self) {
        self.cost_offchain = 0;
    }

    // Param is passed by value, moved
    pub fn set_cost_offchain(&mut self, v: i64) {
        self.cost_offchain = v;
    }

    // string label = 15;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SwapStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id_bytes)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 4, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.failure_reason, 14, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiation_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_update_time = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.htlc_address)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.htlc_address_p2wsh)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.htlc_address_np2wsh)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cost_server = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cost_onchain = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cost_offchain = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if !self.id_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.id_bytes);
        }
        if self.field_type != SwapType::LOOP_OUT {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if self.state != SwapState::INITIATED {
            my_size += ::protobuf::rt::enum_size(4, self.state);
        }
        if self.failure_reason != FailureReason::FAILURE_REASON_NONE {
            my_size += ::protobuf::rt::enum_size(14, self.failure_reason);
        }
        if self.initiation_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.initiation_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_update_time != 0 {
            my_size += ::protobuf::rt::value_size(6, self.last_update_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.htlc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.htlc_address);
        }
        if !self.htlc_address_p2wsh.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.htlc_address_p2wsh);
        }
        if !self.htlc_address_np2wsh.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.htlc_address_np2wsh);
        }
        if self.cost_server != 0 {
            my_size += ::protobuf::rt::value_size(8, self.cost_server, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cost_onchain != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cost_onchain, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cost_offchain != 0 {
            my_size += ::protobuf::rt::value_size(10, self.cost_offchain, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt != 0 {
            os.write_int64(1, self.amt)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if !self.id_bytes.is_empty() {
            os.write_bytes(11, &self.id_bytes)?;
        }
        if self.field_type != SwapType::LOOP_OUT {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.state != SwapState::INITIATED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.failure_reason != FailureReason::FAILURE_REASON_NONE {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.failure_reason))?;
        }
        if self.initiation_time != 0 {
            os.write_int64(5, self.initiation_time)?;
        }
        if self.last_update_time != 0 {
            os.write_int64(6, self.last_update_time)?;
        }
        if !self.htlc_address.is_empty() {
            os.write_string(7, &self.htlc_address)?;
        }
        if !self.htlc_address_p2wsh.is_empty() {
            os.write_string(12, &self.htlc_address_p2wsh)?;
        }
        if !self.htlc_address_np2wsh.is_empty() {
            os.write_string(13, &self.htlc_address_np2wsh)?;
        }
        if self.cost_server != 0 {
            os.write_int64(8, self.cost_server)?;
        }
        if self.cost_onchain != 0 {
            os.write_int64(9, self.cost_onchain)?;
        }
        if self.cost_offchain != 0 {
            os.write_int64(10, self.cost_offchain)?;
        }
        if !self.label.is_empty() {
            os.write_string(15, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwapStatus {
        SwapStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &SwapStatus| { &m.amt },
                |m: &mut SwapStatus| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &SwapStatus| { &m.id },
                |m: &mut SwapStatus| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id_bytes",
                |m: &SwapStatus| { &m.id_bytes },
                |m: &mut SwapStatus| { &mut m.id_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SwapType>>(
                "type",
                |m: &SwapStatus| { &m.field_type },
                |m: &mut SwapStatus| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SwapState>>(
                "state",
                |m: &SwapStatus| { &m.state },
                |m: &mut SwapStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FailureReason>>(
                "failure_reason",
                |m: &SwapStatus| { &m.failure_reason },
                |m: &mut SwapStatus| { &mut m.failure_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "initiation_time",
                |m: &SwapStatus| { &m.initiation_time },
                |m: &mut SwapStatus| { &mut m.initiation_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_update_time",
                |m: &SwapStatus| { &m.last_update_time },
                |m: &mut SwapStatus| { &mut m.last_update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "htlc_address",
                |m: &SwapStatus| { &m.htlc_address },
                |m: &mut SwapStatus| { &mut m.htlc_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "htlc_address_p2wsh",
                |m: &SwapStatus| { &m.htlc_address_p2wsh },
                |m: &mut SwapStatus| { &mut m.htlc_address_p2wsh },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "htlc_address_np2wsh",
                |m: &SwapStatus| { &m.htlc_address_np2wsh },
                |m: &mut SwapStatus| { &mut m.htlc_address_np2wsh },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cost_server",
                |m: &SwapStatus| { &m.cost_server },
                |m: &mut SwapStatus| { &mut m.cost_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cost_onchain",
                |m: &SwapStatus| { &m.cost_onchain },
                |m: &mut SwapStatus| { &mut m.cost_onchain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cost_offchain",
                |m: &SwapStatus| { &m.cost_offchain },
                |m: &mut SwapStatus| { &mut m.cost_offchain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &SwapStatus| { &m.label },
                |m: &mut SwapStatus| { &mut m.label },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwapStatus>(
                "SwapStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwapStatus {
        static instance: ::protobuf::rt::LazyV2<SwapStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwapStatus::new)
    }
}

impl ::protobuf::Clear for SwapStatus {
    fn clear(&mut self) {
        self.amt = 0;
        self.id.clear();
        self.id_bytes.clear();
        self.field_type = SwapType::LOOP_OUT;
        self.state = SwapState::INITIATED;
        self.failure_reason = FailureReason::FAILURE_REASON_NONE;
        self.initiation_time = 0;
        self.last_update_time = 0;
        self.htlc_address.clear();
        self.htlc_address_p2wsh.clear();
        self.htlc_address_np2wsh.clear();
        self.cost_server = 0;
        self.cost_onchain = 0;
        self.cost_offchain = 0;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwapStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwapStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListSwapsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSwapsRequest {
    fn default() -> &'a ListSwapsRequest {
        <ListSwapsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSwapsRequest {
    pub fn new() -> ListSwapsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListSwapsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSwapsRequest {
        ListSwapsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSwapsRequest>(
                "ListSwapsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSwapsRequest {
        static instance: ::protobuf::rt::LazyV2<ListSwapsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSwapsRequest::new)
    }
}

impl ::protobuf::Clear for ListSwapsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSwapsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSwapsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListSwapsResponse {
    // message fields
    pub swaps: ::protobuf::RepeatedField<SwapStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSwapsResponse {
    fn default() -> &'a ListSwapsResponse {
        <ListSwapsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSwapsResponse {
    pub fn new() -> ListSwapsResponse {
        ::std::default::Default::default()
    }

    // repeated .looprpc.SwapStatus swaps = 1;


    pub fn get_swaps(&self) -> &[SwapStatus] {
        &self.swaps
    }
    pub fn clear_swaps(&mut self) {
        self.swaps.clear();
    }

    // Param is passed by value, moved
    pub fn set_swaps(&mut self, v: ::protobuf::RepeatedField<SwapStatus>) {
        self.swaps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_swaps(&mut self) -> &mut ::protobuf::RepeatedField<SwapStatus> {
        &mut self.swaps
    }

    // Take field
    pub fn take_swaps(&mut self) -> ::protobuf::RepeatedField<SwapStatus> {
        ::std::mem::replace(&mut self.swaps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListSwapsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.swaps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.swaps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.swaps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.swaps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSwapsResponse {
        ListSwapsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SwapStatus>>(
                "swaps",
                |m: &ListSwapsResponse| { &m.swaps },
                |m: &mut ListSwapsResponse| { &mut m.swaps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSwapsResponse>(
                "ListSwapsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSwapsResponse {
        static instance: ::protobuf::rt::LazyV2<ListSwapsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSwapsResponse::new)
    }
}

impl ::protobuf::Clear for ListSwapsResponse {
    fn clear(&mut self) {
        self.swaps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSwapsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSwapsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SwapInfoRequest {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwapInfoRequest {
    fn default() -> &'a SwapInfoRequest {
        <SwapInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwapInfoRequest {
    pub fn new() -> SwapInfoRequest {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SwapInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwapInfoRequest {
        SwapInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &SwapInfoRequest| { &m.id },
                |m: &mut SwapInfoRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwapInfoRequest>(
                "SwapInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwapInfoRequest {
        static instance: ::protobuf::rt::LazyV2<SwapInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwapInfoRequest::new)
    }
}

impl ::protobuf::Clear for SwapInfoRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwapInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwapInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TermsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TermsRequest {
    fn default() -> &'a TermsRequest {
        <TermsRequest as ::protobuf::Message>::default_instance()
    }
}

impl TermsRequest {
    pub fn new() -> TermsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TermsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TermsRequest {
        TermsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TermsRequest>(
                "TermsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TermsRequest {
        static instance: ::protobuf::rt::LazyV2<TermsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TermsRequest::new)
    }
}

impl ::protobuf::Clear for TermsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TermsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TermsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InTermsResponse {
    // message fields
    pub min_swap_amount: i64,
    pub max_swap_amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InTermsResponse {
    fn default() -> &'a InTermsResponse {
        <InTermsResponse as ::protobuf::Message>::default_instance()
    }
}

impl InTermsResponse {
    pub fn new() -> InTermsResponse {
        ::std::default::Default::default()
    }

    // int64 min_swap_amount = 5;


    pub fn get_min_swap_amount(&self) -> i64 {
        self.min_swap_amount
    }
    pub fn clear_min_swap_amount(&mut self) {
        self.min_swap_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_swap_amount(&mut self, v: i64) {
        self.min_swap_amount = v;
    }

    // int64 max_swap_amount = 6;


    pub fn get_max_swap_amount(&self) -> i64 {
        self.max_swap_amount
    }
    pub fn clear_max_swap_amount(&mut self) {
        self.max_swap_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_amount(&mut self, v: i64) {
        self.max_swap_amount = v;
    }
}

impl ::protobuf::Message for InTermsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_swap_amount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_swap_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_swap_amount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.min_swap_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_swap_amount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_swap_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_swap_amount != 0 {
            os.write_int64(5, self.min_swap_amount)?;
        }
        if self.max_swap_amount != 0 {
            os.write_int64(6, self.max_swap_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InTermsResponse {
        InTermsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_swap_amount",
                |m: &InTermsResponse| { &m.min_swap_amount },
                |m: &mut InTermsResponse| { &mut m.min_swap_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_swap_amount",
                |m: &InTermsResponse| { &m.max_swap_amount },
                |m: &mut InTermsResponse| { &mut m.max_swap_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InTermsResponse>(
                "InTermsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InTermsResponse {
        static instance: ::protobuf::rt::LazyV2<InTermsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InTermsResponse::new)
    }
}

impl ::protobuf::Clear for InTermsResponse {
    fn clear(&mut self) {
        self.min_swap_amount = 0;
        self.max_swap_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InTermsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InTermsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OutTermsResponse {
    // message fields
    pub min_swap_amount: i64,
    pub max_swap_amount: i64,
    pub min_cltv_delta: i32,
    pub max_cltv_delta: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutTermsResponse {
    fn default() -> &'a OutTermsResponse {
        <OutTermsResponse as ::protobuf::Message>::default_instance()
    }
}

impl OutTermsResponse {
    pub fn new() -> OutTermsResponse {
        ::std::default::Default::default()
    }

    // int64 min_swap_amount = 5;


    pub fn get_min_swap_amount(&self) -> i64 {
        self.min_swap_amount
    }
    pub fn clear_min_swap_amount(&mut self) {
        self.min_swap_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_swap_amount(&mut self, v: i64) {
        self.min_swap_amount = v;
    }

    // int64 max_swap_amount = 6;


    pub fn get_max_swap_amount(&self) -> i64 {
        self.max_swap_amount
    }
    pub fn clear_max_swap_amount(&mut self) {
        self.max_swap_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_amount(&mut self, v: i64) {
        self.max_swap_amount = v;
    }

    // int32 min_cltv_delta = 8;


    pub fn get_min_cltv_delta(&self) -> i32 {
        self.min_cltv_delta
    }
    pub fn clear_min_cltv_delta(&mut self) {
        self.min_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_cltv_delta(&mut self, v: i32) {
        self.min_cltv_delta = v;
    }

    // int32 max_cltv_delta = 9;


    pub fn get_max_cltv_delta(&self) -> i32 {
        self.max_cltv_delta
    }
    pub fn clear_max_cltv_delta(&mut self) {
        self.max_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_cltv_delta(&mut self, v: i32) {
        self.max_cltv_delta = v;
    }
}

impl ::protobuf::Message for OutTermsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_swap_amount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_swap_amount = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_cltv_delta = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_cltv_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_swap_amount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.min_swap_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_swap_amount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_swap_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(8, self.min_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(9, self.max_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_swap_amount != 0 {
            os.write_int64(5, self.min_swap_amount)?;
        }
        if self.max_swap_amount != 0 {
            os.write_int64(6, self.max_swap_amount)?;
        }
        if self.min_cltv_delta != 0 {
            os.write_int32(8, self.min_cltv_delta)?;
        }
        if self.max_cltv_delta != 0 {
            os.write_int32(9, self.max_cltv_delta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutTermsResponse {
        OutTermsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_swap_amount",
                |m: &OutTermsResponse| { &m.min_swap_amount },
                |m: &mut OutTermsResponse| { &mut m.min_swap_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_swap_amount",
                |m: &OutTermsResponse| { &m.max_swap_amount },
                |m: &mut OutTermsResponse| { &mut m.max_swap_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_cltv_delta",
                |m: &OutTermsResponse| { &m.min_cltv_delta },
                |m: &mut OutTermsResponse| { &mut m.min_cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_cltv_delta",
                |m: &OutTermsResponse| { &m.max_cltv_delta },
                |m: &mut OutTermsResponse| { &mut m.max_cltv_delta },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutTermsResponse>(
                "OutTermsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutTermsResponse {
        static instance: ::protobuf::rt::LazyV2<OutTermsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutTermsResponse::new)
    }
}

impl ::protobuf::Clear for OutTermsResponse {
    fn clear(&mut self) {
        self.min_swap_amount = 0;
        self.max_swap_amount = 0;
        self.min_cltv_delta = 0;
        self.max_cltv_delta = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutTermsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutTermsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QuoteRequest {
    // message fields
    pub amt: i64,
    pub conf_target: i32,
    pub external_htlc: bool,
    pub swap_publication_deadline: u64,
    pub loop_in_last_hop: ::std::vec::Vec<u8>,
    pub loop_in_route_hints: ::protobuf::RepeatedField<super::common::RouteHint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuoteRequest {
    fn default() -> &'a QuoteRequest {
        <QuoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuoteRequest {
    pub fn new() -> QuoteRequest {
        ::std::default::Default::default()
    }

    // int64 amt = 1;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int32 conf_target = 2;


    pub fn get_conf_target(&self) -> i32 {
        self.conf_target
    }
    pub fn clear_conf_target(&mut self) {
        self.conf_target = 0;
    }

    // Param is passed by value, moved
    pub fn set_conf_target(&mut self, v: i32) {
        self.conf_target = v;
    }

    // bool external_htlc = 3;


    pub fn get_external_htlc(&self) -> bool {
        self.external_htlc
    }
    pub fn clear_external_htlc(&mut self) {
        self.external_htlc = false;
    }

    // Param is passed by value, moved
    pub fn set_external_htlc(&mut self, v: bool) {
        self.external_htlc = v;
    }

    // uint64 swap_publication_deadline = 4;


    pub fn get_swap_publication_deadline(&self) -> u64 {
        self.swap_publication_deadline
    }
    pub fn clear_swap_publication_deadline(&mut self) {
        self.swap_publication_deadline = 0;
    }

    // Param is passed by value, moved
    pub fn set_swap_publication_deadline(&mut self, v: u64) {
        self.swap_publication_deadline = v;
    }

    // bytes loop_in_last_hop = 5;


    pub fn get_loop_in_last_hop(&self) -> &[u8] {
        &self.loop_in_last_hop
    }
    pub fn clear_loop_in_last_hop(&mut self) {
        self.loop_in_last_hop.clear();
    }

    // Param is passed by value, moved
    pub fn set_loop_in_last_hop(&mut self, v: ::std::vec::Vec<u8>) {
        self.loop_in_last_hop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loop_in_last_hop(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.loop_in_last_hop
    }

    // Take field
    pub fn take_loop_in_last_hop(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.loop_in_last_hop, ::std::vec::Vec::new())
    }

    // repeated .looprpc.RouteHint loop_in_route_hints = 6;


    pub fn get_loop_in_route_hints(&self) -> &[super::common::RouteHint] {
        &self.loop_in_route_hints
    }
    pub fn clear_loop_in_route_hints(&mut self) {
        self.loop_in_route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_loop_in_route_hints(&mut self, v: ::protobuf::RepeatedField<super::common::RouteHint>) {
        self.loop_in_route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loop_in_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<super::common::RouteHint> {
        &mut self.loop_in_route_hints
    }

    // Take field
    pub fn take_loop_in_route_hints(&mut self) -> ::protobuf::RepeatedField<super::common::RouteHint> {
        ::std::mem::replace(&mut self.loop_in_route_hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuoteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.loop_in_route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.conf_target = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.external_htlc = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.swap_publication_deadline = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.loop_in_last_hop)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.loop_in_route_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.conf_target != 0 {
            my_size += ::protobuf::rt::value_size(2, self.conf_target, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.external_htlc != false {
            my_size += 2;
        }
        if self.swap_publication_deadline != 0 {
            my_size += ::protobuf::rt::value_size(4, self.swap_publication_deadline, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.loop_in_last_hop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.loop_in_last_hop);
        }
        for value in &self.loop_in_route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt != 0 {
            os.write_int64(1, self.amt)?;
        }
        if self.conf_target != 0 {
            os.write_int32(2, self.conf_target)?;
        }
        if self.external_htlc != false {
            os.write_bool(3, self.external_htlc)?;
        }
        if self.swap_publication_deadline != 0 {
            os.write_uint64(4, self.swap_publication_deadline)?;
        }
        if !self.loop_in_last_hop.is_empty() {
            os.write_bytes(5, &self.loop_in_last_hop)?;
        }
        for v in &self.loop_in_route_hints {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuoteRequest {
        QuoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &QuoteRequest| { &m.amt },
                |m: &mut QuoteRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "conf_target",
                |m: &QuoteRequest| { &m.conf_target },
                |m: &mut QuoteRequest| { &mut m.conf_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "external_htlc",
                |m: &QuoteRequest| { &m.external_htlc },
                |m: &mut QuoteRequest| { &mut m.external_htlc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "swap_publication_deadline",
                |m: &QuoteRequest| { &m.swap_publication_deadline },
                |m: &mut QuoteRequest| { &mut m.swap_publication_deadline },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "loop_in_last_hop",
                |m: &QuoteRequest| { &m.loop_in_last_hop },
                |m: &mut QuoteRequest| { &mut m.loop_in_last_hop },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::RouteHint>>(
                "loop_in_route_hints",
                |m: &QuoteRequest| { &m.loop_in_route_hints },
                |m: &mut QuoteRequest| { &mut m.loop_in_route_hints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuoteRequest>(
                "QuoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuoteRequest {
        static instance: ::protobuf::rt::LazyV2<QuoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuoteRequest::new)
    }
}

impl ::protobuf::Clear for QuoteRequest {
    fn clear(&mut self) {
        self.amt = 0;
        self.conf_target = 0;
        self.external_htlc = false;
        self.swap_publication_deadline = 0;
        self.loop_in_last_hop.clear();
        self.loop_in_route_hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InQuoteResponse {
    // message fields
    pub swap_fee_sat: i64,
    pub htlc_publish_fee_sat: i64,
    pub cltv_delta: i32,
    pub conf_target: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InQuoteResponse {
    fn default() -> &'a InQuoteResponse {
        <InQuoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl InQuoteResponse {
    pub fn new() -> InQuoteResponse {
        ::std::default::Default::default()
    }

    // int64 swap_fee_sat = 1;


    pub fn get_swap_fee_sat(&self) -> i64 {
        self.swap_fee_sat
    }
    pub fn clear_swap_fee_sat(&mut self) {
        self.swap_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_swap_fee_sat(&mut self, v: i64) {
        self.swap_fee_sat = v;
    }

    // int64 htlc_publish_fee_sat = 3;


    pub fn get_htlc_publish_fee_sat(&self) -> i64 {
        self.htlc_publish_fee_sat
    }
    pub fn clear_htlc_publish_fee_sat(&mut self) {
        self.htlc_publish_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_publish_fee_sat(&mut self, v: i64) {
        self.htlc_publish_fee_sat = v;
    }

    // int32 cltv_delta = 5;


    pub fn get_cltv_delta(&self) -> i32 {
        self.cltv_delta
    }
    pub fn clear_cltv_delta(&mut self) {
        self.cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_delta(&mut self, v: i32) {
        self.cltv_delta = v;
    }

    // int32 conf_target = 6;


    pub fn get_conf_target(&self) -> i32 {
        self.conf_target
    }
    pub fn clear_conf_target(&mut self) {
        self.conf_target = 0;
    }

    // Param is passed by value, moved
    pub fn set_conf_target(&mut self, v: i32) {
        self.conf_target = v;
    }
}

impl ::protobuf::Message for InQuoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.swap_fee_sat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.htlc_publish_fee_sat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cltv_delta = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.conf_target = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.swap_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.swap_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_publish_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.htlc_publish_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.conf_target != 0 {
            my_size += ::protobuf::rt::value_size(6, self.conf_target, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.swap_fee_sat != 0 {
            os.write_int64(1, self.swap_fee_sat)?;
        }
        if self.htlc_publish_fee_sat != 0 {
            os.write_int64(3, self.htlc_publish_fee_sat)?;
        }
        if self.cltv_delta != 0 {
            os.write_int32(5, self.cltv_delta)?;
        }
        if self.conf_target != 0 {
            os.write_int32(6, self.conf_target)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InQuoteResponse {
        InQuoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "swap_fee_sat",
                |m: &InQuoteResponse| { &m.swap_fee_sat },
                |m: &mut InQuoteResponse| { &mut m.swap_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "htlc_publish_fee_sat",
                |m: &InQuoteResponse| { &m.htlc_publish_fee_sat },
                |m: &mut InQuoteResponse| { &mut m.htlc_publish_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cltv_delta",
                |m: &InQuoteResponse| { &m.cltv_delta },
                |m: &mut InQuoteResponse| { &mut m.cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "conf_target",
                |m: &InQuoteResponse| { &m.conf_target },
                |m: &mut InQuoteResponse| { &mut m.conf_target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InQuoteResponse>(
                "InQuoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InQuoteResponse {
        static instance: ::protobuf::rt::LazyV2<InQuoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InQuoteResponse::new)
    }
}

impl ::protobuf::Clear for InQuoteResponse {
    fn clear(&mut self) {
        self.swap_fee_sat = 0;
        self.htlc_publish_fee_sat = 0;
        self.cltv_delta = 0;
        self.conf_target = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InQuoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InQuoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OutQuoteResponse {
    // message fields
    pub swap_fee_sat: i64,
    pub prepay_amt_sat: i64,
    pub htlc_sweep_fee_sat: i64,
    pub swap_payment_dest: ::std::vec::Vec<u8>,
    pub cltv_delta: i32,
    pub conf_target: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutQuoteResponse {
    fn default() -> &'a OutQuoteResponse {
        <OutQuoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl OutQuoteResponse {
    pub fn new() -> OutQuoteResponse {
        ::std::default::Default::default()
    }

    // int64 swap_fee_sat = 1;


    pub fn get_swap_fee_sat(&self) -> i64 {
        self.swap_fee_sat
    }
    pub fn clear_swap_fee_sat(&mut self) {
        self.swap_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_swap_fee_sat(&mut self, v: i64) {
        self.swap_fee_sat = v;
    }

    // int64 prepay_amt_sat = 2;


    pub fn get_prepay_amt_sat(&self) -> i64 {
        self.prepay_amt_sat
    }
    pub fn clear_prepay_amt_sat(&mut self) {
        self.prepay_amt_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_prepay_amt_sat(&mut self, v: i64) {
        self.prepay_amt_sat = v;
    }

    // int64 htlc_sweep_fee_sat = 3;


    pub fn get_htlc_sweep_fee_sat(&self) -> i64 {
        self.htlc_sweep_fee_sat
    }
    pub fn clear_htlc_sweep_fee_sat(&mut self) {
        self.htlc_sweep_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_sweep_fee_sat(&mut self, v: i64) {
        self.htlc_sweep_fee_sat = v;
    }

    // bytes swap_payment_dest = 4;


    pub fn get_swap_payment_dest(&self) -> &[u8] {
        &self.swap_payment_dest
    }
    pub fn clear_swap_payment_dest(&mut self) {
        self.swap_payment_dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_swap_payment_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.swap_payment_dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swap_payment_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.swap_payment_dest
    }

    // Take field
    pub fn take_swap_payment_dest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.swap_payment_dest, ::std::vec::Vec::new())
    }

    // int32 cltv_delta = 5;


    pub fn get_cltv_delta(&self) -> i32 {
        self.cltv_delta
    }
    pub fn clear_cltv_delta(&mut self) {
        self.cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_delta(&mut self, v: i32) {
        self.cltv_delta = v;
    }

    // int32 conf_target = 6;


    pub fn get_conf_target(&self) -> i32 {
        self.conf_target
    }
    pub fn clear_conf_target(&mut self) {
        self.conf_target = 0;
    }

    // Param is passed by value, moved
    pub fn set_conf_target(&mut self, v: i32) {
        self.conf_target = v;
    }
}

impl ::protobuf::Message for OutQuoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.swap_fee_sat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepay_amt_sat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.htlc_sweep_fee_sat = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.swap_payment_dest)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cltv_delta = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.conf_target = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.swap_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.swap_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prepay_amt_sat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.prepay_amt_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_sweep_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.htlc_sweep_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.swap_payment_dest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.swap_payment_dest);
        }
        if self.cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.conf_target != 0 {
            my_size += ::protobuf::rt::value_size(6, self.conf_target, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.swap_fee_sat != 0 {
            os.write_int64(1, self.swap_fee_sat)?;
        }
        if self.prepay_amt_sat != 0 {
            os.write_int64(2, self.prepay_amt_sat)?;
        }
        if self.htlc_sweep_fee_sat != 0 {
            os.write_int64(3, self.htlc_sweep_fee_sat)?;
        }
        if !self.swap_payment_dest.is_empty() {
            os.write_bytes(4, &self.swap_payment_dest)?;
        }
        if self.cltv_delta != 0 {
            os.write_int32(5, self.cltv_delta)?;
        }
        if self.conf_target != 0 {
            os.write_int32(6, self.conf_target)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutQuoteResponse {
        OutQuoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "swap_fee_sat",
                |m: &OutQuoteResponse| { &m.swap_fee_sat },
                |m: &mut OutQuoteResponse| { &mut m.swap_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "prepay_amt_sat",
                |m: &OutQuoteResponse| { &m.prepay_amt_sat },
                |m: &mut OutQuoteResponse| { &mut m.prepay_amt_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "htlc_sweep_fee_sat",
                |m: &OutQuoteResponse| { &m.htlc_sweep_fee_sat },
                |m: &mut OutQuoteResponse| { &mut m.htlc_sweep_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "swap_payment_dest",
                |m: &OutQuoteResponse| { &m.swap_payment_dest },
                |m: &mut OutQuoteResponse| { &mut m.swap_payment_dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cltv_delta",
                |m: &OutQuoteResponse| { &m.cltv_delta },
                |m: &mut OutQuoteResponse| { &mut m.cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "conf_target",
                |m: &OutQuoteResponse| { &m.conf_target },
                |m: &mut OutQuoteResponse| { &mut m.conf_target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutQuoteResponse>(
                "OutQuoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutQuoteResponse {
        static instance: ::protobuf::rt::LazyV2<OutQuoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutQuoteResponse::new)
    }
}

impl ::protobuf::Clear for OutQuoteResponse {
    fn clear(&mut self) {
        self.swap_fee_sat = 0;
        self.prepay_amt_sat = 0;
        self.htlc_sweep_fee_sat = 0;
        self.swap_payment_dest.clear();
        self.cltv_delta = 0;
        self.conf_target = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutQuoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutQuoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProbeRequest {
    // message fields
    pub amt: i64,
    pub last_hop: ::std::vec::Vec<u8>,
    pub route_hints: ::protobuf::RepeatedField<super::common::RouteHint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProbeRequest {
    fn default() -> &'a ProbeRequest {
        <ProbeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ProbeRequest {
    pub fn new() -> ProbeRequest {
        ::std::default::Default::default()
    }

    // int64 amt = 1;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // bytes last_hop = 2;


    pub fn get_last_hop(&self) -> &[u8] {
        &self.last_hop
    }
    pub fn clear_last_hop(&mut self) {
        self.last_hop.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_hop(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_hop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_hop(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.last_hop
    }

    // Take field
    pub fn take_last_hop(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.last_hop, ::std::vec::Vec::new())
    }

    // repeated .looprpc.RouteHint route_hints = 3;


    pub fn get_route_hints(&self) -> &[super::common::RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<super::common::RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<super::common::RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<super::common::RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProbeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.last_hop)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.last_hop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.last_hop);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt != 0 {
            os.write_int64(1, self.amt)?;
        }
        if !self.last_hop.is_empty() {
            os.write_bytes(2, &self.last_hop)?;
        }
        for v in &self.route_hints {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProbeRequest {
        ProbeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &ProbeRequest| { &m.amt },
                |m: &mut ProbeRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "last_hop",
                |m: &ProbeRequest| { &m.last_hop },
                |m: &mut ProbeRequest| { &mut m.last_hop },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::RouteHint>>(
                "route_hints",
                |m: &ProbeRequest| { &m.route_hints },
                |m: &mut ProbeRequest| { &mut m.route_hints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProbeRequest>(
                "ProbeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProbeRequest {
        static instance: ::protobuf::rt::LazyV2<ProbeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProbeRequest::new)
    }
}

impl ::protobuf::Clear for ProbeRequest {
    fn clear(&mut self) {
        self.amt = 0;
        self.last_hop.clear();
        self.route_hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProbeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProbeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProbeResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProbeResponse {
    fn default() -> &'a ProbeResponse {
        <ProbeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ProbeResponse {
    pub fn new() -> ProbeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ProbeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProbeResponse {
        ProbeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProbeResponse>(
                "ProbeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProbeResponse {
        static instance: ::protobuf::rt::LazyV2<ProbeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProbeResponse::new)
    }
}

impl ::protobuf::Clear for ProbeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProbeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProbeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TokensRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokensRequest {
    fn default() -> &'a TokensRequest {
        <TokensRequest as ::protobuf::Message>::default_instance()
    }
}

impl TokensRequest {
    pub fn new() -> TokensRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TokensRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokensRequest {
        TokensRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TokensRequest>(
                "TokensRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TokensRequest {
        static instance: ::protobuf::rt::LazyV2<TokensRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TokensRequest::new)
    }
}

impl ::protobuf::Clear for TokensRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TokensRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokensRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TokensResponse {
    // message fields
    pub tokens: ::protobuf::RepeatedField<LsatToken>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokensResponse {
    fn default() -> &'a TokensResponse {
        <TokensResponse as ::protobuf::Message>::default_instance()
    }
}

impl TokensResponse {
    pub fn new() -> TokensResponse {
        ::std::default::Default::default()
    }

    // repeated .looprpc.LsatToken tokens = 1;


    pub fn get_tokens(&self) -> &[LsatToken] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<LsatToken>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<LsatToken> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<LsatToken> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TokensResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tokens {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokensResponse {
        TokensResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsatToken>>(
                "tokens",
                |m: &TokensResponse| { &m.tokens },
                |m: &mut TokensResponse| { &mut m.tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TokensResponse>(
                "TokensResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TokensResponse {
        static instance: ::protobuf::rt::LazyV2<TokensResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TokensResponse::new)
    }
}

impl ::protobuf::Clear for TokensResponse {
    fn clear(&mut self) {
        self.tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TokensResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokensResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LsatToken {
    // message fields
    pub base_macaroon: ::std::vec::Vec<u8>,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_preimage: ::std::vec::Vec<u8>,
    pub amount_paid_msat: i64,
    pub routing_fee_paid_msat: i64,
    pub time_created: i64,
    pub expired: bool,
    pub storage_name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsatToken {
    fn default() -> &'a LsatToken {
        <LsatToken as ::protobuf::Message>::default_instance()
    }
}

impl LsatToken {
    pub fn new() -> LsatToken {
        ::std::default::Default::default()
    }

    // bytes base_macaroon = 1;


    pub fn get_base_macaroon(&self) -> &[u8] {
        &self.base_macaroon
    }
    pub fn clear_base_macaroon(&mut self) {
        self.base_macaroon.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_macaroon(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_macaroon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_macaroon(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.base_macaroon
    }

    // Take field
    pub fn take_base_macaroon(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.base_macaroon, ::std::vec::Vec::new())
    }

    // bytes payment_hash = 2;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // bytes payment_preimage = 3;


    pub fn get_payment_preimage(&self) -> &[u8] {
        &self.payment_preimage
    }
    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_preimage, ::std::vec::Vec::new())
    }

    // int64 amount_paid_msat = 4;


    pub fn get_amount_paid_msat(&self) -> i64 {
        self.amount_paid_msat
    }
    pub fn clear_amount_paid_msat(&mut self) {
        self.amount_paid_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount_paid_msat(&mut self, v: i64) {
        self.amount_paid_msat = v;
    }

    // int64 routing_fee_paid_msat = 5;


    pub fn get_routing_fee_paid_msat(&self) -> i64 {
        self.routing_fee_paid_msat
    }
    pub fn clear_routing_fee_paid_msat(&mut self) {
        self.routing_fee_paid_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_routing_fee_paid_msat(&mut self, v: i64) {
        self.routing_fee_paid_msat = v;
    }

    // int64 time_created = 6;


    pub fn get_time_created(&self) -> i64 {
        self.time_created
    }
    pub fn clear_time_created(&mut self) {
        self.time_created = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: i64) {
        self.time_created = v;
    }

    // bool expired = 7;


    pub fn get_expired(&self) -> bool {
        self.expired
    }
    pub fn clear_expired(&mut self) {
        self.expired = false;
    }

    // Param is passed by value, moved
    pub fn set_expired(&mut self, v: bool) {
        self.expired = v;
    }

    // string storage_name = 8;


    pub fn get_storage_name(&self) -> &str {
        &self.storage_name
    }
    pub fn clear_storage_name(&mut self) {
        self.storage_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_name(&mut self, v: ::std::string::String) {
        self.storage_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_name(&mut self) -> &mut ::std::string::String {
        &mut self.storage_name
    }

    // Take field
    pub fn take_storage_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LsatToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.base_macaroon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_preimage)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount_paid_msat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.routing_fee_paid_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_created = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expired = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.base_macaroon.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.base_macaroon);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payment_hash);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payment_preimage);
        }
        if self.amount_paid_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount_paid_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.routing_fee_paid_msat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.routing_fee_paid_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_created != 0 {
            my_size += ::protobuf::rt::value_size(6, self.time_created, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expired != false {
            my_size += 2;
        }
        if !self.storage_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.storage_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.base_macaroon.is_empty() {
            os.write_bytes(1, &self.base_macaroon)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(2, &self.payment_hash)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_bytes(3, &self.payment_preimage)?;
        }
        if self.amount_paid_msat != 0 {
            os.write_int64(4, self.amount_paid_msat)?;
        }
        if self.routing_fee_paid_msat != 0 {
            os.write_int64(5, self.routing_fee_paid_msat)?;
        }
        if self.time_created != 0 {
            os.write_int64(6, self.time_created)?;
        }
        if self.expired != false {
            os.write_bool(7, self.expired)?;
        }
        if !self.storage_name.is_empty() {
            os.write_string(8, &self.storage_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsatToken {
        LsatToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "base_macaroon",
                |m: &LsatToken| { &m.base_macaroon },
                |m: &mut LsatToken| { &mut m.base_macaroon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &LsatToken| { &m.payment_hash },
                |m: &mut LsatToken| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_preimage",
                |m: &LsatToken| { &m.payment_preimage },
                |m: &mut LsatToken| { &mut m.payment_preimage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount_paid_msat",
                |m: &LsatToken| { &m.amount_paid_msat },
                |m: &mut LsatToken| { &mut m.amount_paid_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "routing_fee_paid_msat",
                |m: &LsatToken| { &m.routing_fee_paid_msat },
                |m: &mut LsatToken| { &mut m.routing_fee_paid_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "time_created",
                |m: &LsatToken| { &m.time_created },
                |m: &mut LsatToken| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expired",
                |m: &LsatToken| { &m.expired },
                |m: &mut LsatToken| { &mut m.expired },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storage_name",
                |m: &LsatToken| { &m.storage_name },
                |m: &mut LsatToken| { &mut m.storage_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LsatToken>(
                "LsatToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LsatToken {
        static instance: ::protobuf::rt::LazyV2<LsatToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LsatToken::new)
    }
}

impl ::protobuf::Clear for LsatToken {
    fn clear(&mut self) {
        self.base_macaroon.clear();
        self.payment_hash.clear();
        self.payment_preimage.clear();
        self.amount_paid_msat = 0;
        self.routing_fee_paid_msat = 0;
        self.time_created = 0;
        self.expired = false;
        self.storage_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsatToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsatToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetLiquidityParamsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLiquidityParamsRequest {
    fn default() -> &'a GetLiquidityParamsRequest {
        <GetLiquidityParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLiquidityParamsRequest {
    pub fn new() -> GetLiquidityParamsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetLiquidityParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLiquidityParamsRequest {
        GetLiquidityParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLiquidityParamsRequest>(
                "GetLiquidityParamsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLiquidityParamsRequest {
        static instance: ::protobuf::rt::LazyV2<GetLiquidityParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLiquidityParamsRequest::new)
    }
}

impl ::protobuf::Clear for GetLiquidityParamsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLiquidityParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLiquidityParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LiquidityParameters {
    // message fields
    pub rules: ::protobuf::RepeatedField<LiquidityRule>,
    pub fee_ppm: u64,
    pub sweep_fee_rate_sat_per_vbyte: u64,
    pub max_swap_fee_ppm: u64,
    pub max_routing_fee_ppm: u64,
    pub max_prepay_routing_fee_ppm: u64,
    pub max_prepay_sat: u64,
    pub max_miner_fee_sat: u64,
    pub sweep_conf_target: i32,
    pub failure_backoff_sec: u64,
    pub autoloop: bool,
    pub autoloop_budget_sat: u64,
    pub autoloop_budget_start_sec: u64,
    pub auto_max_in_flight: u64,
    pub min_swap_amount: u64,
    pub max_swap_amount: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LiquidityParameters {
    fn default() -> &'a LiquidityParameters {
        <LiquidityParameters as ::protobuf::Message>::default_instance()
    }
}

impl LiquidityParameters {
    pub fn new() -> LiquidityParameters {
        ::std::default::Default::default()
    }

    // repeated .looprpc.LiquidityRule rules = 1;


    pub fn get_rules(&self) -> &[LiquidityRule] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<LiquidityRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<LiquidityRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<LiquidityRule> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }

    // uint64 fee_ppm = 16;


    pub fn get_fee_ppm(&self) -> u64 {
        self.fee_ppm
    }
    pub fn clear_fee_ppm(&mut self) {
        self.fee_ppm = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_ppm(&mut self, v: u64) {
        self.fee_ppm = v;
    }

    // uint64 sweep_fee_rate_sat_per_vbyte = 2;


    pub fn get_sweep_fee_rate_sat_per_vbyte(&self) -> u64 {
        self.sweep_fee_rate_sat_per_vbyte
    }
    pub fn clear_sweep_fee_rate_sat_per_vbyte(&mut self) {
        self.sweep_fee_rate_sat_per_vbyte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sweep_fee_rate_sat_per_vbyte(&mut self, v: u64) {
        self.sweep_fee_rate_sat_per_vbyte = v;
    }

    // uint64 max_swap_fee_ppm = 3;


    pub fn get_max_swap_fee_ppm(&self) -> u64 {
        self.max_swap_fee_ppm
    }
    pub fn clear_max_swap_fee_ppm(&mut self) {
        self.max_swap_fee_ppm = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_fee_ppm(&mut self, v: u64) {
        self.max_swap_fee_ppm = v;
    }

    // uint64 max_routing_fee_ppm = 4;


    pub fn get_max_routing_fee_ppm(&self) -> u64 {
        self.max_routing_fee_ppm
    }
    pub fn clear_max_routing_fee_ppm(&mut self) {
        self.max_routing_fee_ppm = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_routing_fee_ppm(&mut self, v: u64) {
        self.max_routing_fee_ppm = v;
    }

    // uint64 max_prepay_routing_fee_ppm = 5;


    pub fn get_max_prepay_routing_fee_ppm(&self) -> u64 {
        self.max_prepay_routing_fee_ppm
    }
    pub fn clear_max_prepay_routing_fee_ppm(&mut self) {
        self.max_prepay_routing_fee_ppm = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_prepay_routing_fee_ppm(&mut self, v: u64) {
        self.max_prepay_routing_fee_ppm = v;
    }

    // uint64 max_prepay_sat = 6;


    pub fn get_max_prepay_sat(&self) -> u64 {
        self.max_prepay_sat
    }
    pub fn clear_max_prepay_sat(&mut self) {
        self.max_prepay_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_prepay_sat(&mut self, v: u64) {
        self.max_prepay_sat = v;
    }

    // uint64 max_miner_fee_sat = 7;


    pub fn get_max_miner_fee_sat(&self) -> u64 {
        self.max_miner_fee_sat
    }
    pub fn clear_max_miner_fee_sat(&mut self) {
        self.max_miner_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_miner_fee_sat(&mut self, v: u64) {
        self.max_miner_fee_sat = v;
    }

    // int32 sweep_conf_target = 8;


    pub fn get_sweep_conf_target(&self) -> i32 {
        self.sweep_conf_target
    }
    pub fn clear_sweep_conf_target(&mut self) {
        self.sweep_conf_target = 0;
    }

    // Param is passed by value, moved
    pub fn set_sweep_conf_target(&mut self, v: i32) {
        self.sweep_conf_target = v;
    }

    // uint64 failure_backoff_sec = 9;


    pub fn get_failure_backoff_sec(&self) -> u64 {
        self.failure_backoff_sec
    }
    pub fn clear_failure_backoff_sec(&mut self) {
        self.failure_backoff_sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_failure_backoff_sec(&mut self, v: u64) {
        self.failure_backoff_sec = v;
    }

    // bool autoloop = 10;


    pub fn get_autoloop(&self) -> bool {
        self.autoloop
    }
    pub fn clear_autoloop(&mut self) {
        self.autoloop = false;
    }

    // Param is passed by value, moved
    pub fn set_autoloop(&mut self, v: bool) {
        self.autoloop = v;
    }

    // uint64 autoloop_budget_sat = 11;


    pub fn get_autoloop_budget_sat(&self) -> u64 {
        self.autoloop_budget_sat
    }
    pub fn clear_autoloop_budget_sat(&mut self) {
        self.autoloop_budget_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_autoloop_budget_sat(&mut self, v: u64) {
        self.autoloop_budget_sat = v;
    }

    // uint64 autoloop_budget_start_sec = 12;


    pub fn get_autoloop_budget_start_sec(&self) -> u64 {
        self.autoloop_budget_start_sec
    }
    pub fn clear_autoloop_budget_start_sec(&mut self) {
        self.autoloop_budget_start_sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_autoloop_budget_start_sec(&mut self, v: u64) {
        self.autoloop_budget_start_sec = v;
    }

    // uint64 auto_max_in_flight = 13;


    pub fn get_auto_max_in_flight(&self) -> u64 {
        self.auto_max_in_flight
    }
    pub fn clear_auto_max_in_flight(&mut self) {
        self.auto_max_in_flight = 0;
    }

    // Param is passed by value, moved
    pub fn set_auto_max_in_flight(&mut self, v: u64) {
        self.auto_max_in_flight = v;
    }

    // uint64 min_swap_amount = 14;


    pub fn get_min_swap_amount(&self) -> u64 {
        self.min_swap_amount
    }
    pub fn clear_min_swap_amount(&mut self) {
        self.min_swap_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_swap_amount(&mut self, v: u64) {
        self.min_swap_amount = v;
    }

    // uint64 max_swap_amount = 15;


    pub fn get_max_swap_amount(&self) -> u64 {
        self.max_swap_amount
    }
    pub fn clear_max_swap_amount(&mut self) {
        self.max_swap_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_swap_amount(&mut self, v: u64) {
        self.max_swap_amount = v;
    }
}

impl ::protobuf::Message for LiquidityParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee_ppm = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sweep_fee_rate_sat_per_vbyte = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_swap_fee_ppm = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_routing_fee_ppm = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_prepay_routing_fee_ppm = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_prepay_sat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_miner_fee_sat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sweep_conf_target = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failure_backoff_sec = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoloop = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.autoloop_budget_sat = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.autoloop_budget_start_sec = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.auto_max_in_flight = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_swap_amount = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_swap_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.fee_ppm != 0 {
            my_size += ::protobuf::rt::value_size(16, self.fee_ppm, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sweep_fee_rate_sat_per_vbyte != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sweep_fee_rate_sat_per_vbyte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_swap_fee_ppm != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_swap_fee_ppm, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_routing_fee_ppm != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_routing_fee_ppm, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_prepay_routing_fee_ppm != 0 {
            my_size += ::protobuf::rt::value_size(5, self.max_prepay_routing_fee_ppm, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_prepay_sat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_prepay_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_miner_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.max_miner_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sweep_conf_target != 0 {
            my_size += ::protobuf::rt::value_size(8, self.sweep_conf_target, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failure_backoff_sec != 0 {
            my_size += ::protobuf::rt::value_size(9, self.failure_backoff_sec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autoloop != false {
            my_size += 2;
        }
        if self.autoloop_budget_sat != 0 {
            my_size += ::protobuf::rt::value_size(11, self.autoloop_budget_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autoloop_budget_start_sec != 0 {
            my_size += ::protobuf::rt::value_size(12, self.autoloop_budget_start_sec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.auto_max_in_flight != 0 {
            my_size += ::protobuf::rt::value_size(13, self.auto_max_in_flight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_swap_amount != 0 {
            my_size += ::protobuf::rt::value_size(14, self.min_swap_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_swap_amount != 0 {
            my_size += ::protobuf::rt::value_size(15, self.max_swap_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.fee_ppm != 0 {
            os.write_uint64(16, self.fee_ppm)?;
        }
        if self.sweep_fee_rate_sat_per_vbyte != 0 {
            os.write_uint64(2, self.sweep_fee_rate_sat_per_vbyte)?;
        }
        if self.max_swap_fee_ppm != 0 {
            os.write_uint64(3, self.max_swap_fee_ppm)?;
        }
        if self.max_routing_fee_ppm != 0 {
            os.write_uint64(4, self.max_routing_fee_ppm)?;
        }
        if self.max_prepay_routing_fee_ppm != 0 {
            os.write_uint64(5, self.max_prepay_routing_fee_ppm)?;
        }
        if self.max_prepay_sat != 0 {
            os.write_uint64(6, self.max_prepay_sat)?;
        }
        if self.max_miner_fee_sat != 0 {
            os.write_uint64(7, self.max_miner_fee_sat)?;
        }
        if self.sweep_conf_target != 0 {
            os.write_int32(8, self.sweep_conf_target)?;
        }
        if self.failure_backoff_sec != 0 {
            os.write_uint64(9, self.failure_backoff_sec)?;
        }
        if self.autoloop != false {
            os.write_bool(10, self.autoloop)?;
        }
        if self.autoloop_budget_sat != 0 {
            os.write_uint64(11, self.autoloop_budget_sat)?;
        }
        if self.autoloop_budget_start_sec != 0 {
            os.write_uint64(12, self.autoloop_budget_start_sec)?;
        }
        if self.auto_max_in_flight != 0 {
            os.write_uint64(13, self.auto_max_in_flight)?;
        }
        if self.min_swap_amount != 0 {
            os.write_uint64(14, self.min_swap_amount)?;
        }
        if self.max_swap_amount != 0 {
            os.write_uint64(15, self.max_swap_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LiquidityParameters {
        LiquidityParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LiquidityRule>>(
                "rules",
                |m: &LiquidityParameters| { &m.rules },
                |m: &mut LiquidityParameters| { &mut m.rules },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee_ppm",
                |m: &LiquidityParameters| { &m.fee_ppm },
                |m: &mut LiquidityParameters| { &mut m.fee_ppm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sweep_fee_rate_sat_per_vbyte",
                |m: &LiquidityParameters| { &m.sweep_fee_rate_sat_per_vbyte },
                |m: &mut LiquidityParameters| { &mut m.sweep_fee_rate_sat_per_vbyte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_swap_fee_ppm",
                |m: &LiquidityParameters| { &m.max_swap_fee_ppm },
                |m: &mut LiquidityParameters| { &mut m.max_swap_fee_ppm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_routing_fee_ppm",
                |m: &LiquidityParameters| { &m.max_routing_fee_ppm },
                |m: &mut LiquidityParameters| { &mut m.max_routing_fee_ppm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_prepay_routing_fee_ppm",
                |m: &LiquidityParameters| { &m.max_prepay_routing_fee_ppm },
                |m: &mut LiquidityParameters| { &mut m.max_prepay_routing_fee_ppm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_prepay_sat",
                |m: &LiquidityParameters| { &m.max_prepay_sat },
                |m: &mut LiquidityParameters| { &mut m.max_prepay_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_miner_fee_sat",
                |m: &LiquidityParameters| { &m.max_miner_fee_sat },
                |m: &mut LiquidityParameters| { &mut m.max_miner_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sweep_conf_target",
                |m: &LiquidityParameters| { &m.sweep_conf_target },
                |m: &mut LiquidityParameters| { &mut m.sweep_conf_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "failure_backoff_sec",
                |m: &LiquidityParameters| { &m.failure_backoff_sec },
                |m: &mut LiquidityParameters| { &mut m.failure_backoff_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoloop",
                |m: &LiquidityParameters| { &m.autoloop },
                |m: &mut LiquidityParameters| { &mut m.autoloop },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "autoloop_budget_sat",
                |m: &LiquidityParameters| { &m.autoloop_budget_sat },
                |m: &mut LiquidityParameters| { &mut m.autoloop_budget_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "autoloop_budget_start_sec",
                |m: &LiquidityParameters| { &m.autoloop_budget_start_sec },
                |m: &mut LiquidityParameters| { &mut m.autoloop_budget_start_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "auto_max_in_flight",
                |m: &LiquidityParameters| { &m.auto_max_in_flight },
                |m: &mut LiquidityParameters| { &mut m.auto_max_in_flight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "min_swap_amount",
                |m: &LiquidityParameters| { &m.min_swap_amount },
                |m: &mut LiquidityParameters| { &mut m.min_swap_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_swap_amount",
                |m: &LiquidityParameters| { &m.max_swap_amount },
                |m: &mut LiquidityParameters| { &mut m.max_swap_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LiquidityParameters>(
                "LiquidityParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LiquidityParameters {
        static instance: ::protobuf::rt::LazyV2<LiquidityParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LiquidityParameters::new)
    }
}

impl ::protobuf::Clear for LiquidityParameters {
    fn clear(&mut self) {
        self.rules.clear();
        self.fee_ppm = 0;
        self.sweep_fee_rate_sat_per_vbyte = 0;
        self.max_swap_fee_ppm = 0;
        self.max_routing_fee_ppm = 0;
        self.max_prepay_routing_fee_ppm = 0;
        self.max_prepay_sat = 0;
        self.max_miner_fee_sat = 0;
        self.sweep_conf_target = 0;
        self.failure_backoff_sec = 0;
        self.autoloop = false;
        self.autoloop_budget_sat = 0;
        self.autoloop_budget_start_sec = 0;
        self.auto_max_in_flight = 0;
        self.min_swap_amount = 0;
        self.max_swap_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LiquidityParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LiquidityParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LiquidityRule {
    // message fields
    pub channel_id: u64,
    pub pubkey: ::std::vec::Vec<u8>,
    pub field_type: LiquidityRuleType,
    pub incoming_threshold: u32,
    pub outgoing_threshold: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LiquidityRule {
    fn default() -> &'a LiquidityRule {
        <LiquidityRule as ::protobuf::Message>::default_instance()
    }
}

impl LiquidityRule {
    pub fn new() -> LiquidityRule {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // bytes pubkey = 5;


    pub fn get_pubkey(&self) -> &[u8] {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubkey, ::std::vec::Vec::new())
    }

    // .looprpc.LiquidityRuleType type = 2;


    pub fn get_field_type(&self) -> LiquidityRuleType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = LiquidityRuleType::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: LiquidityRuleType) {
        self.field_type = v;
    }

    // uint32 incoming_threshold = 3;


    pub fn get_incoming_threshold(&self) -> u32 {
        self.incoming_threshold
    }
    pub fn clear_incoming_threshold(&mut self) {
        self.incoming_threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_threshold(&mut self, v: u32) {
        self.incoming_threshold = v;
    }

    // uint32 outgoing_threshold = 4;


    pub fn get_outgoing_threshold(&self) -> u32 {
        self.outgoing_threshold
    }
    pub fn clear_outgoing_threshold(&mut self) {
        self.outgoing_threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_threshold(&mut self, v: u32) {
        self.outgoing_threshold = v;
    }
}

impl ::protobuf::Message for LiquidityRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.incoming_threshold = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.outgoing_threshold = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.pubkey);
        }
        if self.field_type != LiquidityRuleType::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if self.incoming_threshold != 0 {
            my_size += ::protobuf::rt::value_size(3, self.incoming_threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_threshold != 0 {
            my_size += ::protobuf::rt::value_size(4, self.outgoing_threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if !self.pubkey.is_empty() {
            os.write_bytes(5, &self.pubkey)?;
        }
        if self.field_type != LiquidityRuleType::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.incoming_threshold != 0 {
            os.write_uint32(3, self.incoming_threshold)?;
        }
        if self.outgoing_threshold != 0 {
            os.write_uint32(4, self.outgoing_threshold)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LiquidityRule {
        LiquidityRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "channel_id",
                |m: &LiquidityRule| { &m.channel_id },
                |m: &mut LiquidityRule| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pubkey",
                |m: &LiquidityRule| { &m.pubkey },
                |m: &mut LiquidityRule| { &mut m.pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LiquidityRuleType>>(
                "type",
                |m: &LiquidityRule| { &m.field_type },
                |m: &mut LiquidityRule| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "incoming_threshold",
                |m: &LiquidityRule| { &m.incoming_threshold },
                |m: &mut LiquidityRule| { &mut m.incoming_threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "outgoing_threshold",
                |m: &LiquidityRule| { &m.outgoing_threshold },
                |m: &mut LiquidityRule| { &mut m.outgoing_threshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LiquidityRule>(
                "LiquidityRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LiquidityRule {
        static instance: ::protobuf::rt::LazyV2<LiquidityRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LiquidityRule::new)
    }
}

impl ::protobuf::Clear for LiquidityRule {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.pubkey.clear();
        self.field_type = LiquidityRuleType::UNKNOWN;
        self.incoming_threshold = 0;
        self.outgoing_threshold = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LiquidityRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LiquidityRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SetLiquidityParamsRequest {
    // message fields
    pub parameters: ::protobuf::SingularPtrField<LiquidityParameters>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetLiquidityParamsRequest {
    fn default() -> &'a SetLiquidityParamsRequest {
        <SetLiquidityParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetLiquidityParamsRequest {
    pub fn new() -> SetLiquidityParamsRequest {
        ::std::default::Default::default()
    }

    // .looprpc.LiquidityParameters parameters = 1;


    pub fn get_parameters(&self) -> &LiquidityParameters {
        self.parameters.as_ref().unwrap_or_else(|| <LiquidityParameters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: LiquidityParameters) {
        self.parameters = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut LiquidityParameters {
        if self.parameters.is_none() {
            self.parameters.set_default();
        }
        self.parameters.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameters(&mut self) -> LiquidityParameters {
        self.parameters.take().unwrap_or_else(|| LiquidityParameters::new())
    }
}

impl ::protobuf::Message for SetLiquidityParamsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parameters.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetLiquidityParamsRequest {
        SetLiquidityParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LiquidityParameters>>(
                "parameters",
                |m: &SetLiquidityParamsRequest| { &m.parameters },
                |m: &mut SetLiquidityParamsRequest| { &mut m.parameters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetLiquidityParamsRequest>(
                "SetLiquidityParamsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetLiquidityParamsRequest {
        static instance: ::protobuf::rt::LazyV2<SetLiquidityParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetLiquidityParamsRequest::new)
    }
}

impl ::protobuf::Clear for SetLiquidityParamsRequest {
    fn clear(&mut self) {
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetLiquidityParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetLiquidityParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SetLiquidityParamsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetLiquidityParamsResponse {
    fn default() -> &'a SetLiquidityParamsResponse {
        <SetLiquidityParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetLiquidityParamsResponse {
    pub fn new() -> SetLiquidityParamsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetLiquidityParamsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetLiquidityParamsResponse {
        SetLiquidityParamsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetLiquidityParamsResponse>(
                "SetLiquidityParamsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetLiquidityParamsResponse {
        static instance: ::protobuf::rt::LazyV2<SetLiquidityParamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetLiquidityParamsResponse::new)
    }
}

impl ::protobuf::Clear for SetLiquidityParamsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetLiquidityParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetLiquidityParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SuggestSwapsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SuggestSwapsRequest {
    fn default() -> &'a SuggestSwapsRequest {
        <SuggestSwapsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SuggestSwapsRequest {
    pub fn new() -> SuggestSwapsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SuggestSwapsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SuggestSwapsRequest {
        SuggestSwapsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SuggestSwapsRequest>(
                "SuggestSwapsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SuggestSwapsRequest {
        static instance: ::protobuf::rt::LazyV2<SuggestSwapsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SuggestSwapsRequest::new)
    }
}

impl ::protobuf::Clear for SuggestSwapsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuggestSwapsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuggestSwapsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Disqualified {
    // message fields
    pub channel_id: u64,
    pub pubkey: ::std::vec::Vec<u8>,
    pub reason: AutoReason,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Disqualified {
    fn default() -> &'a Disqualified {
        <Disqualified as ::protobuf::Message>::default_instance()
    }
}

impl Disqualified {
    pub fn new() -> Disqualified {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // bytes pubkey = 3;


    pub fn get_pubkey(&self) -> &[u8] {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubkey, ::std::vec::Vec::new())
    }

    // .looprpc.AutoReason reason = 2;


    pub fn get_reason(&self) -> AutoReason {
        self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason = AutoReason::AUTO_REASON_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: AutoReason) {
        self.reason = v;
    }
}

impl ::protobuf::Message for Disqualified {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pubkey);
        }
        if self.reason != AutoReason::AUTO_REASON_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if !self.pubkey.is_empty() {
            os.write_bytes(3, &self.pubkey)?;
        }
        if self.reason != AutoReason::AUTO_REASON_UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reason))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Disqualified {
        Disqualified::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "channel_id",
                |m: &Disqualified| { &m.channel_id },
                |m: &mut Disqualified| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pubkey",
                |m: &Disqualified| { &m.pubkey },
                |m: &mut Disqualified| { &mut m.pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AutoReason>>(
                "reason",
                |m: &Disqualified| { &m.reason },
                |m: &mut Disqualified| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Disqualified>(
                "Disqualified",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Disqualified {
        static instance: ::protobuf::rt::LazyV2<Disqualified> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Disqualified::new)
    }
}

impl ::protobuf::Clear for Disqualified {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.pubkey.clear();
        self.reason = AutoReason::AUTO_REASON_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Disqualified {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Disqualified {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SuggestSwapsResponse {
    // message fields
    pub loop_out: ::protobuf::RepeatedField<LoopOutRequest>,
    pub disqualified: ::protobuf::RepeatedField<Disqualified>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SuggestSwapsResponse {
    fn default() -> &'a SuggestSwapsResponse {
        <SuggestSwapsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SuggestSwapsResponse {
    pub fn new() -> SuggestSwapsResponse {
        ::std::default::Default::default()
    }

    // repeated .looprpc.LoopOutRequest loop_out = 1;


    pub fn get_loop_out(&self) -> &[LoopOutRequest] {
        &self.loop_out
    }
    pub fn clear_loop_out(&mut self) {
        self.loop_out.clear();
    }

    // Param is passed by value, moved
    pub fn set_loop_out(&mut self, v: ::protobuf::RepeatedField<LoopOutRequest>) {
        self.loop_out = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loop_out(&mut self) -> &mut ::protobuf::RepeatedField<LoopOutRequest> {
        &mut self.loop_out
    }

    // Take field
    pub fn take_loop_out(&mut self) -> ::protobuf::RepeatedField<LoopOutRequest> {
        ::std::mem::replace(&mut self.loop_out, ::protobuf::RepeatedField::new())
    }

    // repeated .looprpc.Disqualified disqualified = 2;


    pub fn get_disqualified(&self) -> &[Disqualified] {
        &self.disqualified
    }
    pub fn clear_disqualified(&mut self) {
        self.disqualified.clear();
    }

    // Param is passed by value, moved
    pub fn set_disqualified(&mut self, v: ::protobuf::RepeatedField<Disqualified>) {
        self.disqualified = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disqualified(&mut self) -> &mut ::protobuf::RepeatedField<Disqualified> {
        &mut self.disqualified
    }

    // Take field
    pub fn take_disqualified(&mut self) -> ::protobuf::RepeatedField<Disqualified> {
        ::std::mem::replace(&mut self.disqualified, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SuggestSwapsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.loop_out {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disqualified {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.loop_out)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.disqualified)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.loop_out {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.disqualified {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.loop_out {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.disqualified {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SuggestSwapsResponse {
        SuggestSwapsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoopOutRequest>>(
                "loop_out",
                |m: &SuggestSwapsResponse| { &m.loop_out },
                |m: &mut SuggestSwapsResponse| { &mut m.loop_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Disqualified>>(
                "disqualified",
                |m: &SuggestSwapsResponse| { &m.disqualified },
                |m: &mut SuggestSwapsResponse| { &mut m.disqualified },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SuggestSwapsResponse>(
                "SuggestSwapsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SuggestSwapsResponse {
        static instance: ::protobuf::rt::LazyV2<SuggestSwapsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SuggestSwapsResponse::new)
    }
}

impl ::protobuf::Clear for SuggestSwapsResponse {
    fn clear(&mut self) {
        self.loop_out.clear();
        self.disqualified.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuggestSwapsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuggestSwapsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SwapType {
    LOOP_OUT = 0,
    LOOP_IN = 1,
}

impl ::protobuf::ProtobufEnum for SwapType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwapType> {
        match value {
            0 => ::std::option::Option::Some(SwapType::LOOP_OUT),
            1 => ::std::option::Option::Some(SwapType::LOOP_IN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SwapType] = &[
            SwapType::LOOP_OUT,
            SwapType::LOOP_IN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SwapType>("SwapType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SwapType {
}

impl ::std::default::Default for SwapType {
    fn default() -> Self {
        SwapType::LOOP_OUT
    }
}

impl ::protobuf::reflect::ProtobufValue for SwapType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SwapState {
    INITIATED = 0,
    PREIMAGE_REVEALED = 1,
    HTLC_PUBLISHED = 2,
    SUCCESS = 3,
    FAILED = 4,
    INVOICE_SETTLED = 5,
}

impl ::protobuf::ProtobufEnum for SwapState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwapState> {
        match value {
            0 => ::std::option::Option::Some(SwapState::INITIATED),
            1 => ::std::option::Option::Some(SwapState::PREIMAGE_REVEALED),
            2 => ::std::option::Option::Some(SwapState::HTLC_PUBLISHED),
            3 => ::std::option::Option::Some(SwapState::SUCCESS),
            4 => ::std::option::Option::Some(SwapState::FAILED),
            5 => ::std::option::Option::Some(SwapState::INVOICE_SETTLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SwapState] = &[
            SwapState::INITIATED,
            SwapState::PREIMAGE_REVEALED,
            SwapState::HTLC_PUBLISHED,
            SwapState::SUCCESS,
            SwapState::FAILED,
            SwapState::INVOICE_SETTLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SwapState>("SwapState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SwapState {
}

impl ::std::default::Default for SwapState {
    fn default() -> Self {
        SwapState::INITIATED
    }
}

impl ::protobuf::reflect::ProtobufValue for SwapState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FailureReason {
    FAILURE_REASON_NONE = 0,
    FAILURE_REASON_OFFCHAIN = 1,
    FAILURE_REASON_TIMEOUT = 2,
    FAILURE_REASON_SWEEP_TIMEOUT = 3,
    FAILURE_REASON_INSUFFICIENT_VALUE = 4,
    FAILURE_REASON_TEMPORARY = 5,
    FAILURE_REASON_INCORRECT_AMOUNT = 6,
}

impl ::protobuf::ProtobufEnum for FailureReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FailureReason> {
        match value {
            0 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_NONE),
            1 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_OFFCHAIN),
            2 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_TIMEOUT),
            3 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_SWEEP_TIMEOUT),
            4 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_INSUFFICIENT_VALUE),
            5 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_TEMPORARY),
            6 => ::std::option::Option::Some(FailureReason::FAILURE_REASON_INCORRECT_AMOUNT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FailureReason] = &[
            FailureReason::FAILURE_REASON_NONE,
            FailureReason::FAILURE_REASON_OFFCHAIN,
            FailureReason::FAILURE_REASON_TIMEOUT,
            FailureReason::FAILURE_REASON_SWEEP_TIMEOUT,
            FailureReason::FAILURE_REASON_INSUFFICIENT_VALUE,
            FailureReason::FAILURE_REASON_TEMPORARY,
            FailureReason::FAILURE_REASON_INCORRECT_AMOUNT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FailureReason>("FailureReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FailureReason {
}

impl ::std::default::Default for FailureReason {
    fn default() -> Self {
        FailureReason::FAILURE_REASON_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for FailureReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum LiquidityRuleType {
    UNKNOWN = 0,
    THRESHOLD = 1,
}

impl ::protobuf::ProtobufEnum for LiquidityRuleType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LiquidityRuleType> {
        match value {
            0 => ::std::option::Option::Some(LiquidityRuleType::UNKNOWN),
            1 => ::std::option::Option::Some(LiquidityRuleType::THRESHOLD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LiquidityRuleType] = &[
            LiquidityRuleType::UNKNOWN,
            LiquidityRuleType::THRESHOLD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LiquidityRuleType>("LiquidityRuleType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LiquidityRuleType {
}

impl ::std::default::Default for LiquidityRuleType {
    fn default() -> Self {
        LiquidityRuleType::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for LiquidityRuleType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AutoReason {
    AUTO_REASON_UNKNOWN = 0,
    AUTO_REASON_BUDGET_NOT_STARTED = 1,
    AUTO_REASON_SWEEP_FEES = 2,
    AUTO_REASON_BUDGET_ELAPSED = 3,
    AUTO_REASON_IN_FLIGHT = 4,
    AUTO_REASON_SWAP_FEE = 5,
    AUTO_REASON_MINER_FEE = 6,
    AUTO_REASON_PREPAY = 7,
    AUTO_REASON_FAILURE_BACKOFF = 8,
    AUTO_REASON_LOOP_OUT = 9,
    AUTO_REASON_LOOP_IN = 10,
    AUTO_REASON_LIQUIDITY_OK = 11,
    AUTO_REASON_BUDGET_INSUFFICIENT = 12,
    AUTO_REASON_FEE_INSUFFICIENT = 13,
}

impl ::protobuf::ProtobufEnum for AutoReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AutoReason> {
        match value {
            0 => ::std::option::Option::Some(AutoReason::AUTO_REASON_UNKNOWN),
            1 => ::std::option::Option::Some(AutoReason::AUTO_REASON_BUDGET_NOT_STARTED),
            2 => ::std::option::Option::Some(AutoReason::AUTO_REASON_SWEEP_FEES),
            3 => ::std::option::Option::Some(AutoReason::AUTO_REASON_BUDGET_ELAPSED),
            4 => ::std::option::Option::Some(AutoReason::AUTO_REASON_IN_FLIGHT),
            5 => ::std::option::Option::Some(AutoReason::AUTO_REASON_SWAP_FEE),
            6 => ::std::option::Option::Some(AutoReason::AUTO_REASON_MINER_FEE),
            7 => ::std::option::Option::Some(AutoReason::AUTO_REASON_PREPAY),
            8 => ::std::option::Option::Some(AutoReason::AUTO_REASON_FAILURE_BACKOFF),
            9 => ::std::option::Option::Some(AutoReason::AUTO_REASON_LOOP_OUT),
            10 => ::std::option::Option::Some(AutoReason::AUTO_REASON_LOOP_IN),
            11 => ::std::option::Option::Some(AutoReason::AUTO_REASON_LIQUIDITY_OK),
            12 => ::std::option::Option::Some(AutoReason::AUTO_REASON_BUDGET_INSUFFICIENT),
            13 => ::std::option::Option::Some(AutoReason::AUTO_REASON_FEE_INSUFFICIENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AutoReason] = &[
            AutoReason::AUTO_REASON_UNKNOWN,
            AutoReason::AUTO_REASON_BUDGET_NOT_STARTED,
            AutoReason::AUTO_REASON_SWEEP_FEES,
            AutoReason::AUTO_REASON_BUDGET_ELAPSED,
            AutoReason::AUTO_REASON_IN_FLIGHT,
            AutoReason::AUTO_REASON_SWAP_FEE,
            AutoReason::AUTO_REASON_MINER_FEE,
            AutoReason::AUTO_REASON_PREPAY,
            AutoReason::AUTO_REASON_FAILURE_BACKOFF,
            AutoReason::AUTO_REASON_LOOP_OUT,
            AutoReason::AUTO_REASON_LOOP_IN,
            AutoReason::AUTO_REASON_LIQUIDITY_OK,
            AutoReason::AUTO_REASON_BUDGET_INSUFFICIENT,
            AutoReason::AUTO_REASON_FEE_INSUFFICIENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AutoReason>("AutoReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AutoReason {
}

impl ::std::default::Default for AutoReason {
    fn default() -> Self {
        AutoReason::AUTO_REASON_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cclient.proto\x12\x07looprpc\x1a\x0ccommon.proto\"\xad\x04\n\x0eLoo\
    pOutRequest\x12\x10\n\x03amt\x18\x01\x20\x01(\x03R\x03amt\x12\x12\n\x04d\
    est\x18\x02\x20\x01(\tR\x04dest\x12/\n\x14max_swap_routing_fee\x18\x03\
    \x20\x01(\x03R\x11maxSwapRoutingFee\x123\n\x16max_prepay_routing_fee\x18\
    \x04\x20\x01(\x03R\x13maxPrepayRoutingFee\x12\x20\n\x0cmax_swap_fee\x18\
    \x05\x20\x01(\x03R\nmaxSwapFee\x12$\n\x0emax_prepay_amt\x18\x06\x20\x01(\
    \x03R\x0cmaxPrepayAmt\x12\"\n\rmax_miner_fee\x18\x07\x20\x01(\x03R\x0bma\
    xMinerFee\x12,\n\x10loop_out_channel\x18\x08\x20\x01(\x04R\x0eloopOutCha\
    nnelB\x02\x18\x01\x12*\n\x11outgoing_chan_set\x18\x0b\x20\x03(\x04R\x0fo\
    utgoingChanSet\x12*\n\x11sweep_conf_target\x18\t\x20\x01(\x05R\x0fsweepC\
    onfTarget\x12-\n\x12htlc_confirmations\x18\r\x20\x01(\x05R\x11htlcConfir\
    mations\x12:\n\x19swap_publication_deadline\x18\n\x20\x01(\x04R\x17swapP\
    ublicationDeadline\x12\x14\n\x05label\x18\x0c\x20\x01(\tR\x05label\x12\
    \x1c\n\tinitiator\x18\x0e\x20\x01(\tR\tinitiator\"\x85\x02\n\rLoopInRequ\
    est\x12\x10\n\x03amt\x18\x01\x20\x01(\x03R\x03amt\x12\x20\n\x0cmax_swap_\
    fee\x18\x02\x20\x01(\x03R\nmaxSwapFee\x12\"\n\rmax_miner_fee\x18\x03\x20\
    \x01(\x03R\x0bmaxMinerFee\x12\x19\n\x08last_hop\x18\x04\x20\x01(\x0cR\
    \x07lastHop\x12#\n\rexternal_htlc\x18\x05\x20\x01(\x08R\x0cexternalHtlc\
    \x12(\n\x10htlc_conf_target\x18\x06\x20\x01(\x05R\x0ehtlcConfTarget\x12\
    \x14\n\x05label\x18\x07\x20\x01(\tR\x05label\x12\x1c\n\tinitiator\x18\
    \x08\x20\x01(\tR\tinitiator\"\xe9\x01\n\x0cSwapResponse\x12\x12\n\x02id\
    \x18\x01\x20\x01(\tR\x02idB\x02\x18\x01\x12\x19\n\x08id_bytes\x18\x03\
    \x20\x01(\x0cR\x07idBytes\x12%\n\x0chtlc_address\x18\x02\x20\x01(\tR\x0b\
    htlcAddressB\x02\x18\x01\x12.\n\x13htlc_address_np2wsh\x18\x04\x20\x01(\
    \tR\x11htlcAddressNp2wsh\x12,\n\x12htlc_address_p2wsh\x18\x05\x20\x01(\t\
    R\x10htlcAddressP2wsh\x12%\n\x0eserver_message\x18\x06\x20\x01(\tR\rserv\
    erMessage\"\x10\n\x0eMonitorRequest\"\xb4\x04\n\nSwapStatus\x12\x10\n\
    \x03amt\x18\x01\x20\x01(\x03R\x03amt\x12\x12\n\x02id\x18\x02\x20\x01(\tR\
    \x02idB\x02\x18\x01\x12\x19\n\x08id_bytes\x18\x0b\x20\x01(\x0cR\x07idByt\
    es\x12%\n\x04type\x18\x03\x20\x01(\x0e2\x11.looprpc.SwapTypeR\x04type\
    \x12(\n\x05state\x18\x04\x20\x01(\x0e2\x12.looprpc.SwapStateR\x05state\
    \x12=\n\x0efailure_reason\x18\x0e\x20\x01(\x0e2\x16.looprpc.FailureReaso\
    nR\rfailureReason\x12'\n\x0finitiation_time\x18\x05\x20\x01(\x03R\x0eini\
    tiationTime\x12(\n\x10last_update_time\x18\x06\x20\x01(\x03R\x0elastUpda\
    teTime\x12%\n\x0chtlc_address\x18\x07\x20\x01(\tR\x0bhtlcAddressB\x02\
    \x18\x01\x12,\n\x12htlc_address_p2wsh\x18\x0c\x20\x01(\tR\x10htlcAddress\
    P2wsh\x12.\n\x13htlc_address_np2wsh\x18\r\x20\x01(\tR\x11htlcAddressNp2w\
    sh\x12\x1f\n\x0bcost_server\x18\x08\x20\x01(\x03R\ncostServer\x12!\n\x0c\
    cost_onchain\x18\t\x20\x01(\x03R\x0bcostOnchain\x12#\n\rcost_offchain\
    \x18\n\x20\x01(\x03R\x0ccostOffchain\x12\x14\n\x05label\x18\x0f\x20\x01(\
    \tR\x05label\"\x12\n\x10ListSwapsRequest\">\n\x11ListSwapsResponse\x12)\
    \n\x05swaps\x18\x01\x20\x03(\x0b2\x13.looprpc.SwapStatusR\x05swaps\"!\n\
    \x0fSwapInfoRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\"\x0e\n\
    \x0cTermsRequest\"\x7f\n\x0fInTermsResponse\x12&\n\x0fmin_swap_amount\
    \x18\x05\x20\x01(\x03R\rminSwapAmount\x12&\n\x0fmax_swap_amount\x18\x06\
    \x20\x01(\x03R\rmaxSwapAmountJ\x04\x08\x01\x10\x02J\x04\x08\x02\x10\x03J\
    \x04\x08\x03\x10\x04J\x04\x08\x04\x10\x05J\x04\x08\x07\x10\x08\"\xcc\x01\
    \n\x10OutTermsResponse\x12&\n\x0fmin_swap_amount\x18\x05\x20\x01(\x03R\r\
    minSwapAmount\x12&\n\x0fmax_swap_amount\x18\x06\x20\x01(\x03R\rmaxSwapAm\
    ount\x12$\n\x0emin_cltv_delta\x18\x08\x20\x01(\x05R\x0cminCltvDelta\x12$\
    \n\x0emax_cltv_delta\x18\t\x20\x01(\x05R\x0cmaxCltvDeltaJ\x04\x08\x01\
    \x10\x02J\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04J\x04\x08\x04\x10\x05J\
    \x04\x08\x07\x10\x08\"\x8e\x02\n\x0cQuoteRequest\x12\x10\n\x03amt\x18\
    \x01\x20\x01(\x03R\x03amt\x12\x1f\n\x0bconf_target\x18\x02\x20\x01(\x05R\
    \nconfTarget\x12#\n\rexternal_htlc\x18\x03\x20\x01(\x08R\x0cexternalHtlc\
    \x12:\n\x19swap_publication_deadline\x18\x04\x20\x01(\x04R\x17swapPublic\
    ationDeadline\x12'\n\x10loop_in_last_hop\x18\x05\x20\x01(\x0cR\rloopInLa\
    stHop\x12A\n\x13loop_in_route_hints\x18\x06\x20\x03(\x0b2\x12.looprpc.Ro\
    uteHintR\x10loopInRouteHints\"\xb0\x01\n\x0fInQuoteResponse\x12\x20\n\
    \x0cswap_fee_sat\x18\x01\x20\x01(\x03R\nswapFeeSat\x12/\n\x14htlc_publis\
    h_fee_sat\x18\x03\x20\x01(\x03R\x11htlcPublishFeeSat\x12\x1d\n\ncltv_del\
    ta\x18\x05\x20\x01(\x05R\tcltvDelta\x12\x1f\n\x0bconf_target\x18\x06\x20\
    \x01(\x05R\nconfTargetJ\x04\x08\x02\x10\x03J\x04\x08\x04\x10\x05\"\xf3\
    \x01\n\x10OutQuoteResponse\x12\x20\n\x0cswap_fee_sat\x18\x01\x20\x01(\
    \x03R\nswapFeeSat\x12$\n\x0eprepay_amt_sat\x18\x02\x20\x01(\x03R\x0cprep\
    ayAmtSat\x12+\n\x12htlc_sweep_fee_sat\x18\x03\x20\x01(\x03R\x0fhtlcSweep\
    FeeSat\x12*\n\x11swap_payment_dest\x18\x04\x20\x01(\x0cR\x0fswapPaymentD\
    est\x12\x1d\n\ncltv_delta\x18\x05\x20\x01(\x05R\tcltvDelta\x12\x1f\n\x0b\
    conf_target\x18\x06\x20\x01(\x05R\nconfTarget\"p\n\x0cProbeRequest\x12\
    \x10\n\x03amt\x18\x01\x20\x01(\x03R\x03amt\x12\x19\n\x08last_hop\x18\x02\
    \x20\x01(\x0cR\x07lastHop\x123\n\x0broute_hints\x18\x03\x20\x03(\x0b2\
    \x12.looprpc.RouteHintR\nrouteHints\"\x0f\n\rProbeResponse\"\x0f\n\rToke\
    nsRequest\"<\n\x0eTokensResponse\x12*\n\x06tokens\x18\x01\x20\x03(\x0b2\
    \x12.looprpc.LsatTokenR\x06tokens\"\xbb\x02\n\tLsatToken\x12#\n\rbase_ma\
    caroon\x18\x01\x20\x01(\x0cR\x0cbaseMacaroon\x12!\n\x0cpayment_hash\x18\
    \x02\x20\x01(\x0cR\x0bpaymentHash\x12)\n\x10payment_preimage\x18\x03\x20\
    \x01(\x0cR\x0fpaymentPreimage\x12(\n\x10amount_paid_msat\x18\x04\x20\x01\
    (\x03R\x0eamountPaidMsat\x121\n\x15routing_fee_paid_msat\x18\x05\x20\x01\
    (\x03R\x12routingFeePaidMsat\x12!\n\x0ctime_created\x18\x06\x20\x01(\x03\
    R\x0btimeCreated\x12\x18\n\x07expired\x18\x07\x20\x01(\x08R\x07expired\
    \x12!\n\x0cstorage_name\x18\x08\x20\x01(\tR\x0bstorageName\"\x1b\n\x19Ge\
    tLiquidityParamsRequest\"\xe0\x05\n\x13LiquidityParameters\x12,\n\x05rul\
    es\x18\x01\x20\x03(\x0b2\x16.looprpc.LiquidityRuleR\x05rules\x12\x17\n\
    \x07fee_ppm\x18\x10\x20\x01(\x04R\x06feePpm\x12=\n\x1csweep_fee_rate_sat\
    _per_vbyte\x18\x02\x20\x01(\x04R\x17sweepFeeRateSatPerVbyte\x12'\n\x10ma\
    x_swap_fee_ppm\x18\x03\x20\x01(\x04R\rmaxSwapFeePpm\x12-\n\x13max_routin\
    g_fee_ppm\x18\x04\x20\x01(\x04R\x10maxRoutingFeePpm\x12:\n\x1amax_prepay\
    _routing_fee_ppm\x18\x05\x20\x01(\x04R\x16maxPrepayRoutingFeePpm\x12$\n\
    \x0emax_prepay_sat\x18\x06\x20\x01(\x04R\x0cmaxPrepaySat\x12)\n\x11max_m\
    iner_fee_sat\x18\x07\x20\x01(\x04R\x0emaxMinerFeeSat\x12*\n\x11sweep_con\
    f_target\x18\x08\x20\x01(\x05R\x0fsweepConfTarget\x12.\n\x13failure_back\
    off_sec\x18\t\x20\x01(\x04R\x11failureBackoffSec\x12\x1a\n\x08autoloop\
    \x18\n\x20\x01(\x08R\x08autoloop\x12.\n\x13autoloop_budget_sat\x18\x0b\
    \x20\x01(\x04R\x11autoloopBudgetSat\x129\n\x19autoloop_budget_start_sec\
    \x18\x0c\x20\x01(\x04R\x16autoloopBudgetStartSec\x12+\n\x12auto_max_in_f\
    light\x18\r\x20\x01(\x04R\x0fautoMaxInFlight\x12&\n\x0fmin_swap_amount\
    \x18\x0e\x20\x01(\x04R\rminSwapAmount\x12&\n\x0fmax_swap_amount\x18\x0f\
    \x20\x01(\x04R\rmaxSwapAmount\"\xd4\x01\n\rLiquidityRule\x12\x1d\n\nchan\
    nel_id\x18\x01\x20\x01(\x04R\tchannelId\x12\x16\n\x06pubkey\x18\x05\x20\
    \x01(\x0cR\x06pubkey\x12.\n\x04type\x18\x02\x20\x01(\x0e2\x1a.looprpc.Li\
    quidityRuleTypeR\x04type\x12-\n\x12incoming_threshold\x18\x03\x20\x01(\r\
    R\x11incomingThreshold\x12-\n\x12outgoing_threshold\x18\x04\x20\x01(\rR\
    \x11outgoingThreshold\"Y\n\x19SetLiquidityParamsRequest\x12<\n\nparamete\
    rs\x18\x01\x20\x01(\x0b2\x1c.looprpc.LiquidityParametersR\nparameters\"\
    \x1c\n\x1aSetLiquidityParamsResponse\"\x15\n\x13SuggestSwapsRequest\"r\n\
    \x0cDisqualified\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\x04R\tchannelId\
    \x12\x16\n\x06pubkey\x18\x03\x20\x01(\x0cR\x06pubkey\x12+\n\x06reason\
    \x18\x02\x20\x01(\x0e2\x13.looprpc.AutoReasonR\x06reason\"\x85\x01\n\x14\
    SuggestSwapsResponse\x122\n\x08loop_out\x18\x01\x20\x03(\x0b2\x17.looprp\
    c.LoopOutRequestR\x07loopOut\x129\n\x0cdisqualified\x18\x02\x20\x03(\x0b\
    2\x15.looprpc.DisqualifiedR\x0cdisqualified*%\n\x08SwapType\x12\x0c\n\
    \x08LOOP_OUT\x10\0\x12\x0b\n\x07LOOP_IN\x10\x01*s\n\tSwapState\x12\r\n\t\
    INITIATED\x10\0\x12\x15\n\x11PREIMAGE_REVEALED\x10\x01\x12\x12\n\x0eHTLC\
    _PUBLISHED\x10\x02\x12\x0b\n\x07SUCCESS\x10\x03\x12\n\n\x06FAILED\x10\
    \x04\x12\x13\n\x0fINVOICE_SETTLED\x10\x05*\xed\x01\n\rFailureReason\x12\
    \x17\n\x13FAILURE_REASON_NONE\x10\0\x12\x1b\n\x17FAILURE_REASON_OFFCHAIN\
    \x10\x01\x12\x1a\n\x16FAILURE_REASON_TIMEOUT\x10\x02\x12\x20\n\x1cFAILUR\
    E_REASON_SWEEP_TIMEOUT\x10\x03\x12%\n!FAILURE_REASON_INSUFFICIENT_VALUE\
    \x10\x04\x12\x1c\n\x18FAILURE_REASON_TEMPORARY\x10\x05\x12#\n\x1fFAILURE\
    _REASON_INCORRECT_AMOUNT\x10\x06*/\n\x11LiquidityRuleType\x12\x0b\n\x07U\
    NKNOWN\x10\0\x12\r\n\tTHRESHOLD\x10\x01*\xa6\x03\n\nAutoReason\x12\x17\n\
    \x13AUTO_REASON_UNKNOWN\x10\0\x12\"\n\x1eAUTO_REASON_BUDGET_NOT_STARTED\
    \x10\x01\x12\x1a\n\x16AUTO_REASON_SWEEP_FEES\x10\x02\x12\x1e\n\x1aAUTO_R\
    EASON_BUDGET_ELAPSED\x10\x03\x12\x19\n\x15AUTO_REASON_IN_FLIGHT\x10\x04\
    \x12\x18\n\x14AUTO_REASON_SWAP_FEE\x10\x05\x12\x19\n\x15AUTO_REASON_MINE\
    R_FEE\x10\x06\x12\x16\n\x12AUTO_REASON_PREPAY\x10\x07\x12\x1f\n\x1bAUTO_\
    REASON_FAILURE_BACKOFF\x10\x08\x12\x18\n\x14AUTO_REASON_LOOP_OUT\x10\t\
    \x12\x17\n\x13AUTO_REASON_LOOP_IN\x10\n\x12\x1c\n\x18AUTO_REASON_LIQUIDI\
    TY_OK\x10\x0b\x12#\n\x1fAUTO_REASON_BUDGET_INSUFFICIENT\x10\x0c\x12\x20\
    \n\x1cAUTO_REASON_FEE_INSUFFICIENT\x10\r2\xc2\x07\n\nSwapClient\x129\n\
    \x07LoopOut\x12\x17.looprpc.LoopOutRequest\x1a\x15.looprpc.SwapResponse\
    \x127\n\x06LoopIn\x12\x16.looprpc.LoopInRequest\x1a\x15.looprpc.SwapResp\
    onse\x129\n\x07Monitor\x12\x17.looprpc.MonitorRequest\x1a\x13.looprpc.Sw\
    apStatus0\x01\x12B\n\tListSwaps\x12\x19.looprpc.ListSwapsRequest\x1a\x1a\
    .looprpc.ListSwapsResponse\x129\n\x08SwapInfo\x12\x18.looprpc.SwapInfoRe\
    quest\x1a\x13.looprpc.SwapStatus\x12@\n\x0cLoopOutTerms\x12\x15.looprpc.\
    TermsRequest\x1a\x19.looprpc.OutTermsResponse\x12@\n\x0cLoopOutQuote\x12\
    \x15.looprpc.QuoteRequest\x1a\x19.looprpc.OutQuoteResponse\x12A\n\x0eGet\
    LoopInTerms\x12\x15.looprpc.TermsRequest\x1a\x18.looprpc.InTermsResponse\
    \x12A\n\x0eGetLoopInQuote\x12\x15.looprpc.QuoteRequest\x1a\x18.looprpc.I\
    nQuoteResponse\x126\n\x05Probe\x12\x15.looprpc.ProbeRequest\x1a\x16.loop\
    rpc.ProbeResponse\x12@\n\rGetLsatTokens\x12\x16.looprpc.TokensRequest\
    \x1a\x17.looprpc.TokensResponse\x12V\n\x12GetLiquidityParams\x12\".loopr\
    pc.GetLiquidityParamsRequest\x1a\x1c.looprpc.LiquidityParameters\x12]\n\
    \x12SetLiquidityParams\x12\".looprpc.SetLiquidityParamsRequest\x1a#.loop\
    rpc.SetLiquidityParamsResponse\x12K\n\x0cSuggestSwaps\x12\x1c.looprpc.Su\
    ggestSwapsRequest\x1a\x1d.looprpc.SuggestSwapsResponseB'Z%github.com/lig\
    htninglabs/loop/looprpcb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
