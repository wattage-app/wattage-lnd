// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `walletunlocker.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GenSeedRequest {
    // message fields
    pub aezeed_passphrase: ::std::vec::Vec<u8>,
    pub seed_entropy: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenSeedRequest {
    fn default() -> &'a GenSeedRequest {
        <GenSeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GenSeedRequest {
    pub fn new() -> GenSeedRequest {
        ::std::default::Default::default()
    }

    // bytes aezeed_passphrase = 1;


    pub fn get_aezeed_passphrase(&self) -> &[u8] {
        &self.aezeed_passphrase
    }
    pub fn clear_aezeed_passphrase(&mut self) {
        self.aezeed_passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_aezeed_passphrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.aezeed_passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aezeed_passphrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.aezeed_passphrase
    }

    // Take field
    pub fn take_aezeed_passphrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.aezeed_passphrase, ::std::vec::Vec::new())
    }

    // bytes seed_entropy = 2;


    pub fn get_seed_entropy(&self) -> &[u8] {
        &self.seed_entropy
    }
    pub fn clear_seed_entropy(&mut self) {
        self.seed_entropy.clear();
    }

    // Param is passed by value, moved
    pub fn set_seed_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.seed_entropy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.seed_entropy
    }

    // Take field
    pub fn take_seed_entropy(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.seed_entropy, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GenSeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.aezeed_passphrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.seed_entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.aezeed_passphrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.aezeed_passphrase);
        }
        if !self.seed_entropy.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.seed_entropy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.aezeed_passphrase.is_empty() {
            os.write_bytes(1, &self.aezeed_passphrase)?;
        }
        if !self.seed_entropy.is_empty() {
            os.write_bytes(2, &self.seed_entropy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenSeedRequest {
        GenSeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "aezeed_passphrase",
                |m: &GenSeedRequest| { &m.aezeed_passphrase },
                |m: &mut GenSeedRequest| { &mut m.aezeed_passphrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "seed_entropy",
                |m: &GenSeedRequest| { &m.seed_entropy },
                |m: &mut GenSeedRequest| { &mut m.seed_entropy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenSeedRequest>(
                "GenSeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenSeedRequest {
        static instance: ::protobuf::rt::LazyV2<GenSeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenSeedRequest::new)
    }
}

impl ::protobuf::Clear for GenSeedRequest {
    fn clear(&mut self) {
        self.aezeed_passphrase.clear();
        self.seed_entropy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenSeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenSeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GenSeedResponse {
    // message fields
    pub cipher_seed_mnemonic: ::protobuf::RepeatedField<::std::string::String>,
    pub enciphered_seed: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenSeedResponse {
    fn default() -> &'a GenSeedResponse {
        <GenSeedResponse as ::protobuf::Message>::default_instance()
    }
}

impl GenSeedResponse {
    pub fn new() -> GenSeedResponse {
        ::std::default::Default::default()
    }

    // repeated string cipher_seed_mnemonic = 1;


    pub fn get_cipher_seed_mnemonic(&self) -> &[::std::string::String] {
        &self.cipher_seed_mnemonic
    }
    pub fn clear_cipher_seed_mnemonic(&mut self) {
        self.cipher_seed_mnemonic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_seed_mnemonic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cipher_seed_mnemonic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipher_seed_mnemonic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cipher_seed_mnemonic
    }

    // Take field
    pub fn take_cipher_seed_mnemonic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cipher_seed_mnemonic, ::protobuf::RepeatedField::new())
    }

    // bytes enciphered_seed = 2;


    pub fn get_enciphered_seed(&self) -> &[u8] {
        &self.enciphered_seed
    }
    pub fn clear_enciphered_seed(&mut self) {
        self.enciphered_seed.clear();
    }

    // Param is passed by value, moved
    pub fn set_enciphered_seed(&mut self, v: ::std::vec::Vec<u8>) {
        self.enciphered_seed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enciphered_seed(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.enciphered_seed
    }

    // Take field
    pub fn take_enciphered_seed(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.enciphered_seed, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GenSeedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cipher_seed_mnemonic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.enciphered_seed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cipher_seed_mnemonic {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.enciphered_seed.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.enciphered_seed);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cipher_seed_mnemonic {
            os.write_string(1, &v)?;
        };
        if !self.enciphered_seed.is_empty() {
            os.write_bytes(2, &self.enciphered_seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenSeedResponse {
        GenSeedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cipher_seed_mnemonic",
                |m: &GenSeedResponse| { &m.cipher_seed_mnemonic },
                |m: &mut GenSeedResponse| { &mut m.cipher_seed_mnemonic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "enciphered_seed",
                |m: &GenSeedResponse| { &m.enciphered_seed },
                |m: &mut GenSeedResponse| { &mut m.enciphered_seed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenSeedResponse>(
                "GenSeedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenSeedResponse {
        static instance: ::protobuf::rt::LazyV2<GenSeedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenSeedResponse::new)
    }
}

impl ::protobuf::Clear for GenSeedResponse {
    fn clear(&mut self) {
        self.cipher_seed_mnemonic.clear();
        self.enciphered_seed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenSeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenSeedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InitWalletRequest {
    // message fields
    pub wallet_password: ::std::vec::Vec<u8>,
    pub cipher_seed_mnemonic: ::protobuf::RepeatedField<::std::string::String>,
    pub aezeed_passphrase: ::std::vec::Vec<u8>,
    pub recovery_window: i32,
    pub channel_backups: ::protobuf::SingularPtrField<super::rpc::ChanBackupSnapshot>,
    pub stateless_init: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InitWalletRequest {
    fn default() -> &'a InitWalletRequest {
        <InitWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl InitWalletRequest {
    pub fn new() -> InitWalletRequest {
        ::std::default::Default::default()
    }

    // bytes wallet_password = 1;


    pub fn get_wallet_password(&self) -> &[u8] {
        &self.wallet_password
    }
    pub fn clear_wallet_password(&mut self) {
        self.wallet_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.wallet_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wallet_password
    }

    // Take field
    pub fn take_wallet_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wallet_password, ::std::vec::Vec::new())
    }

    // repeated string cipher_seed_mnemonic = 2;


    pub fn get_cipher_seed_mnemonic(&self) -> &[::std::string::String] {
        &self.cipher_seed_mnemonic
    }
    pub fn clear_cipher_seed_mnemonic(&mut self) {
        self.cipher_seed_mnemonic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_seed_mnemonic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cipher_seed_mnemonic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipher_seed_mnemonic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cipher_seed_mnemonic
    }

    // Take field
    pub fn take_cipher_seed_mnemonic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cipher_seed_mnemonic, ::protobuf::RepeatedField::new())
    }

    // bytes aezeed_passphrase = 3;


    pub fn get_aezeed_passphrase(&self) -> &[u8] {
        &self.aezeed_passphrase
    }
    pub fn clear_aezeed_passphrase(&mut self) {
        self.aezeed_passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_aezeed_passphrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.aezeed_passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aezeed_passphrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.aezeed_passphrase
    }

    // Take field
    pub fn take_aezeed_passphrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.aezeed_passphrase, ::std::vec::Vec::new())
    }

    // int32 recovery_window = 4;


    pub fn get_recovery_window(&self) -> i32 {
        self.recovery_window
    }
    pub fn clear_recovery_window(&mut self) {
        self.recovery_window = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovery_window(&mut self, v: i32) {
        self.recovery_window = v;
    }

    // .lnrpc.ChanBackupSnapshot channel_backups = 5;


    pub fn get_channel_backups(&self) -> &super::rpc::ChanBackupSnapshot {
        self.channel_backups.as_ref().unwrap_or_else(|| <super::rpc::ChanBackupSnapshot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel_backups(&mut self) {
        self.channel_backups.clear();
    }

    pub fn has_channel_backups(&self) -> bool {
        self.channel_backups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_backups(&mut self, v: super::rpc::ChanBackupSnapshot) {
        self.channel_backups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_backups(&mut self) -> &mut super::rpc::ChanBackupSnapshot {
        if self.channel_backups.is_none() {
            self.channel_backups.set_default();
        }
        self.channel_backups.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_backups(&mut self) -> super::rpc::ChanBackupSnapshot {
        self.channel_backups.take().unwrap_or_else(|| super::rpc::ChanBackupSnapshot::new())
    }

    // bool stateless_init = 6;


    pub fn get_stateless_init(&self) -> bool {
        self.stateless_init
    }
    pub fn clear_stateless_init(&mut self) {
        self.stateless_init = false;
    }

    // Param is passed by value, moved
    pub fn set_stateless_init(&mut self, v: bool) {
        self.stateless_init = v;
    }
}

impl ::protobuf::Message for InitWalletRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wallet_password)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cipher_seed_mnemonic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.aezeed_passphrase)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recovery_window = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_backups)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stateless_init = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wallet_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_password);
        }
        for value in &self.cipher_seed_mnemonic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.aezeed_passphrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.aezeed_passphrase);
        }
        if self.recovery_window != 0 {
            my_size += ::protobuf::rt::value_size(4, self.recovery_window, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stateless_init != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.wallet_password.is_empty() {
            os.write_bytes(1, &self.wallet_password)?;
        }
        for v in &self.cipher_seed_mnemonic {
            os.write_string(2, &v)?;
        };
        if !self.aezeed_passphrase.is_empty() {
            os.write_bytes(3, &self.aezeed_passphrase)?;
        }
        if self.recovery_window != 0 {
            os.write_int32(4, self.recovery_window)?;
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stateless_init != false {
            os.write_bool(6, self.stateless_init)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitWalletRequest {
        InitWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "wallet_password",
                |m: &InitWalletRequest| { &m.wallet_password },
                |m: &mut InitWalletRequest| { &mut m.wallet_password },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cipher_seed_mnemonic",
                |m: &InitWalletRequest| { &m.cipher_seed_mnemonic },
                |m: &mut InitWalletRequest| { &mut m.cipher_seed_mnemonic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "aezeed_passphrase",
                |m: &InitWalletRequest| { &m.aezeed_passphrase },
                |m: &mut InitWalletRequest| { &mut m.aezeed_passphrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "recovery_window",
                |m: &InitWalletRequest| { &m.recovery_window },
                |m: &mut InitWalletRequest| { &mut m.recovery_window },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::rpc::ChanBackupSnapshot>>(
                "channel_backups",
                |m: &InitWalletRequest| { &m.channel_backups },
                |m: &mut InitWalletRequest| { &mut m.channel_backups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stateless_init",
                |m: &InitWalletRequest| { &m.stateless_init },
                |m: &mut InitWalletRequest| { &mut m.stateless_init },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InitWalletRequest>(
                "InitWalletRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InitWalletRequest {
        static instance: ::protobuf::rt::LazyV2<InitWalletRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InitWalletRequest::new)
    }
}

impl ::protobuf::Clear for InitWalletRequest {
    fn clear(&mut self) {
        self.wallet_password.clear();
        self.cipher_seed_mnemonic.clear();
        self.aezeed_passphrase.clear();
        self.recovery_window = 0;
        self.channel_backups.clear();
        self.stateless_init = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InitWalletResponse {
    // message fields
    pub admin_macaroon: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InitWalletResponse {
    fn default() -> &'a InitWalletResponse {
        <InitWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl InitWalletResponse {
    pub fn new() -> InitWalletResponse {
        ::std::default::Default::default()
    }

    // bytes admin_macaroon = 1;


    pub fn get_admin_macaroon(&self) -> &[u8] {
        &self.admin_macaroon
    }
    pub fn clear_admin_macaroon(&mut self) {
        self.admin_macaroon.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin_macaroon(&mut self, v: ::std::vec::Vec<u8>) {
        self.admin_macaroon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin_macaroon(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.admin_macaroon
    }

    // Take field
    pub fn take_admin_macaroon(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.admin_macaroon, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for InitWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.admin_macaroon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.admin_macaroon.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.admin_macaroon);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.admin_macaroon.is_empty() {
            os.write_bytes(1, &self.admin_macaroon)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitWalletResponse {
        InitWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "admin_macaroon",
                |m: &InitWalletResponse| { &m.admin_macaroon },
                |m: &mut InitWalletResponse| { &mut m.admin_macaroon },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InitWalletResponse>(
                "InitWalletResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InitWalletResponse {
        static instance: ::protobuf::rt::LazyV2<InitWalletResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InitWalletResponse::new)
    }
}

impl ::protobuf::Clear for InitWalletResponse {
    fn clear(&mut self) {
        self.admin_macaroon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UnlockWalletRequest {
    // message fields
    pub wallet_password: ::std::vec::Vec<u8>,
    pub recovery_window: i32,
    pub channel_backups: ::protobuf::SingularPtrField<super::rpc::ChanBackupSnapshot>,
    pub stateless_init: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnlockWalletRequest {
    fn default() -> &'a UnlockWalletRequest {
        <UnlockWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnlockWalletRequest {
    pub fn new() -> UnlockWalletRequest {
        ::std::default::Default::default()
    }

    // bytes wallet_password = 1;


    pub fn get_wallet_password(&self) -> &[u8] {
        &self.wallet_password
    }
    pub fn clear_wallet_password(&mut self) {
        self.wallet_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.wallet_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wallet_password
    }

    // Take field
    pub fn take_wallet_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wallet_password, ::std::vec::Vec::new())
    }

    // int32 recovery_window = 2;


    pub fn get_recovery_window(&self) -> i32 {
        self.recovery_window
    }
    pub fn clear_recovery_window(&mut self) {
        self.recovery_window = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovery_window(&mut self, v: i32) {
        self.recovery_window = v;
    }

    // .lnrpc.ChanBackupSnapshot channel_backups = 3;


    pub fn get_channel_backups(&self) -> &super::rpc::ChanBackupSnapshot {
        self.channel_backups.as_ref().unwrap_or_else(|| <super::rpc::ChanBackupSnapshot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel_backups(&mut self) {
        self.channel_backups.clear();
    }

    pub fn has_channel_backups(&self) -> bool {
        self.channel_backups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_backups(&mut self, v: super::rpc::ChanBackupSnapshot) {
        self.channel_backups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_backups(&mut self) -> &mut super::rpc::ChanBackupSnapshot {
        if self.channel_backups.is_none() {
            self.channel_backups.set_default();
        }
        self.channel_backups.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_backups(&mut self) -> super::rpc::ChanBackupSnapshot {
        self.channel_backups.take().unwrap_or_else(|| super::rpc::ChanBackupSnapshot::new())
    }

    // bool stateless_init = 4;


    pub fn get_stateless_init(&self) -> bool {
        self.stateless_init
    }
    pub fn clear_stateless_init(&mut self) {
        self.stateless_init = false;
    }

    // Param is passed by value, moved
    pub fn set_stateless_init(&mut self, v: bool) {
        self.stateless_init = v;
    }
}

impl ::protobuf::Message for UnlockWalletRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wallet_password)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recovery_window = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_backups)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stateless_init = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wallet_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_password);
        }
        if self.recovery_window != 0 {
            my_size += ::protobuf::rt::value_size(2, self.recovery_window, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stateless_init != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.wallet_password.is_empty() {
            os.write_bytes(1, &self.wallet_password)?;
        }
        if self.recovery_window != 0 {
            os.write_int32(2, self.recovery_window)?;
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stateless_init != false {
            os.write_bool(4, self.stateless_init)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlockWalletRequest {
        UnlockWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "wallet_password",
                |m: &UnlockWalletRequest| { &m.wallet_password },
                |m: &mut UnlockWalletRequest| { &mut m.wallet_password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "recovery_window",
                |m: &UnlockWalletRequest| { &m.recovery_window },
                |m: &mut UnlockWalletRequest| { &mut m.recovery_window },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::rpc::ChanBackupSnapshot>>(
                "channel_backups",
                |m: &UnlockWalletRequest| { &m.channel_backups },
                |m: &mut UnlockWalletRequest| { &mut m.channel_backups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stateless_init",
                |m: &UnlockWalletRequest| { &m.stateless_init },
                |m: &mut UnlockWalletRequest| { &mut m.stateless_init },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnlockWalletRequest>(
                "UnlockWalletRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnlockWalletRequest {
        static instance: ::protobuf::rt::LazyV2<UnlockWalletRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnlockWalletRequest::new)
    }
}

impl ::protobuf::Clear for UnlockWalletRequest {
    fn clear(&mut self) {
        self.wallet_password.clear();
        self.recovery_window = 0;
        self.channel_backups.clear();
        self.stateless_init = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlockWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UnlockWalletResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnlockWalletResponse {
    fn default() -> &'a UnlockWalletResponse {
        <UnlockWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnlockWalletResponse {
    pub fn new() -> UnlockWalletResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnlockWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlockWalletResponse {
        UnlockWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnlockWalletResponse>(
                "UnlockWalletResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnlockWalletResponse {
        static instance: ::protobuf::rt::LazyV2<UnlockWalletResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnlockWalletResponse::new)
    }
}

impl ::protobuf::Clear for UnlockWalletResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlockWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChangePasswordRequest {
    // message fields
    pub current_password: ::std::vec::Vec<u8>,
    pub new_password: ::std::vec::Vec<u8>,
    pub stateless_init: bool,
    pub new_macaroon_root_key: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangePasswordRequest {
    fn default() -> &'a ChangePasswordRequest {
        <ChangePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChangePasswordRequest {
    pub fn new() -> ChangePasswordRequest {
        ::std::default::Default::default()
    }

    // bytes current_password = 1;


    pub fn get_current_password(&self) -> &[u8] {
        &self.current_password
    }
    pub fn clear_current_password(&mut self) {
        self.current_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.current_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.current_password
    }

    // Take field
    pub fn take_current_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.current_password, ::std::vec::Vec::new())
    }

    // bytes new_password = 2;


    pub fn get_new_password(&self) -> &[u8] {
        &self.new_password
    }
    pub fn clear_new_password(&mut self) {
        self.new_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.new_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.new_password
    }

    // Take field
    pub fn take_new_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.new_password, ::std::vec::Vec::new())
    }

    // bool stateless_init = 3;


    pub fn get_stateless_init(&self) -> bool {
        self.stateless_init
    }
    pub fn clear_stateless_init(&mut self) {
        self.stateless_init = false;
    }

    // Param is passed by value, moved
    pub fn set_stateless_init(&mut self, v: bool) {
        self.stateless_init = v;
    }

    // bool new_macaroon_root_key = 4;


    pub fn get_new_macaroon_root_key(&self) -> bool {
        self.new_macaroon_root_key
    }
    pub fn clear_new_macaroon_root_key(&mut self) {
        self.new_macaroon_root_key = false;
    }

    // Param is passed by value, moved
    pub fn set_new_macaroon_root_key(&mut self, v: bool) {
        self.new_macaroon_root_key = v;
    }
}

impl ::protobuf::Message for ChangePasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.current_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.new_password)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stateless_init = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.new_macaroon_root_key = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.current_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.current_password);
        }
        if !self.new_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.new_password);
        }
        if self.stateless_init != false {
            my_size += 2;
        }
        if self.new_macaroon_root_key != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.current_password.is_empty() {
            os.write_bytes(1, &self.current_password)?;
        }
        if !self.new_password.is_empty() {
            os.write_bytes(2, &self.new_password)?;
        }
        if self.stateless_init != false {
            os.write_bool(3, self.stateless_init)?;
        }
        if self.new_macaroon_root_key != false {
            os.write_bool(4, self.new_macaroon_root_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePasswordRequest {
        ChangePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "current_password",
                |m: &ChangePasswordRequest| { &m.current_password },
                |m: &mut ChangePasswordRequest| { &mut m.current_password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "new_password",
                |m: &ChangePasswordRequest| { &m.new_password },
                |m: &mut ChangePasswordRequest| { &mut m.new_password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stateless_init",
                |m: &ChangePasswordRequest| { &m.stateless_init },
                |m: &mut ChangePasswordRequest| { &mut m.stateless_init },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "new_macaroon_root_key",
                |m: &ChangePasswordRequest| { &m.new_macaroon_root_key },
                |m: &mut ChangePasswordRequest| { &mut m.new_macaroon_root_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangePasswordRequest>(
                "ChangePasswordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChangePasswordRequest {
        static instance: ::protobuf::rt::LazyV2<ChangePasswordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChangePasswordRequest::new)
    }
}

impl ::protobuf::Clear for ChangePasswordRequest {
    fn clear(&mut self) {
        self.current_password.clear();
        self.new_password.clear();
        self.stateless_init = false;
        self.new_macaroon_root_key = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChangePasswordResponse {
    // message fields
    pub admin_macaroon: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangePasswordResponse {
    fn default() -> &'a ChangePasswordResponse {
        <ChangePasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChangePasswordResponse {
    pub fn new() -> ChangePasswordResponse {
        ::std::default::Default::default()
    }

    // bytes admin_macaroon = 1;


    pub fn get_admin_macaroon(&self) -> &[u8] {
        &self.admin_macaroon
    }
    pub fn clear_admin_macaroon(&mut self) {
        self.admin_macaroon.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin_macaroon(&mut self, v: ::std::vec::Vec<u8>) {
        self.admin_macaroon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin_macaroon(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.admin_macaroon
    }

    // Take field
    pub fn take_admin_macaroon(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.admin_macaroon, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChangePasswordResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.admin_macaroon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.admin_macaroon.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.admin_macaroon);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.admin_macaroon.is_empty() {
            os.write_bytes(1, &self.admin_macaroon)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePasswordResponse {
        ChangePasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "admin_macaroon",
                |m: &ChangePasswordResponse| { &m.admin_macaroon },
                |m: &mut ChangePasswordResponse| { &mut m.admin_macaroon },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangePasswordResponse>(
                "ChangePasswordResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChangePasswordResponse {
        static instance: ::protobuf::rt::LazyV2<ChangePasswordResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChangePasswordResponse::new)
    }
}

impl ::protobuf::Clear for ChangePasswordResponse {
    fn clear(&mut self) {
        self.admin_macaroon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14walletunlocker.proto\x12\x05lnrpc\x1a\trpc.proto\"`\n\x0eGenSeedRe\
    quest\x12+\n\x11aezeed_passphrase\x18\x01\x20\x01(\x0cR\x10aezeedPassphr\
    ase\x12!\n\x0cseed_entropy\x18\x02\x20\x01(\x0cR\x0bseedEntropy\"l\n\x0f\
    GenSeedResponse\x120\n\x14cipher_seed_mnemonic\x18\x01\x20\x03(\tR\x12ci\
    pherSeedMnemonic\x12'\n\x0fenciphered_seed\x18\x02\x20\x01(\x0cR\x0eenci\
    pheredSeed\"\xaf\x02\n\x11InitWalletRequest\x12'\n\x0fwallet_password\
    \x18\x01\x20\x01(\x0cR\x0ewalletPassword\x120\n\x14cipher_seed_mnemonic\
    \x18\x02\x20\x03(\tR\x12cipherSeedMnemonic\x12+\n\x11aezeed_passphrase\
    \x18\x03\x20\x01(\x0cR\x10aezeedPassphrase\x12'\n\x0frecovery_window\x18\
    \x04\x20\x01(\x05R\x0erecoveryWindow\x12B\n\x0fchannel_backups\x18\x05\
    \x20\x01(\x0b2\x19.lnrpc.ChanBackupSnapshotR\x0echannelBackups\x12%\n\
    \x0estateless_init\x18\x06\x20\x01(\x08R\rstatelessInit\";\n\x12InitWall\
    etResponse\x12%\n\x0eadmin_macaroon\x18\x01\x20\x01(\x0cR\radminMacaroon\
    \"\xd2\x01\n\x13UnlockWalletRequest\x12'\n\x0fwallet_password\x18\x01\
    \x20\x01(\x0cR\x0ewalletPassword\x12'\n\x0frecovery_window\x18\x02\x20\
    \x01(\x05R\x0erecoveryWindow\x12B\n\x0fchannel_backups\x18\x03\x20\x01(\
    \x0b2\x19.lnrpc.ChanBackupSnapshotR\x0echannelBackups\x12%\n\x0estateles\
    s_init\x18\x04\x20\x01(\x08R\rstatelessInit\"\x16\n\x14UnlockWalletRespo\
    nse\"\xbf\x01\n\x15ChangePasswordRequest\x12)\n\x10current_password\x18\
    \x01\x20\x01(\x0cR\x0fcurrentPassword\x12!\n\x0cnew_password\x18\x02\x20\
    \x01(\x0cR\x0bnewPassword\x12%\n\x0estateless_init\x18\x03\x20\x01(\x08R\
    \rstatelessInit\x121\n\x15new_macaroon_root_key\x18\x04\x20\x01(\x08R\
    \x12newMacaroonRootKey\"?\n\x16ChangePasswordResponse\x12%\n\x0eadmin_ma\
    caroon\x18\x01\x20\x01(\x0cR\radminMacaroon2\xa5\x02\n\x0eWalletUnlocker\
    \x128\n\x07GenSeed\x12\x15.lnrpc.GenSeedRequest\x1a\x16.lnrpc.GenSeedRes\
    ponse\x12A\n\nInitWallet\x12\x18.lnrpc.InitWalletRequest\x1a\x19.lnrpc.I\
    nitWalletResponse\x12G\n\x0cUnlockWallet\x12\x1a.lnrpc.UnlockWalletReque\
    st\x1a\x1b.lnrpc.UnlockWalletResponse\x12M\n\x0eChangePassword\x12\x1c.l\
    nrpc.ChangePasswordRequest\x1a\x1d.lnrpc.ChangePasswordResponseB'Z%githu\
    b.com/lightningnetwork/lnd/lnrpcb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
