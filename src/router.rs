// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `router.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendPaymentRequest {
    // message fields
    pub dest: ::std::vec::Vec<u8>,
    pub amt: i64,
    pub amt_msat: i64,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub final_cltv_delta: i32,
    pub payment_addr: ::std::vec::Vec<u8>,
    pub payment_request: ::std::string::String,
    pub timeout_seconds: i32,
    pub fee_limit_sat: i64,
    pub fee_limit_msat: i64,
    pub outgoing_chan_id: u64,
    pub outgoing_chan_ids: ::std::vec::Vec<u64>,
    pub last_hop_pubkey: ::std::vec::Vec<u8>,
    pub cltv_limit: i32,
    pub route_hints: ::protobuf::RepeatedField<super::lightning::RouteHint>,
    pub dest_custom_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    pub allow_self_payment: bool,
    pub dest_features: ::std::vec::Vec<super::lightning::FeatureBit>,
    pub max_parts: u32,
    pub no_inflight_updates: bool,
    pub max_shard_size_msat: u64,
    pub amp: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendPaymentRequest {
    fn default() -> &'a SendPaymentRequest {
        <SendPaymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendPaymentRequest {
    pub fn new() -> SendPaymentRequest {
        ::std::default::Default::default()
    }

    // bytes dest = 1;


    pub fn get_dest(&self) -> &[u8] {
        &self.dest
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dest
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dest, ::std::vec::Vec::new())
    }

    // int64 amt = 2;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int64 amt_msat = 12;


    pub fn get_amt_msat(&self) -> i64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: i64) {
        self.amt_msat = v;
    }

    // bytes payment_hash = 3;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // int32 final_cltv_delta = 4;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // bytes payment_addr = 20;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }

    // string payment_request = 5;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // int32 timeout_seconds = 6;


    pub fn get_timeout_seconds(&self) -> i32 {
        self.timeout_seconds
    }
    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: i32) {
        self.timeout_seconds = v;
    }

    // int64 fee_limit_sat = 7;


    pub fn get_fee_limit_sat(&self) -> i64 {
        self.fee_limit_sat
    }
    pub fn clear_fee_limit_sat(&mut self) {
        self.fee_limit_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_limit_sat(&mut self, v: i64) {
        self.fee_limit_sat = v;
    }

    // int64 fee_limit_msat = 13;


    pub fn get_fee_limit_msat(&self) -> i64 {
        self.fee_limit_msat
    }
    pub fn clear_fee_limit_msat(&mut self) {
        self.fee_limit_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_limit_msat(&mut self, v: i64) {
        self.fee_limit_msat = v;
    }

    // uint64 outgoing_chan_id = 8;


    pub fn get_outgoing_chan_id(&self) -> u64 {
        self.outgoing_chan_id
    }
    pub fn clear_outgoing_chan_id(&mut self) {
        self.outgoing_chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_id(&mut self, v: u64) {
        self.outgoing_chan_id = v;
    }

    // repeated uint64 outgoing_chan_ids = 19;


    pub fn get_outgoing_chan_ids(&self) -> &[u64] {
        &self.outgoing_chan_ids
    }
    pub fn clear_outgoing_chan_ids(&mut self) {
        self.outgoing_chan_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.outgoing_chan_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outgoing_chan_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.outgoing_chan_ids
    }

    // Take field
    pub fn take_outgoing_chan_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.outgoing_chan_ids, ::std::vec::Vec::new())
    }

    // bytes last_hop_pubkey = 14;


    pub fn get_last_hop_pubkey(&self) -> &[u8] {
        &self.last_hop_pubkey
    }
    pub fn clear_last_hop_pubkey(&mut self) {
        self.last_hop_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_hop_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_hop_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_hop_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.last_hop_pubkey
    }

    // Take field
    pub fn take_last_hop_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.last_hop_pubkey, ::std::vec::Vec::new())
    }

    // int32 cltv_limit = 9;


    pub fn get_cltv_limit(&self) -> i32 {
        self.cltv_limit
    }
    pub fn clear_cltv_limit(&mut self) {
        self.cltv_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_limit(&mut self, v: i32) {
        self.cltv_limit = v;
    }

    // repeated .lnrpc.RouteHint route_hints = 10;


    pub fn get_route_hints(&self) -> &[super::lightning::RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<super::lightning::RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<super::lightning::RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<super::lightning::RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    // repeated .routerrpc.SendPaymentRequest.DestCustomRecordsEntry dest_custom_records = 11;


    pub fn get_dest_custom_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.dest_custom_records
    }
    pub fn clear_dest_custom_records(&mut self) {
        self.dest_custom_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_custom_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.dest_custom_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_custom_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.dest_custom_records
    }

    // Take field
    pub fn take_dest_custom_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.dest_custom_records, ::std::collections::HashMap::new())
    }

    // bool allow_self_payment = 15;


    pub fn get_allow_self_payment(&self) -> bool {
        self.allow_self_payment
    }
    pub fn clear_allow_self_payment(&mut self) {
        self.allow_self_payment = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_self_payment(&mut self, v: bool) {
        self.allow_self_payment = v;
    }

    // repeated .lnrpc.FeatureBit dest_features = 16;


    pub fn get_dest_features(&self) -> &[super::lightning::FeatureBit] {
        &self.dest_features
    }
    pub fn clear_dest_features(&mut self) {
        self.dest_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_features(&mut self, v: ::std::vec::Vec<super::lightning::FeatureBit>) {
        self.dest_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_features(&mut self) -> &mut ::std::vec::Vec<super::lightning::FeatureBit> {
        &mut self.dest_features
    }

    // Take field
    pub fn take_dest_features(&mut self) -> ::std::vec::Vec<super::lightning::FeatureBit> {
        ::std::mem::replace(&mut self.dest_features, ::std::vec::Vec::new())
    }

    // uint32 max_parts = 17;


    pub fn get_max_parts(&self) -> u32 {
        self.max_parts
    }
    pub fn clear_max_parts(&mut self) {
        self.max_parts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_parts(&mut self, v: u32) {
        self.max_parts = v;
    }

    // bool no_inflight_updates = 18;


    pub fn get_no_inflight_updates(&self) -> bool {
        self.no_inflight_updates
    }
    pub fn clear_no_inflight_updates(&mut self) {
        self.no_inflight_updates = false;
    }

    // Param is passed by value, moved
    pub fn set_no_inflight_updates(&mut self, v: bool) {
        self.no_inflight_updates = v;
    }

    // uint64 max_shard_size_msat = 21;


    pub fn get_max_shard_size_msat(&self) -> u64 {
        self.max_shard_size_msat
    }
    pub fn clear_max_shard_size_msat(&mut self) {
        self.max_shard_size_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_shard_size_msat(&mut self, v: u64) {
        self.max_shard_size_msat = v;
    }

    // bool amp = 22;


    pub fn get_amp(&self) -> bool {
        self.amp
    }
    pub fn clear_amp(&mut self) {
        self.amp = false;
    }

    // Param is passed by value, moved
    pub fn set_amp(&mut self, v: bool) {
        self.amp = v;
    }
}

impl ::protobuf::Message for SendPaymentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_msat = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeout_seconds = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_limit_sat = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_limit_msat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_chan_id = tmp;
                },
                19 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.outgoing_chan_ids)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.last_hop_pubkey)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cltv_limit = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.dest_custom_records)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_self_payment = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.dest_features, 16, &mut self.unknown_fields)?
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_parts = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_inflight_updates = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_shard_size_msat = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.amp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.dest);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(12, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payment_hash);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(4, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.payment_addr);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payment_request);
        }
        if self.timeout_seconds != 0 {
            my_size += ::protobuf::rt::value_size(6, self.timeout_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_limit_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee_limit_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_limit_msat != 0 {
            my_size += ::protobuf::rt::value_size(13, self.fee_limit_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_chan_id != 0 {
            my_size += ::protobuf::rt::value_size(8, self.outgoing_chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.outgoing_chan_ids {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.last_hop_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.last_hop_pubkey);
        }
        if self.cltv_limit != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cltv_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_custom_records);
        if self.allow_self_payment != false {
            my_size += 2;
        }
        for value in &self.dest_features {
            my_size += ::protobuf::rt::enum_size(16, *value);
        };
        if self.max_parts != 0 {
            my_size += ::protobuf::rt::value_size(17, self.max_parts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.no_inflight_updates != false {
            my_size += 3;
        }
        if self.max_shard_size_msat != 0 {
            my_size += ::protobuf::rt::value_size(21, self.max_shard_size_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amp != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dest.is_empty() {
            os.write_bytes(1, &self.dest)?;
        }
        if self.amt != 0 {
            os.write_int64(2, self.amt)?;
        }
        if self.amt_msat != 0 {
            os.write_int64(12, self.amt_msat)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(3, &self.payment_hash)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(4, self.final_cltv_delta)?;
        }
        if !self.payment_addr.is_empty() {
            os.write_bytes(20, &self.payment_addr)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(5, &self.payment_request)?;
        }
        if self.timeout_seconds != 0 {
            os.write_int32(6, self.timeout_seconds)?;
        }
        if self.fee_limit_sat != 0 {
            os.write_int64(7, self.fee_limit_sat)?;
        }
        if self.fee_limit_msat != 0 {
            os.write_int64(13, self.fee_limit_msat)?;
        }
        if self.outgoing_chan_id != 0 {
            os.write_uint64(8, self.outgoing_chan_id)?;
        }
        for v in &self.outgoing_chan_ids {
            os.write_uint64(19, *v)?;
        };
        if !self.last_hop_pubkey.is_empty() {
            os.write_bytes(14, &self.last_hop_pubkey)?;
        }
        if self.cltv_limit != 0 {
            os.write_int32(9, self.cltv_limit)?;
        }
        for v in &self.route_hints {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_custom_records, os)?;
        if self.allow_self_payment != false {
            os.write_bool(15, self.allow_self_payment)?;
        }
        for v in &self.dest_features {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.max_parts != 0 {
            os.write_uint32(17, self.max_parts)?;
        }
        if self.no_inflight_updates != false {
            os.write_bool(18, self.no_inflight_updates)?;
        }
        if self.max_shard_size_msat != 0 {
            os.write_uint64(21, self.max_shard_size_msat)?;
        }
        if self.amp != false {
            os.write_bool(22, self.amp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendPaymentRequest {
        SendPaymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dest",
                |m: &SendPaymentRequest| { &m.dest },
                |m: &mut SendPaymentRequest| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &SendPaymentRequest| { &m.amt },
                |m: &mut SendPaymentRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_msat",
                |m: &SendPaymentRequest| { &m.amt_msat },
                |m: &mut SendPaymentRequest| { &mut m.amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &SendPaymentRequest| { &m.payment_hash },
                |m: &mut SendPaymentRequest| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "final_cltv_delta",
                |m: &SendPaymentRequest| { &m.final_cltv_delta },
                |m: &mut SendPaymentRequest| { &mut m.final_cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &SendPaymentRequest| { &m.payment_addr },
                |m: &mut SendPaymentRequest| { &mut m.payment_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_request",
                |m: &SendPaymentRequest| { &m.payment_request },
                |m: &mut SendPaymentRequest| { &mut m.payment_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timeout_seconds",
                |m: &SendPaymentRequest| { &m.timeout_seconds },
                |m: &mut SendPaymentRequest| { &mut m.timeout_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_limit_sat",
                |m: &SendPaymentRequest| { &m.fee_limit_sat },
                |m: &mut SendPaymentRequest| { &mut m.fee_limit_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_limit_msat",
                |m: &SendPaymentRequest| { &m.fee_limit_msat },
                |m: &mut SendPaymentRequest| { &mut m.fee_limit_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_chan_id",
                |m: &SendPaymentRequest| { &m.outgoing_chan_id },
                |m: &mut SendPaymentRequest| { &mut m.outgoing_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_chan_ids",
                |m: &SendPaymentRequest| { &m.outgoing_chan_ids },
                |m: &mut SendPaymentRequest| { &mut m.outgoing_chan_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "last_hop_pubkey",
                |m: &SendPaymentRequest| { &m.last_hop_pubkey },
                |m: &mut SendPaymentRequest| { &mut m.last_hop_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cltv_limit",
                |m: &SendPaymentRequest| { &m.cltv_limit },
                |m: &mut SendPaymentRequest| { &mut m.cltv_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lightning::RouteHint>>(
                "route_hints",
                |m: &SendPaymentRequest| { &m.route_hints },
                |m: &mut SendPaymentRequest| { &mut m.route_hints },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                "dest_custom_records",
                |m: &SendPaymentRequest| { &m.dest_custom_records },
                |m: &mut SendPaymentRequest| { &mut m.dest_custom_records },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_self_payment",
                |m: &SendPaymentRequest| { &m.allow_self_payment },
                |m: &mut SendPaymentRequest| { &mut m.allow_self_payment },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::lightning::FeatureBit>>(
                "dest_features",
                |m: &SendPaymentRequest| { &m.dest_features },
                |m: &mut SendPaymentRequest| { &mut m.dest_features },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_parts",
                |m: &SendPaymentRequest| { &m.max_parts },
                |m: &mut SendPaymentRequest| { &mut m.max_parts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_inflight_updates",
                |m: &SendPaymentRequest| { &m.no_inflight_updates },
                |m: &mut SendPaymentRequest| { &mut m.no_inflight_updates },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_shard_size_msat",
                |m: &SendPaymentRequest| { &m.max_shard_size_msat },
                |m: &mut SendPaymentRequest| { &mut m.max_shard_size_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "amp",
                |m: &SendPaymentRequest| { &m.amp },
                |m: &mut SendPaymentRequest| { &mut m.amp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendPaymentRequest>(
                "SendPaymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendPaymentRequest {
        static instance: ::protobuf::rt::LazyV2<SendPaymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendPaymentRequest::new)
    }
}

impl ::protobuf::Clear for SendPaymentRequest {
    fn clear(&mut self) {
        self.dest.clear();
        self.amt = 0;
        self.amt_msat = 0;
        self.payment_hash.clear();
        self.final_cltv_delta = 0;
        self.payment_addr.clear();
        self.payment_request.clear();
        self.timeout_seconds = 0;
        self.fee_limit_sat = 0;
        self.fee_limit_msat = 0;
        self.outgoing_chan_id = 0;
        self.outgoing_chan_ids.clear();
        self.last_hop_pubkey.clear();
        self.cltv_limit = 0;
        self.route_hints.clear();
        self.dest_custom_records.clear();
        self.allow_self_payment = false;
        self.dest_features.clear();
        self.max_parts = 0;
        self.no_inflight_updates = false;
        self.max_shard_size_msat = 0;
        self.amp = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendPaymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendPaymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TrackPaymentRequest {
    // message fields
    pub payment_hash: ::std::vec::Vec<u8>,
    pub no_inflight_updates: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrackPaymentRequest {
    fn default() -> &'a TrackPaymentRequest {
        <TrackPaymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl TrackPaymentRequest {
    pub fn new() -> TrackPaymentRequest {
        ::std::default::Default::default()
    }

    // bytes payment_hash = 1;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // bool no_inflight_updates = 2;


    pub fn get_no_inflight_updates(&self) -> bool {
        self.no_inflight_updates
    }
    pub fn clear_no_inflight_updates(&mut self) {
        self.no_inflight_updates = false;
    }

    // Param is passed by value, moved
    pub fn set_no_inflight_updates(&mut self, v: bool) {
        self.no_inflight_updates = v;
    }
}

impl ::protobuf::Message for TrackPaymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_inflight_updates = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payment_hash);
        }
        if self.no_inflight_updates != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_bytes(1, &self.payment_hash)?;
        }
        if self.no_inflight_updates != false {
            os.write_bool(2, self.no_inflight_updates)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrackPaymentRequest {
        TrackPaymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &TrackPaymentRequest| { &m.payment_hash },
                |m: &mut TrackPaymentRequest| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_inflight_updates",
                |m: &TrackPaymentRequest| { &m.no_inflight_updates },
                |m: &mut TrackPaymentRequest| { &mut m.no_inflight_updates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrackPaymentRequest>(
                "TrackPaymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrackPaymentRequest {
        static instance: ::protobuf::rt::LazyV2<TrackPaymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrackPaymentRequest::new)
    }
}

impl ::protobuf::Clear for TrackPaymentRequest {
    fn clear(&mut self) {
        self.payment_hash.clear();
        self.no_inflight_updates = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrackPaymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrackPaymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteFeeRequest {
    // message fields
    pub dest: ::std::vec::Vec<u8>,
    pub amt_sat: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteFeeRequest {
    fn default() -> &'a RouteFeeRequest {
        <RouteFeeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RouteFeeRequest {
    pub fn new() -> RouteFeeRequest {
        ::std::default::Default::default()
    }

    // bytes dest = 1;


    pub fn get_dest(&self) -> &[u8] {
        &self.dest
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dest
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dest, ::std::vec::Vec::new())
    }

    // int64 amt_sat = 2;


    pub fn get_amt_sat(&self) -> i64 {
        self.amt_sat
    }
    pub fn clear_amt_sat(&mut self) {
        self.amt_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_sat(&mut self, v: i64) {
        self.amt_sat = v;
    }
}

impl ::protobuf::Message for RouteFeeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_sat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.dest);
        }
        if self.amt_sat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amt_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dest.is_empty() {
            os.write_bytes(1, &self.dest)?;
        }
        if self.amt_sat != 0 {
            os.write_int64(2, self.amt_sat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteFeeRequest {
        RouteFeeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dest",
                |m: &RouteFeeRequest| { &m.dest },
                |m: &mut RouteFeeRequest| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_sat",
                |m: &RouteFeeRequest| { &m.amt_sat },
                |m: &mut RouteFeeRequest| { &mut m.amt_sat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteFeeRequest>(
                "RouteFeeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteFeeRequest {
        static instance: ::protobuf::rt::LazyV2<RouteFeeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteFeeRequest::new)
    }
}

impl ::protobuf::Clear for RouteFeeRequest {
    fn clear(&mut self) {
        self.dest.clear();
        self.amt_sat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteFeeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteFeeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteFeeResponse {
    // message fields
    pub routing_fee_msat: i64,
    pub time_lock_delay: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteFeeResponse {
    fn default() -> &'a RouteFeeResponse {
        <RouteFeeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RouteFeeResponse {
    pub fn new() -> RouteFeeResponse {
        ::std::default::Default::default()
    }

    // int64 routing_fee_msat = 1;


    pub fn get_routing_fee_msat(&self) -> i64 {
        self.routing_fee_msat
    }
    pub fn clear_routing_fee_msat(&mut self) {
        self.routing_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_routing_fee_msat(&mut self, v: i64) {
        self.routing_fee_msat = v;
    }

    // int64 time_lock_delay = 2;


    pub fn get_time_lock_delay(&self) -> i64 {
        self.time_lock_delay
    }
    pub fn clear_time_lock_delay(&mut self) {
        self.time_lock_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delay(&mut self, v: i64) {
        self.time_lock_delay = v;
    }
}

impl ::protobuf::Message for RouteFeeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.routing_fee_msat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_lock_delay = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.routing_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.routing_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_lock_delay != 0 {
            my_size += ::protobuf::rt::value_size(2, self.time_lock_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.routing_fee_msat != 0 {
            os.write_int64(1, self.routing_fee_msat)?;
        }
        if self.time_lock_delay != 0 {
            os.write_int64(2, self.time_lock_delay)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteFeeResponse {
        RouteFeeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "routing_fee_msat",
                |m: &RouteFeeResponse| { &m.routing_fee_msat },
                |m: &mut RouteFeeResponse| { &mut m.routing_fee_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "time_lock_delay",
                |m: &RouteFeeResponse| { &m.time_lock_delay },
                |m: &mut RouteFeeResponse| { &mut m.time_lock_delay },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteFeeResponse>(
                "RouteFeeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteFeeResponse {
        static instance: ::protobuf::rt::LazyV2<RouteFeeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteFeeResponse::new)
    }
}

impl ::protobuf::Clear for RouteFeeResponse {
    fn clear(&mut self) {
        self.routing_fee_msat = 0;
        self.time_lock_delay = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteFeeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteFeeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendToRouteRequest {
    // message fields
    pub payment_hash: ::std::vec::Vec<u8>,
    pub route: ::protobuf::SingularPtrField<super::lightning::Route>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToRouteRequest {
    fn default() -> &'a SendToRouteRequest {
        <SendToRouteRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendToRouteRequest {
    pub fn new() -> SendToRouteRequest {
        ::std::default::Default::default()
    }

    // bytes payment_hash = 1;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // .lnrpc.Route route = 2;


    pub fn get_route(&self) -> &super::lightning::Route {
        self.route.as_ref().unwrap_or_else(|| <super::lightning::Route as ::protobuf::Message>::default_instance())
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: super::lightning::Route) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut super::lightning::Route {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> super::lightning::Route {
        self.route.take().unwrap_or_else(|| super::lightning::Route::new())
    }
}

impl ::protobuf::Message for SendToRouteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payment_hash);
        }
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_bytes(1, &self.payment_hash)?;
        }
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToRouteRequest {
        SendToRouteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &SendToRouteRequest| { &m.payment_hash },
                |m: &mut SendToRouteRequest| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lightning::Route>>(
                "route",
                |m: &SendToRouteRequest| { &m.route },
                |m: &mut SendToRouteRequest| { &mut m.route },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendToRouteRequest>(
                "SendToRouteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendToRouteRequest {
        static instance: ::protobuf::rt::LazyV2<SendToRouteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendToRouteRequest::new)
    }
}

impl ::protobuf::Clear for SendToRouteRequest {
    fn clear(&mut self) {
        self.payment_hash.clear();
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToRouteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToRouteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendToRouteResponse {
    // message fields
    pub preimage: ::std::vec::Vec<u8>,
    pub failure: ::protobuf::SingularPtrField<super::lightning::Failure>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToRouteResponse {
    fn default() -> &'a SendToRouteResponse {
        <SendToRouteResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendToRouteResponse {
    pub fn new() -> SendToRouteResponse {
        ::std::default::Default::default()
    }

    // bytes preimage = 1;


    pub fn get_preimage(&self) -> &[u8] {
        &self.preimage
    }
    pub fn clear_preimage(&mut self) {
        self.preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.preimage
    }

    // Take field
    pub fn take_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.preimage, ::std::vec::Vec::new())
    }

    // .lnrpc.Failure failure = 2;


    pub fn get_failure(&self) -> &super::lightning::Failure {
        self.failure.as_ref().unwrap_or_else(|| <super::lightning::Failure as ::protobuf::Message>::default_instance())
    }
    pub fn clear_failure(&mut self) {
        self.failure.clear();
    }

    pub fn has_failure(&self) -> bool {
        self.failure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failure(&mut self, v: super::lightning::Failure) {
        self.failure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failure(&mut self) -> &mut super::lightning::Failure {
        if self.failure.is_none() {
            self.failure.set_default();
        }
        self.failure.as_mut().unwrap()
    }

    // Take field
    pub fn take_failure(&mut self) -> super::lightning::Failure {
        self.failure.take().unwrap_or_else(|| super::lightning::Failure::new())
    }
}

impl ::protobuf::Message for SendToRouteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.failure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.preimage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.failure)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.preimage);
        }
        if let Some(ref v) = self.failure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.preimage.is_empty() {
            os.write_bytes(1, &self.preimage)?;
        }
        if let Some(ref v) = self.failure.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToRouteResponse {
        SendToRouteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "preimage",
                |m: &SendToRouteResponse| { &m.preimage },
                |m: &mut SendToRouteResponse| { &mut m.preimage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lightning::Failure>>(
                "failure",
                |m: &SendToRouteResponse| { &m.failure },
                |m: &mut SendToRouteResponse| { &mut m.failure },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendToRouteResponse>(
                "SendToRouteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendToRouteResponse {
        static instance: ::protobuf::rt::LazyV2<SendToRouteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendToRouteResponse::new)
    }
}

impl ::protobuf::Clear for SendToRouteResponse {
    fn clear(&mut self) {
        self.preimage.clear();
        self.failure.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToRouteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToRouteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResetMissionControlRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetMissionControlRequest {
    fn default() -> &'a ResetMissionControlRequest {
        <ResetMissionControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetMissionControlRequest {
    pub fn new() -> ResetMissionControlRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetMissionControlRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetMissionControlRequest {
        ResetMissionControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResetMissionControlRequest>(
                "ResetMissionControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResetMissionControlRequest {
        static instance: ::protobuf::rt::LazyV2<ResetMissionControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetMissionControlRequest::new)
    }
}

impl ::protobuf::Clear for ResetMissionControlRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetMissionControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetMissionControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResetMissionControlResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetMissionControlResponse {
    fn default() -> &'a ResetMissionControlResponse {
        <ResetMissionControlResponse as ::protobuf::Message>::default_instance()
    }
}

impl ResetMissionControlResponse {
    pub fn new() -> ResetMissionControlResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetMissionControlResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetMissionControlResponse {
        ResetMissionControlResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResetMissionControlResponse>(
                "ResetMissionControlResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResetMissionControlResponse {
        static instance: ::protobuf::rt::LazyV2<ResetMissionControlResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetMissionControlResponse::new)
    }
}

impl ::protobuf::Clear for ResetMissionControlResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetMissionControlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetMissionControlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryMissionControlRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMissionControlRequest {
    fn default() -> &'a QueryMissionControlRequest {
        <QueryMissionControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryMissionControlRequest {
    pub fn new() -> QueryMissionControlRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryMissionControlRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMissionControlRequest {
        QueryMissionControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryMissionControlRequest>(
                "QueryMissionControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryMissionControlRequest {
        static instance: ::protobuf::rt::LazyV2<QueryMissionControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMissionControlRequest::new)
    }
}

impl ::protobuf::Clear for QueryMissionControlRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryMissionControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMissionControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryMissionControlResponse {
    // message fields
    pub pairs: ::protobuf::RepeatedField<PairHistory>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMissionControlResponse {
    fn default() -> &'a QueryMissionControlResponse {
        <QueryMissionControlResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryMissionControlResponse {
    pub fn new() -> QueryMissionControlResponse {
        ::std::default::Default::default()
    }

    // repeated .routerrpc.PairHistory pairs = 2;


    pub fn get_pairs(&self) -> &[PairHistory] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<PairHistory>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<PairHistory> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<PairHistory> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryMissionControlResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMissionControlResponse {
        QueryMissionControlResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PairHistory>>(
                "pairs",
                |m: &QueryMissionControlResponse| { &m.pairs },
                |m: &mut QueryMissionControlResponse| { &mut m.pairs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryMissionControlResponse>(
                "QueryMissionControlResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryMissionControlResponse {
        static instance: ::protobuf::rt::LazyV2<QueryMissionControlResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMissionControlResponse::new)
    }
}

impl ::protobuf::Clear for QueryMissionControlResponse {
    fn clear(&mut self) {
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryMissionControlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMissionControlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct XImportMissionControlRequest {
    // message fields
    pub pairs: ::protobuf::RepeatedField<PairHistory>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XImportMissionControlRequest {
    fn default() -> &'a XImportMissionControlRequest {
        <XImportMissionControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl XImportMissionControlRequest {
    pub fn new() -> XImportMissionControlRequest {
        ::std::default::Default::default()
    }

    // repeated .routerrpc.PairHistory pairs = 1;


    pub fn get_pairs(&self) -> &[PairHistory] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<PairHistory>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<PairHistory> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<PairHistory> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for XImportMissionControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pairs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XImportMissionControlRequest {
        XImportMissionControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PairHistory>>(
                "pairs",
                |m: &XImportMissionControlRequest| { &m.pairs },
                |m: &mut XImportMissionControlRequest| { &mut m.pairs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<XImportMissionControlRequest>(
                "XImportMissionControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static XImportMissionControlRequest {
        static instance: ::protobuf::rt::LazyV2<XImportMissionControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(XImportMissionControlRequest::new)
    }
}

impl ::protobuf::Clear for XImportMissionControlRequest {
    fn clear(&mut self) {
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for XImportMissionControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XImportMissionControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct XImportMissionControlResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XImportMissionControlResponse {
    fn default() -> &'a XImportMissionControlResponse {
        <XImportMissionControlResponse as ::protobuf::Message>::default_instance()
    }
}

impl XImportMissionControlResponse {
    pub fn new() -> XImportMissionControlResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for XImportMissionControlResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XImportMissionControlResponse {
        XImportMissionControlResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<XImportMissionControlResponse>(
                "XImportMissionControlResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static XImportMissionControlResponse {
        static instance: ::protobuf::rt::LazyV2<XImportMissionControlResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(XImportMissionControlResponse::new)
    }
}

impl ::protobuf::Clear for XImportMissionControlResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for XImportMissionControlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XImportMissionControlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PairHistory {
    // message fields
    pub node_from: ::std::vec::Vec<u8>,
    pub node_to: ::std::vec::Vec<u8>,
    pub history: ::protobuf::SingularPtrField<PairData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PairHistory {
    fn default() -> &'a PairHistory {
        <PairHistory as ::protobuf::Message>::default_instance()
    }
}

impl PairHistory {
    pub fn new() -> PairHistory {
        ::std::default::Default::default()
    }

    // bytes node_from = 1;


    pub fn get_node_from(&self) -> &[u8] {
        &self.node_from
    }
    pub fn clear_node_from(&mut self) {
        self.node_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_from
    }

    // Take field
    pub fn take_node_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_from, ::std::vec::Vec::new())
    }

    // bytes node_to = 2;


    pub fn get_node_to(&self) -> &[u8] {
        &self.node_to
    }
    pub fn clear_node_to(&mut self) {
        self.node_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_to
    }

    // Take field
    pub fn take_node_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_to, ::std::vec::Vec::new())
    }

    // .routerrpc.PairData history = 7;


    pub fn get_history(&self) -> &PairData {
        self.history.as_ref().unwrap_or_else(|| <PairData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_history(&mut self) {
        self.history.clear();
    }

    pub fn has_history(&self) -> bool {
        self.history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history(&mut self, v: PairData) {
        self.history = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_history(&mut self) -> &mut PairData {
        if self.history.is_none() {
            self.history.set_default();
        }
        self.history.as_mut().unwrap()
    }

    // Take field
    pub fn take_history(&mut self) -> PairData {
        self.history.take().unwrap_or_else(|| PairData::new())
    }
}

impl ::protobuf::Message for PairHistory {
    fn is_initialized(&self) -> bool {
        for v in &self.history {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_to)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.history)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.node_from);
        }
        if !self.node_to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.node_to);
        }
        if let Some(ref v) = self.history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_from.is_empty() {
            os.write_bytes(1, &self.node_from)?;
        }
        if !self.node_to.is_empty() {
            os.write_bytes(2, &self.node_to)?;
        }
        if let Some(ref v) = self.history.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PairHistory {
        PairHistory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "node_from",
                |m: &PairHistory| { &m.node_from },
                |m: &mut PairHistory| { &mut m.node_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "node_to",
                |m: &PairHistory| { &m.node_to },
                |m: &mut PairHistory| { &mut m.node_to },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PairData>>(
                "history",
                |m: &PairHistory| { &m.history },
                |m: &mut PairHistory| { &mut m.history },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PairHistory>(
                "PairHistory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PairHistory {
        static instance: ::protobuf::rt::LazyV2<PairHistory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PairHistory::new)
    }
}

impl ::protobuf::Clear for PairHistory {
    fn clear(&mut self) {
        self.node_from.clear();
        self.node_to.clear();
        self.history.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PairHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PairHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PairData {
    // message fields
    pub fail_time: i64,
    pub fail_amt_sat: i64,
    pub fail_amt_msat: i64,
    pub success_time: i64,
    pub success_amt_sat: i64,
    pub success_amt_msat: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PairData {
    fn default() -> &'a PairData {
        <PairData as ::protobuf::Message>::default_instance()
    }
}

impl PairData {
    pub fn new() -> PairData {
        ::std::default::Default::default()
    }

    // int64 fail_time = 1;


    pub fn get_fail_time(&self) -> i64 {
        self.fail_time
    }
    pub fn clear_fail_time(&mut self) {
        self.fail_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_fail_time(&mut self, v: i64) {
        self.fail_time = v;
    }

    // int64 fail_amt_sat = 2;


    pub fn get_fail_amt_sat(&self) -> i64 {
        self.fail_amt_sat
    }
    pub fn clear_fail_amt_sat(&mut self) {
        self.fail_amt_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fail_amt_sat(&mut self, v: i64) {
        self.fail_amt_sat = v;
    }

    // int64 fail_amt_msat = 4;


    pub fn get_fail_amt_msat(&self) -> i64 {
        self.fail_amt_msat
    }
    pub fn clear_fail_amt_msat(&mut self) {
        self.fail_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fail_amt_msat(&mut self, v: i64) {
        self.fail_amt_msat = v;
    }

    // int64 success_time = 5;


    pub fn get_success_time(&self) -> i64 {
        self.success_time
    }
    pub fn clear_success_time(&mut self) {
        self.success_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_success_time(&mut self, v: i64) {
        self.success_time = v;
    }

    // int64 success_amt_sat = 6;


    pub fn get_success_amt_sat(&self) -> i64 {
        self.success_amt_sat
    }
    pub fn clear_success_amt_sat(&mut self) {
        self.success_amt_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_success_amt_sat(&mut self, v: i64) {
        self.success_amt_sat = v;
    }

    // int64 success_amt_msat = 7;


    pub fn get_success_amt_msat(&self) -> i64 {
        self.success_amt_msat
    }
    pub fn clear_success_amt_msat(&mut self) {
        self.success_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_success_amt_msat(&mut self, v: i64) {
        self.success_amt_msat = v;
    }
}

impl ::protobuf::Message for PairData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fail_time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fail_amt_sat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fail_amt_msat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.success_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.success_amt_sat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.success_amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fail_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fail_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fail_amt_sat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.fail_amt_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fail_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fail_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.success_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success_amt_sat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.success_amt_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.success_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fail_time != 0 {
            os.write_int64(1, self.fail_time)?;
        }
        if self.fail_amt_sat != 0 {
            os.write_int64(2, self.fail_amt_sat)?;
        }
        if self.fail_amt_msat != 0 {
            os.write_int64(4, self.fail_amt_msat)?;
        }
        if self.success_time != 0 {
            os.write_int64(5, self.success_time)?;
        }
        if self.success_amt_sat != 0 {
            os.write_int64(6, self.success_amt_sat)?;
        }
        if self.success_amt_msat != 0 {
            os.write_int64(7, self.success_amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PairData {
        PairData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fail_time",
                |m: &PairData| { &m.fail_time },
                |m: &mut PairData| { &mut m.fail_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fail_amt_sat",
                |m: &PairData| { &m.fail_amt_sat },
                |m: &mut PairData| { &mut m.fail_amt_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fail_amt_msat",
                |m: &PairData| { &m.fail_amt_msat },
                |m: &mut PairData| { &mut m.fail_amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "success_time",
                |m: &PairData| { &m.success_time },
                |m: &mut PairData| { &mut m.success_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "success_amt_sat",
                |m: &PairData| { &m.success_amt_sat },
                |m: &mut PairData| { &mut m.success_amt_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "success_amt_msat",
                |m: &PairData| { &m.success_amt_msat },
                |m: &mut PairData| { &mut m.success_amt_msat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PairData>(
                "PairData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PairData {
        static instance: ::protobuf::rt::LazyV2<PairData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PairData::new)
    }
}

impl ::protobuf::Clear for PairData {
    fn clear(&mut self) {
        self.fail_time = 0;
        self.fail_amt_sat = 0;
        self.fail_amt_msat = 0;
        self.success_time = 0;
        self.success_amt_sat = 0;
        self.success_amt_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PairData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PairData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetMissionControlConfigRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMissionControlConfigRequest {
    fn default() -> &'a GetMissionControlConfigRequest {
        <GetMissionControlConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMissionControlConfigRequest {
    pub fn new() -> GetMissionControlConfigRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMissionControlConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMissionControlConfigRequest {
        GetMissionControlConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMissionControlConfigRequest>(
                "GetMissionControlConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMissionControlConfigRequest {
        static instance: ::protobuf::rt::LazyV2<GetMissionControlConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMissionControlConfigRequest::new)
    }
}

impl ::protobuf::Clear for GetMissionControlConfigRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMissionControlConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMissionControlConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetMissionControlConfigResponse {
    // message fields
    pub config: ::protobuf::SingularPtrField<MissionControlConfig>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMissionControlConfigResponse {
    fn default() -> &'a GetMissionControlConfigResponse {
        <GetMissionControlConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMissionControlConfigResponse {
    pub fn new() -> GetMissionControlConfigResponse {
        ::std::default::Default::default()
    }

    // .routerrpc.MissionControlConfig config = 1;


    pub fn get_config(&self) -> &MissionControlConfig {
        self.config.as_ref().unwrap_or_else(|| <MissionControlConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: MissionControlConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut MissionControlConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> MissionControlConfig {
        self.config.take().unwrap_or_else(|| MissionControlConfig::new())
    }
}

impl ::protobuf::Message for GetMissionControlConfigResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMissionControlConfigResponse {
        GetMissionControlConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionControlConfig>>(
                "config",
                |m: &GetMissionControlConfigResponse| { &m.config },
                |m: &mut GetMissionControlConfigResponse| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMissionControlConfigResponse>(
                "GetMissionControlConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMissionControlConfigResponse {
        static instance: ::protobuf::rt::LazyV2<GetMissionControlConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMissionControlConfigResponse::new)
    }
}

impl ::protobuf::Clear for GetMissionControlConfigResponse {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMissionControlConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMissionControlConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SetMissionControlConfigRequest {
    // message fields
    pub config: ::protobuf::SingularPtrField<MissionControlConfig>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMissionControlConfigRequest {
    fn default() -> &'a SetMissionControlConfigRequest {
        <SetMissionControlConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMissionControlConfigRequest {
    pub fn new() -> SetMissionControlConfigRequest {
        ::std::default::Default::default()
    }

    // .routerrpc.MissionControlConfig config = 1;


    pub fn get_config(&self) -> &MissionControlConfig {
        self.config.as_ref().unwrap_or_else(|| <MissionControlConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: MissionControlConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut MissionControlConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> MissionControlConfig {
        self.config.take().unwrap_or_else(|| MissionControlConfig::new())
    }
}

impl ::protobuf::Message for SetMissionControlConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMissionControlConfigRequest {
        SetMissionControlConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionControlConfig>>(
                "config",
                |m: &SetMissionControlConfigRequest| { &m.config },
                |m: &mut SetMissionControlConfigRequest| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMissionControlConfigRequest>(
                "SetMissionControlConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetMissionControlConfigRequest {
        static instance: ::protobuf::rt::LazyV2<SetMissionControlConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMissionControlConfigRequest::new)
    }
}

impl ::protobuf::Clear for SetMissionControlConfigRequest {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMissionControlConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMissionControlConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SetMissionControlConfigResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMissionControlConfigResponse {
    fn default() -> &'a SetMissionControlConfigResponse {
        <SetMissionControlConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetMissionControlConfigResponse {
    pub fn new() -> SetMissionControlConfigResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetMissionControlConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMissionControlConfigResponse {
        SetMissionControlConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMissionControlConfigResponse>(
                "SetMissionControlConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetMissionControlConfigResponse {
        static instance: ::protobuf::rt::LazyV2<SetMissionControlConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMissionControlConfigResponse::new)
    }
}

impl ::protobuf::Clear for SetMissionControlConfigResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMissionControlConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMissionControlConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MissionControlConfig {
    // message fields
    pub half_life_seconds: u64,
    pub hop_probability: f32,
    pub weight: f32,
    pub maximum_payment_results: u32,
    pub minimum_failure_relax_interval: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionControlConfig {
    fn default() -> &'a MissionControlConfig {
        <MissionControlConfig as ::protobuf::Message>::default_instance()
    }
}

impl MissionControlConfig {
    pub fn new() -> MissionControlConfig {
        ::std::default::Default::default()
    }

    // uint64 half_life_seconds = 1;


    pub fn get_half_life_seconds(&self) -> u64 {
        self.half_life_seconds
    }
    pub fn clear_half_life_seconds(&mut self) {
        self.half_life_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_half_life_seconds(&mut self, v: u64) {
        self.half_life_seconds = v;
    }

    // float hop_probability = 2;


    pub fn get_hop_probability(&self) -> f32 {
        self.hop_probability
    }
    pub fn clear_hop_probability(&mut self) {
        self.hop_probability = 0.;
    }

    // Param is passed by value, moved
    pub fn set_hop_probability(&mut self, v: f32) {
        self.hop_probability = v;
    }

    // float weight = 3;


    pub fn get_weight(&self) -> f32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0.;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f32) {
        self.weight = v;
    }

    // uint32 maximum_payment_results = 4;


    pub fn get_maximum_payment_results(&self) -> u32 {
        self.maximum_payment_results
    }
    pub fn clear_maximum_payment_results(&mut self) {
        self.maximum_payment_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_payment_results(&mut self, v: u32) {
        self.maximum_payment_results = v;
    }

    // uint64 minimum_failure_relax_interval = 5;


    pub fn get_minimum_failure_relax_interval(&self) -> u64 {
        self.minimum_failure_relax_interval
    }
    pub fn clear_minimum_failure_relax_interval(&mut self) {
        self.minimum_failure_relax_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_minimum_failure_relax_interval(&mut self, v: u64) {
        self.minimum_failure_relax_interval = v;
    }
}

impl ::protobuf::Message for MissionControlConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.half_life_seconds = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.hop_probability = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.weight = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_payment_results = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minimum_failure_relax_interval = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.half_life_seconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.half_life_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hop_probability != 0. {
            my_size += 5;
        }
        if self.weight != 0. {
            my_size += 5;
        }
        if self.maximum_payment_results != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maximum_payment_results, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minimum_failure_relax_interval != 0 {
            my_size += ::protobuf::rt::value_size(5, self.minimum_failure_relax_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.half_life_seconds != 0 {
            os.write_uint64(1, self.half_life_seconds)?;
        }
        if self.hop_probability != 0. {
            os.write_float(2, self.hop_probability)?;
        }
        if self.weight != 0. {
            os.write_float(3, self.weight)?;
        }
        if self.maximum_payment_results != 0 {
            os.write_uint32(4, self.maximum_payment_results)?;
        }
        if self.minimum_failure_relax_interval != 0 {
            os.write_uint64(5, self.minimum_failure_relax_interval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionControlConfig {
        MissionControlConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "half_life_seconds",
                |m: &MissionControlConfig| { &m.half_life_seconds },
                |m: &mut MissionControlConfig| { &mut m.half_life_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "hop_probability",
                |m: &MissionControlConfig| { &m.hop_probability },
                |m: &mut MissionControlConfig| { &mut m.hop_probability },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "weight",
                |m: &MissionControlConfig| { &m.weight },
                |m: &mut MissionControlConfig| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximum_payment_results",
                |m: &MissionControlConfig| { &m.maximum_payment_results },
                |m: &mut MissionControlConfig| { &mut m.maximum_payment_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minimum_failure_relax_interval",
                |m: &MissionControlConfig| { &m.minimum_failure_relax_interval },
                |m: &mut MissionControlConfig| { &mut m.minimum_failure_relax_interval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MissionControlConfig>(
                "MissionControlConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MissionControlConfig {
        static instance: ::protobuf::rt::LazyV2<MissionControlConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MissionControlConfig::new)
    }
}

impl ::protobuf::Clear for MissionControlConfig {
    fn clear(&mut self) {
        self.half_life_seconds = 0;
        self.hop_probability = 0.;
        self.weight = 0.;
        self.maximum_payment_results = 0;
        self.minimum_failure_relax_interval = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionControlConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionControlConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryProbabilityRequest {
    // message fields
    pub from_node: ::std::vec::Vec<u8>,
    pub to_node: ::std::vec::Vec<u8>,
    pub amt_msat: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryProbabilityRequest {
    fn default() -> &'a QueryProbabilityRequest {
        <QueryProbabilityRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryProbabilityRequest {
    pub fn new() -> QueryProbabilityRequest {
        ::std::default::Default::default()
    }

    // bytes from_node = 1;


    pub fn get_from_node(&self) -> &[u8] {
        &self.from_node
    }
    pub fn clear_from_node(&mut self) {
        self.from_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_node(&mut self, v: ::std::vec::Vec<u8>) {
        self.from_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_node(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from_node
    }

    // Take field
    pub fn take_from_node(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from_node, ::std::vec::Vec::new())
    }

    // bytes to_node = 2;


    pub fn get_to_node(&self) -> &[u8] {
        &self.to_node
    }
    pub fn clear_to_node(&mut self) {
        self.to_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_node(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_node(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_node
    }

    // Take field
    pub fn take_to_node(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_node, ::std::vec::Vec::new())
    }

    // int64 amt_msat = 3;


    pub fn get_amt_msat(&self) -> i64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: i64) {
        self.amt_msat = v;
    }
}

impl ::protobuf::Message for QueryProbabilityRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from_node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_node)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from_node.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from_node);
        }
        if !self.to_node.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_node);
        }
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from_node.is_empty() {
            os.write_bytes(1, &self.from_node)?;
        }
        if !self.to_node.is_empty() {
            os.write_bytes(2, &self.to_node)?;
        }
        if self.amt_msat != 0 {
            os.write_int64(3, self.amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryProbabilityRequest {
        QueryProbabilityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "from_node",
                |m: &QueryProbabilityRequest| { &m.from_node },
                |m: &mut QueryProbabilityRequest| { &mut m.from_node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "to_node",
                |m: &QueryProbabilityRequest| { &m.to_node },
                |m: &mut QueryProbabilityRequest| { &mut m.to_node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_msat",
                |m: &QueryProbabilityRequest| { &m.amt_msat },
                |m: &mut QueryProbabilityRequest| { &mut m.amt_msat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryProbabilityRequest>(
                "QueryProbabilityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryProbabilityRequest {
        static instance: ::protobuf::rt::LazyV2<QueryProbabilityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryProbabilityRequest::new)
    }
}

impl ::protobuf::Clear for QueryProbabilityRequest {
    fn clear(&mut self) {
        self.from_node.clear();
        self.to_node.clear();
        self.amt_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryProbabilityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryProbabilityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryProbabilityResponse {
    // message fields
    pub probability: f64,
    pub history: ::protobuf::SingularPtrField<PairData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryProbabilityResponse {
    fn default() -> &'a QueryProbabilityResponse {
        <QueryProbabilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryProbabilityResponse {
    pub fn new() -> QueryProbabilityResponse {
        ::std::default::Default::default()
    }

    // double probability = 1;


    pub fn get_probability(&self) -> f64 {
        self.probability
    }
    pub fn clear_probability(&mut self) {
        self.probability = 0.;
    }

    // Param is passed by value, moved
    pub fn set_probability(&mut self, v: f64) {
        self.probability = v;
    }

    // .routerrpc.PairData history = 2;


    pub fn get_history(&self) -> &PairData {
        self.history.as_ref().unwrap_or_else(|| <PairData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_history(&mut self) {
        self.history.clear();
    }

    pub fn has_history(&self) -> bool {
        self.history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history(&mut self, v: PairData) {
        self.history = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_history(&mut self) -> &mut PairData {
        if self.history.is_none() {
            self.history.set_default();
        }
        self.history.as_mut().unwrap()
    }

    // Take field
    pub fn take_history(&mut self) -> PairData {
        self.history.take().unwrap_or_else(|| PairData::new())
    }
}

impl ::protobuf::Message for QueryProbabilityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.history {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.probability = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.history)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.probability != 0. {
            my_size += 9;
        }
        if let Some(ref v) = self.history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.probability != 0. {
            os.write_double(1, self.probability)?;
        }
        if let Some(ref v) = self.history.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryProbabilityResponse {
        QueryProbabilityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "probability",
                |m: &QueryProbabilityResponse| { &m.probability },
                |m: &mut QueryProbabilityResponse| { &mut m.probability },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PairData>>(
                "history",
                |m: &QueryProbabilityResponse| { &m.history },
                |m: &mut QueryProbabilityResponse| { &mut m.history },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryProbabilityResponse>(
                "QueryProbabilityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryProbabilityResponse {
        static instance: ::protobuf::rt::LazyV2<QueryProbabilityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryProbabilityResponse::new)
    }
}

impl ::protobuf::Clear for QueryProbabilityResponse {
    fn clear(&mut self) {
        self.probability = 0.;
        self.history.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryProbabilityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryProbabilityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuildRouteRequest {
    // message fields
    pub amt_msat: i64,
    pub final_cltv_delta: i32,
    pub outgoing_chan_id: u64,
    pub hop_pubkeys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub payment_addr: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildRouteRequest {
    fn default() -> &'a BuildRouteRequest {
        <BuildRouteRequest as ::protobuf::Message>::default_instance()
    }
}

impl BuildRouteRequest {
    pub fn new() -> BuildRouteRequest {
        ::std::default::Default::default()
    }

    // int64 amt_msat = 1;


    pub fn get_amt_msat(&self) -> i64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: i64) {
        self.amt_msat = v;
    }

    // int32 final_cltv_delta = 2;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // uint64 outgoing_chan_id = 3;


    pub fn get_outgoing_chan_id(&self) -> u64 {
        self.outgoing_chan_id
    }
    pub fn clear_outgoing_chan_id(&mut self) {
        self.outgoing_chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_id(&mut self, v: u64) {
        self.outgoing_chan_id = v;
    }

    // repeated bytes hop_pubkeys = 4;


    pub fn get_hop_pubkeys(&self) -> &[::std::vec::Vec<u8>] {
        &self.hop_pubkeys
    }
    pub fn clear_hop_pubkeys(&mut self) {
        self.hop_pubkeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_hop_pubkeys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hop_pubkeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hop_pubkeys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hop_pubkeys
    }

    // Take field
    pub fn take_hop_pubkeys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hop_pubkeys, ::protobuf::RepeatedField::new())
    }

    // bytes payment_addr = 5;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BuildRouteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_msat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_chan_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hop_pubkeys)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(2, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_chan_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.outgoing_chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hop_pubkeys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.payment_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt_msat != 0 {
            os.write_int64(1, self.amt_msat)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(2, self.final_cltv_delta)?;
        }
        if self.outgoing_chan_id != 0 {
            os.write_uint64(3, self.outgoing_chan_id)?;
        }
        for v in &self.hop_pubkeys {
            os.write_bytes(4, &v)?;
        };
        if !self.payment_addr.is_empty() {
            os.write_bytes(5, &self.payment_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildRouteRequest {
        BuildRouteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_msat",
                |m: &BuildRouteRequest| { &m.amt_msat },
                |m: &mut BuildRouteRequest| { &mut m.amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "final_cltv_delta",
                |m: &BuildRouteRequest| { &m.final_cltv_delta },
                |m: &mut BuildRouteRequest| { &mut m.final_cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_chan_id",
                |m: &BuildRouteRequest| { &m.outgoing_chan_id },
                |m: &mut BuildRouteRequest| { &mut m.outgoing_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hop_pubkeys",
                |m: &BuildRouteRequest| { &m.hop_pubkeys },
                |m: &mut BuildRouteRequest| { &mut m.hop_pubkeys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &BuildRouteRequest| { &m.payment_addr },
                |m: &mut BuildRouteRequest| { &mut m.payment_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildRouteRequest>(
                "BuildRouteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildRouteRequest {
        static instance: ::protobuf::rt::LazyV2<BuildRouteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildRouteRequest::new)
    }
}

impl ::protobuf::Clear for BuildRouteRequest {
    fn clear(&mut self) {
        self.amt_msat = 0;
        self.final_cltv_delta = 0;
        self.outgoing_chan_id = 0;
        self.hop_pubkeys.clear();
        self.payment_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildRouteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildRouteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuildRouteResponse {
    // message fields
    pub route: ::protobuf::SingularPtrField<super::lightning::Route>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildRouteResponse {
    fn default() -> &'a BuildRouteResponse {
        <BuildRouteResponse as ::protobuf::Message>::default_instance()
    }
}

impl BuildRouteResponse {
    pub fn new() -> BuildRouteResponse {
        ::std::default::Default::default()
    }

    // .lnrpc.Route route = 1;


    pub fn get_route(&self) -> &super::lightning::Route {
        self.route.as_ref().unwrap_or_else(|| <super::lightning::Route as ::protobuf::Message>::default_instance())
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: super::lightning::Route) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut super::lightning::Route {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> super::lightning::Route {
        self.route.take().unwrap_or_else(|| super::lightning::Route::new())
    }
}

impl ::protobuf::Message for BuildRouteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildRouteResponse {
        BuildRouteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lightning::Route>>(
                "route",
                |m: &BuildRouteResponse| { &m.route },
                |m: &mut BuildRouteResponse| { &mut m.route },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildRouteResponse>(
                "BuildRouteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildRouteResponse {
        static instance: ::protobuf::rt::LazyV2<BuildRouteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildRouteResponse::new)
    }
}

impl ::protobuf::Clear for BuildRouteResponse {
    fn clear(&mut self) {
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildRouteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildRouteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SubscribeHtlcEventsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHtlcEventsRequest {
    fn default() -> &'a SubscribeHtlcEventsRequest {
        <SubscribeHtlcEventsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHtlcEventsRequest {
    pub fn new() -> SubscribeHtlcEventsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHtlcEventsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHtlcEventsRequest {
        SubscribeHtlcEventsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHtlcEventsRequest>(
                "SubscribeHtlcEventsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHtlcEventsRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeHtlcEventsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHtlcEventsRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeHtlcEventsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHtlcEventsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHtlcEventsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HtlcEvent {
    // message fields
    pub incoming_channel_id: u64,
    pub outgoing_channel_id: u64,
    pub incoming_htlc_id: u64,
    pub outgoing_htlc_id: u64,
    pub timestamp_ns: u64,
    pub event_type: HtlcEvent_EventType,
    // message oneof groups
    pub event: ::std::option::Option<HtlcEvent_oneof_event>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HtlcEvent {
    fn default() -> &'a HtlcEvent {
        <HtlcEvent as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum HtlcEvent_oneof_event {
    forward_event(ForwardEvent),
    forward_fail_event(ForwardFailEvent),
    settle_event(SettleEvent),
    link_fail_event(LinkFailEvent),
}

impl HtlcEvent {
    pub fn new() -> HtlcEvent {
        ::std::default::Default::default()
    }

    // uint64 incoming_channel_id = 1;


    pub fn get_incoming_channel_id(&self) -> u64 {
        self.incoming_channel_id
    }
    pub fn clear_incoming_channel_id(&mut self) {
        self.incoming_channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_channel_id(&mut self, v: u64) {
        self.incoming_channel_id = v;
    }

    // uint64 outgoing_channel_id = 2;


    pub fn get_outgoing_channel_id(&self) -> u64 {
        self.outgoing_channel_id
    }
    pub fn clear_outgoing_channel_id(&mut self) {
        self.outgoing_channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_channel_id(&mut self, v: u64) {
        self.outgoing_channel_id = v;
    }

    // uint64 incoming_htlc_id = 3;


    pub fn get_incoming_htlc_id(&self) -> u64 {
        self.incoming_htlc_id
    }
    pub fn clear_incoming_htlc_id(&mut self) {
        self.incoming_htlc_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_htlc_id(&mut self, v: u64) {
        self.incoming_htlc_id = v;
    }

    // uint64 outgoing_htlc_id = 4;


    pub fn get_outgoing_htlc_id(&self) -> u64 {
        self.outgoing_htlc_id
    }
    pub fn clear_outgoing_htlc_id(&mut self) {
        self.outgoing_htlc_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_htlc_id(&mut self, v: u64) {
        self.outgoing_htlc_id = v;
    }

    // uint64 timestamp_ns = 5;


    pub fn get_timestamp_ns(&self) -> u64 {
        self.timestamp_ns
    }
    pub fn clear_timestamp_ns(&mut self) {
        self.timestamp_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_ns(&mut self, v: u64) {
        self.timestamp_ns = v;
    }

    // .routerrpc.HtlcEvent.EventType event_type = 6;


    pub fn get_event_type(&self) -> HtlcEvent_EventType {
        self.event_type
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = HtlcEvent_EventType::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: HtlcEvent_EventType) {
        self.event_type = v;
    }

    // .routerrpc.ForwardEvent forward_event = 7;


    pub fn get_forward_event(&self) -> &ForwardEvent {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(ref v)) => v,
            _ => <ForwardEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_forward_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_forward_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_forward_event(&mut self, v: ForwardEvent) {
        self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_forward_event(&mut self) -> &mut ForwardEvent {
        if let ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(ForwardEvent::new()));
        }
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_forward_event(&mut self) -> ForwardEvent {
        if self.has_forward_event() {
            match self.event.take() {
                ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(v)) => v,
                _ => panic!(),
            }
        } else {
            ForwardEvent::new()
        }
    }

    // .routerrpc.ForwardFailEvent forward_fail_event = 8;


    pub fn get_forward_fail_event(&self) -> &ForwardFailEvent {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(ref v)) => v,
            _ => <ForwardFailEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_forward_fail_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_forward_fail_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_forward_fail_event(&mut self, v: ForwardFailEvent) {
        self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_forward_fail_event(&mut self) -> &mut ForwardFailEvent {
        if let ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(ForwardFailEvent::new()));
        }
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_forward_fail_event(&mut self) -> ForwardFailEvent {
        if self.has_forward_fail_event() {
            match self.event.take() {
                ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(v)) => v,
                _ => panic!(),
            }
        } else {
            ForwardFailEvent::new()
        }
    }

    // .routerrpc.SettleEvent settle_event = 9;


    pub fn get_settle_event(&self) -> &SettleEvent {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(ref v)) => v,
            _ => <SettleEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_settle_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_settle_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_settle_event(&mut self, v: SettleEvent) {
        self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_settle_event(&mut self) -> &mut SettleEvent {
        if let ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(SettleEvent::new()));
        }
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_settle_event(&mut self) -> SettleEvent {
        if self.has_settle_event() {
            match self.event.take() {
                ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(v)) => v,
                _ => panic!(),
            }
        } else {
            SettleEvent::new()
        }
    }

    // .routerrpc.LinkFailEvent link_fail_event = 10;


    pub fn get_link_fail_event(&self) -> &LinkFailEvent {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(ref v)) => v,
            _ => <LinkFailEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_link_fail_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_link_fail_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_link_fail_event(&mut self, v: LinkFailEvent) {
        self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_link_fail_event(&mut self) -> &mut LinkFailEvent {
        if let ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(LinkFailEvent::new()));
        }
        match self.event {
            ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_link_fail_event(&mut self) -> LinkFailEvent {
        if self.has_link_fail_event() {
            match self.event.take() {
                ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(v)) => v,
                _ => panic!(),
            }
        } else {
            LinkFailEvent::new()
        }
    }
}

impl ::protobuf::Message for HtlcEvent {
    fn is_initialized(&self) -> bool {
        if let Some(HtlcEvent_oneof_event::forward_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HtlcEvent_oneof_event::forward_fail_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HtlcEvent_oneof_event::settle_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HtlcEvent_oneof_event::link_fail_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.incoming_channel_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_channel_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.incoming_htlc_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_htlc_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_ns = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.event_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::forward_event(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::forward_fail_event(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::settle_event(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HtlcEvent_oneof_event::link_fail_event(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming_channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.incoming_channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_channel_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.outgoing_channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.incoming_htlc_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.incoming_htlc_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_htlc_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.outgoing_htlc_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp_ns != 0 {
            my_size += ::protobuf::rt::value_size(5, self.timestamp_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_type != HtlcEvent_EventType::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(6, self.event_type);
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &HtlcEvent_oneof_event::forward_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HtlcEvent_oneof_event::forward_fail_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HtlcEvent_oneof_event::settle_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HtlcEvent_oneof_event::link_fail_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.incoming_channel_id != 0 {
            os.write_uint64(1, self.incoming_channel_id)?;
        }
        if self.outgoing_channel_id != 0 {
            os.write_uint64(2, self.outgoing_channel_id)?;
        }
        if self.incoming_htlc_id != 0 {
            os.write_uint64(3, self.incoming_htlc_id)?;
        }
        if self.outgoing_htlc_id != 0 {
            os.write_uint64(4, self.outgoing_htlc_id)?;
        }
        if self.timestamp_ns != 0 {
            os.write_uint64(5, self.timestamp_ns)?;
        }
        if self.event_type != HtlcEvent_EventType::UNKNOWN {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.event_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &HtlcEvent_oneof_event::forward_event(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HtlcEvent_oneof_event::forward_fail_event(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HtlcEvent_oneof_event::settle_event(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HtlcEvent_oneof_event::link_fail_event(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HtlcEvent {
        HtlcEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "incoming_channel_id",
                |m: &HtlcEvent| { &m.incoming_channel_id },
                |m: &mut HtlcEvent| { &mut m.incoming_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_channel_id",
                |m: &HtlcEvent| { &m.outgoing_channel_id },
                |m: &mut HtlcEvent| { &mut m.outgoing_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "incoming_htlc_id",
                |m: &HtlcEvent| { &m.incoming_htlc_id },
                |m: &mut HtlcEvent| { &mut m.incoming_htlc_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_htlc_id",
                |m: &HtlcEvent| { &m.outgoing_htlc_id },
                |m: &mut HtlcEvent| { &mut m.outgoing_htlc_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp_ns",
                |m: &HtlcEvent| { &m.timestamp_ns },
                |m: &mut HtlcEvent| { &mut m.timestamp_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HtlcEvent_EventType>>(
                "event_type",
                |m: &HtlcEvent| { &m.event_type },
                |m: &mut HtlcEvent| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ForwardEvent>(
                "forward_event",
                HtlcEvent::has_forward_event,
                HtlcEvent::get_forward_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ForwardFailEvent>(
                "forward_fail_event",
                HtlcEvent::has_forward_fail_event,
                HtlcEvent::get_forward_fail_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SettleEvent>(
                "settle_event",
                HtlcEvent::has_settle_event,
                HtlcEvent::get_settle_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LinkFailEvent>(
                "link_fail_event",
                HtlcEvent::has_link_fail_event,
                HtlcEvent::get_link_fail_event,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HtlcEvent>(
                "HtlcEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HtlcEvent {
        static instance: ::protobuf::rt::LazyV2<HtlcEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HtlcEvent::new)
    }
}

impl ::protobuf::Clear for HtlcEvent {
    fn clear(&mut self) {
        self.incoming_channel_id = 0;
        self.outgoing_channel_id = 0;
        self.incoming_htlc_id = 0;
        self.outgoing_htlc_id = 0;
        self.timestamp_ns = 0;
        self.event_type = HtlcEvent_EventType::UNKNOWN;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HtlcEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HtlcEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum HtlcEvent_EventType {
    UNKNOWN = 0,
    SEND = 1,
    RECEIVE = 2,
    FORWARD = 3,
}

impl ::protobuf::ProtobufEnum for HtlcEvent_EventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HtlcEvent_EventType> {
        match value {
            0 => ::std::option::Option::Some(HtlcEvent_EventType::UNKNOWN),
            1 => ::std::option::Option::Some(HtlcEvent_EventType::SEND),
            2 => ::std::option::Option::Some(HtlcEvent_EventType::RECEIVE),
            3 => ::std::option::Option::Some(HtlcEvent_EventType::FORWARD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HtlcEvent_EventType] = &[
            HtlcEvent_EventType::UNKNOWN,
            HtlcEvent_EventType::SEND,
            HtlcEvent_EventType::RECEIVE,
            HtlcEvent_EventType::FORWARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HtlcEvent_EventType>("HtlcEvent.EventType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HtlcEvent_EventType {
}

impl ::std::default::Default for HtlcEvent_EventType {
    fn default() -> Self {
        HtlcEvent_EventType::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for HtlcEvent_EventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HtlcInfo {
    // message fields
    pub incoming_timelock: u32,
    pub outgoing_timelock: u32,
    pub incoming_amt_msat: u64,
    pub outgoing_amt_msat: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HtlcInfo {
    fn default() -> &'a HtlcInfo {
        <HtlcInfo as ::protobuf::Message>::default_instance()
    }
}

impl HtlcInfo {
    pub fn new() -> HtlcInfo {
        ::std::default::Default::default()
    }

    // uint32 incoming_timelock = 1;


    pub fn get_incoming_timelock(&self) -> u32 {
        self.incoming_timelock
    }
    pub fn clear_incoming_timelock(&mut self) {
        self.incoming_timelock = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_timelock(&mut self, v: u32) {
        self.incoming_timelock = v;
    }

    // uint32 outgoing_timelock = 2;


    pub fn get_outgoing_timelock(&self) -> u32 {
        self.outgoing_timelock
    }
    pub fn clear_outgoing_timelock(&mut self) {
        self.outgoing_timelock = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_timelock(&mut self, v: u32) {
        self.outgoing_timelock = v;
    }

    // uint64 incoming_amt_msat = 3;


    pub fn get_incoming_amt_msat(&self) -> u64 {
        self.incoming_amt_msat
    }
    pub fn clear_incoming_amt_msat(&mut self) {
        self.incoming_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_amt_msat(&mut self, v: u64) {
        self.incoming_amt_msat = v;
    }

    // uint64 outgoing_amt_msat = 4;


    pub fn get_outgoing_amt_msat(&self) -> u64 {
        self.outgoing_amt_msat
    }
    pub fn clear_outgoing_amt_msat(&mut self) {
        self.outgoing_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_amt_msat(&mut self, v: u64) {
        self.outgoing_amt_msat = v;
    }
}

impl ::protobuf::Message for HtlcInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.incoming_timelock = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.outgoing_timelock = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.incoming_amt_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming_timelock != 0 {
            my_size += ::protobuf::rt::value_size(1, self.incoming_timelock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_timelock != 0 {
            my_size += ::protobuf::rt::value_size(2, self.outgoing_timelock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.incoming_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.incoming_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.outgoing_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.incoming_timelock != 0 {
            os.write_uint32(1, self.incoming_timelock)?;
        }
        if self.outgoing_timelock != 0 {
            os.write_uint32(2, self.outgoing_timelock)?;
        }
        if self.incoming_amt_msat != 0 {
            os.write_uint64(3, self.incoming_amt_msat)?;
        }
        if self.outgoing_amt_msat != 0 {
            os.write_uint64(4, self.outgoing_amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HtlcInfo {
        HtlcInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "incoming_timelock",
                |m: &HtlcInfo| { &m.incoming_timelock },
                |m: &mut HtlcInfo| { &mut m.incoming_timelock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "outgoing_timelock",
                |m: &HtlcInfo| { &m.outgoing_timelock },
                |m: &mut HtlcInfo| { &mut m.outgoing_timelock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "incoming_amt_msat",
                |m: &HtlcInfo| { &m.incoming_amt_msat },
                |m: &mut HtlcInfo| { &mut m.incoming_amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_amt_msat",
                |m: &HtlcInfo| { &m.outgoing_amt_msat },
                |m: &mut HtlcInfo| { &mut m.outgoing_amt_msat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HtlcInfo>(
                "HtlcInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HtlcInfo {
        static instance: ::protobuf::rt::LazyV2<HtlcInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HtlcInfo::new)
    }
}

impl ::protobuf::Clear for HtlcInfo {
    fn clear(&mut self) {
        self.incoming_timelock = 0;
        self.outgoing_timelock = 0;
        self.incoming_amt_msat = 0;
        self.outgoing_amt_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HtlcInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HtlcInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardEvent {
    // message fields
    pub info: ::protobuf::SingularPtrField<HtlcInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardEvent {
    fn default() -> &'a ForwardEvent {
        <ForwardEvent as ::protobuf::Message>::default_instance()
    }
}

impl ForwardEvent {
    pub fn new() -> ForwardEvent {
        ::std::default::Default::default()
    }

    // .routerrpc.HtlcInfo info = 1;


    pub fn get_info(&self) -> &HtlcInfo {
        self.info.as_ref().unwrap_or_else(|| <HtlcInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: HtlcInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut HtlcInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> HtlcInfo {
        self.info.take().unwrap_or_else(|| HtlcInfo::new())
    }
}

impl ::protobuf::Message for ForwardEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardEvent {
        ForwardEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HtlcInfo>>(
                "info",
                |m: &ForwardEvent| { &m.info },
                |m: &mut ForwardEvent| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardEvent>(
                "ForwardEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardEvent {
        static instance: ::protobuf::rt::LazyV2<ForwardEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardEvent::new)
    }
}

impl ::protobuf::Clear for ForwardEvent {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardFailEvent {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardFailEvent {
    fn default() -> &'a ForwardFailEvent {
        <ForwardFailEvent as ::protobuf::Message>::default_instance()
    }
}

impl ForwardFailEvent {
    pub fn new() -> ForwardFailEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ForwardFailEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardFailEvent {
        ForwardFailEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardFailEvent>(
                "ForwardFailEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardFailEvent {
        static instance: ::protobuf::rt::LazyV2<ForwardFailEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardFailEvent::new)
    }
}

impl ::protobuf::Clear for ForwardFailEvent {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardFailEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardFailEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SettleEvent {
    // message fields
    pub preimage: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SettleEvent {
    fn default() -> &'a SettleEvent {
        <SettleEvent as ::protobuf::Message>::default_instance()
    }
}

impl SettleEvent {
    pub fn new() -> SettleEvent {
        ::std::default::Default::default()
    }

    // bytes preimage = 1;


    pub fn get_preimage(&self) -> &[u8] {
        &self.preimage
    }
    pub fn clear_preimage(&mut self) {
        self.preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.preimage
    }

    // Take field
    pub fn take_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.preimage, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SettleEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.preimage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.preimage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.preimage.is_empty() {
            os.write_bytes(1, &self.preimage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SettleEvent {
        SettleEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "preimage",
                |m: &SettleEvent| { &m.preimage },
                |m: &mut SettleEvent| { &mut m.preimage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SettleEvent>(
                "SettleEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SettleEvent {
        static instance: ::protobuf::rt::LazyV2<SettleEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SettleEvent::new)
    }
}

impl ::protobuf::Clear for SettleEvent {
    fn clear(&mut self) {
        self.preimage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SettleEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SettleEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LinkFailEvent {
    // message fields
    pub info: ::protobuf::SingularPtrField<HtlcInfo>,
    pub wire_failure: super::lightning::Failure_FailureCode,
    pub failure_detail: FailureDetail,
    pub failure_string: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinkFailEvent {
    fn default() -> &'a LinkFailEvent {
        <LinkFailEvent as ::protobuf::Message>::default_instance()
    }
}

impl LinkFailEvent {
    pub fn new() -> LinkFailEvent {
        ::std::default::Default::default()
    }

    // .routerrpc.HtlcInfo info = 1;


    pub fn get_info(&self) -> &HtlcInfo {
        self.info.as_ref().unwrap_or_else(|| <HtlcInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: HtlcInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut HtlcInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> HtlcInfo {
        self.info.take().unwrap_or_else(|| HtlcInfo::new())
    }

    // .lnrpc.Failure.FailureCode wire_failure = 2;


    pub fn get_wire_failure(&self) -> super::lightning::Failure_FailureCode {
        self.wire_failure
    }
    pub fn clear_wire_failure(&mut self) {
        self.wire_failure = super::lightning::Failure_FailureCode::RESERVED;
    }

    // Param is passed by value, moved
    pub fn set_wire_failure(&mut self, v: super::lightning::Failure_FailureCode) {
        self.wire_failure = v;
    }

    // .routerrpc.FailureDetail failure_detail = 3;


    pub fn get_failure_detail(&self) -> FailureDetail {
        self.failure_detail
    }
    pub fn clear_failure_detail(&mut self) {
        self.failure_detail = FailureDetail::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_failure_detail(&mut self, v: FailureDetail) {
        self.failure_detail = v;
    }

    // string failure_string = 4;


    pub fn get_failure_string(&self) -> &str {
        &self.failure_string
    }
    pub fn clear_failure_string(&mut self) {
        self.failure_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure_string(&mut self, v: ::std::string::String) {
        self.failure_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failure_string(&mut self) -> &mut ::std::string::String {
        &mut self.failure_string
    }

    // Take field
    pub fn take_failure_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.failure_string, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinkFailEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.wire_failure, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.failure_detail, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.failure_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.wire_failure != super::lightning::Failure_FailureCode::RESERVED {
            my_size += ::protobuf::rt::enum_size(2, self.wire_failure);
        }
        if self.failure_detail != FailureDetail::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.failure_detail);
        }
        if !self.failure_string.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.failure_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.wire_failure != super::lightning::Failure_FailureCode::RESERVED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.wire_failure))?;
        }
        if self.failure_detail != FailureDetail::UNKNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.failure_detail))?;
        }
        if !self.failure_string.is_empty() {
            os.write_string(4, &self.failure_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkFailEvent {
        LinkFailEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HtlcInfo>>(
                "info",
                |m: &LinkFailEvent| { &m.info },
                |m: &mut LinkFailEvent| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::lightning::Failure_FailureCode>>(
                "wire_failure",
                |m: &LinkFailEvent| { &m.wire_failure },
                |m: &mut LinkFailEvent| { &mut m.wire_failure },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FailureDetail>>(
                "failure_detail",
                |m: &LinkFailEvent| { &m.failure_detail },
                |m: &mut LinkFailEvent| { &mut m.failure_detail },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failure_string",
                |m: &LinkFailEvent| { &m.failure_string },
                |m: &mut LinkFailEvent| { &mut m.failure_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinkFailEvent>(
                "LinkFailEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinkFailEvent {
        static instance: ::protobuf::rt::LazyV2<LinkFailEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinkFailEvent::new)
    }
}

impl ::protobuf::Clear for LinkFailEvent {
    fn clear(&mut self) {
        self.info.clear();
        self.wire_failure = super::lightning::Failure_FailureCode::RESERVED;
        self.failure_detail = FailureDetail::UNKNOWN;
        self.failure_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkFailEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkFailEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaymentStatus {
    // message fields
    pub state: PaymentState,
    pub preimage: ::std::vec::Vec<u8>,
    pub htlcs: ::protobuf::RepeatedField<super::lightning::HTLCAttempt>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentStatus {
    fn default() -> &'a PaymentStatus {
        <PaymentStatus as ::protobuf::Message>::default_instance()
    }
}

impl PaymentStatus {
    pub fn new() -> PaymentStatus {
        ::std::default::Default::default()
    }

    // .routerrpc.PaymentState state = 1;


    pub fn get_state(&self) -> PaymentState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PaymentState::IN_FLIGHT;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PaymentState) {
        self.state = v;
    }

    // bytes preimage = 2;


    pub fn get_preimage(&self) -> &[u8] {
        &self.preimage
    }
    pub fn clear_preimage(&mut self) {
        self.preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.preimage
    }

    // Take field
    pub fn take_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.preimage, ::std::vec::Vec::new())
    }

    // repeated .lnrpc.HTLCAttempt htlcs = 4;


    pub fn get_htlcs(&self) -> &[super::lightning::HTLCAttempt] {
        &self.htlcs
    }
    pub fn clear_htlcs(&mut self) {
        self.htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlcs(&mut self, v: ::protobuf::RepeatedField<super::lightning::HTLCAttempt>) {
        self.htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<super::lightning::HTLCAttempt> {
        &mut self.htlcs
    }

    // Take field
    pub fn take_htlcs(&mut self) -> ::protobuf::RepeatedField<super::lightning::HTLCAttempt> {
        ::std::mem::replace(&mut self.htlcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PaymentStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.preimage)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.htlcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != PaymentState::IN_FLIGHT {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        if !self.preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.preimage);
        }
        for value in &self.htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != PaymentState::IN_FLIGHT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if !self.preimage.is_empty() {
            os.write_bytes(2, &self.preimage)?;
        }
        for v in &self.htlcs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentStatus {
        PaymentStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PaymentState>>(
                "state",
                |m: &PaymentStatus| { &m.state },
                |m: &mut PaymentStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "preimage",
                |m: &PaymentStatus| { &m.preimage },
                |m: &mut PaymentStatus| { &mut m.preimage },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lightning::HTLCAttempt>>(
                "htlcs",
                |m: &PaymentStatus| { &m.htlcs },
                |m: &mut PaymentStatus| { &mut m.htlcs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaymentStatus>(
                "PaymentStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaymentStatus {
        static instance: ::protobuf::rt::LazyV2<PaymentStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaymentStatus::new)
    }
}

impl ::protobuf::Clear for PaymentStatus {
    fn clear(&mut self) {
        self.state = PaymentState::IN_FLIGHT;
        self.preimage.clear();
        self.htlcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CircuitKey {
    // message fields
    pub chan_id: u64,
    pub htlc_id: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CircuitKey {
    fn default() -> &'a CircuitKey {
        <CircuitKey as ::protobuf::Message>::default_instance()
    }
}

impl CircuitKey {
    pub fn new() -> CircuitKey {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // uint64 htlc_id = 2;


    pub fn get_htlc_id(&self) -> u64 {
        self.htlc_id
    }
    pub fn clear_htlc_id(&mut self) {
        self.htlc_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_id(&mut self, v: u64) {
        self.htlc_id = v;
    }
}

impl ::protobuf::Message for CircuitKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.htlc_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.htlc_id != 0 {
            os.write_uint64(2, self.htlc_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CircuitKey {
        CircuitKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &CircuitKey| { &m.chan_id },
                |m: &mut CircuitKey| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "htlc_id",
                |m: &CircuitKey| { &m.htlc_id },
                |m: &mut CircuitKey| { &mut m.htlc_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CircuitKey>(
                "CircuitKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CircuitKey {
        static instance: ::protobuf::rt::LazyV2<CircuitKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CircuitKey::new)
    }
}

impl ::protobuf::Clear for CircuitKey {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.htlc_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CircuitKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircuitKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardHtlcInterceptRequest {
    // message fields
    pub incoming_circuit_key: ::protobuf::SingularPtrField<CircuitKey>,
    pub incoming_amount_msat: u64,
    pub incoming_expiry: u32,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub outgoing_requested_chan_id: u64,
    pub outgoing_amount_msat: u64,
    pub outgoing_expiry: u32,
    pub custom_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    pub onion_blob: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardHtlcInterceptRequest {
    fn default() -> &'a ForwardHtlcInterceptRequest {
        <ForwardHtlcInterceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl ForwardHtlcInterceptRequest {
    pub fn new() -> ForwardHtlcInterceptRequest {
        ::std::default::Default::default()
    }

    // .routerrpc.CircuitKey incoming_circuit_key = 1;


    pub fn get_incoming_circuit_key(&self) -> &CircuitKey {
        self.incoming_circuit_key.as_ref().unwrap_or_else(|| <CircuitKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_incoming_circuit_key(&mut self) {
        self.incoming_circuit_key.clear();
    }

    pub fn has_incoming_circuit_key(&self) -> bool {
        self.incoming_circuit_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incoming_circuit_key(&mut self, v: CircuitKey) {
        self.incoming_circuit_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_incoming_circuit_key(&mut self) -> &mut CircuitKey {
        if self.incoming_circuit_key.is_none() {
            self.incoming_circuit_key.set_default();
        }
        self.incoming_circuit_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_incoming_circuit_key(&mut self) -> CircuitKey {
        self.incoming_circuit_key.take().unwrap_or_else(|| CircuitKey::new())
    }

    // uint64 incoming_amount_msat = 5;


    pub fn get_incoming_amount_msat(&self) -> u64 {
        self.incoming_amount_msat
    }
    pub fn clear_incoming_amount_msat(&mut self) {
        self.incoming_amount_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_amount_msat(&mut self, v: u64) {
        self.incoming_amount_msat = v;
    }

    // uint32 incoming_expiry = 6;


    pub fn get_incoming_expiry(&self) -> u32 {
        self.incoming_expiry
    }
    pub fn clear_incoming_expiry(&mut self) {
        self.incoming_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_incoming_expiry(&mut self, v: u32) {
        self.incoming_expiry = v;
    }

    // bytes payment_hash = 2;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // uint64 outgoing_requested_chan_id = 7;


    pub fn get_outgoing_requested_chan_id(&self) -> u64 {
        self.outgoing_requested_chan_id
    }
    pub fn clear_outgoing_requested_chan_id(&mut self) {
        self.outgoing_requested_chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_requested_chan_id(&mut self, v: u64) {
        self.outgoing_requested_chan_id = v;
    }

    // uint64 outgoing_amount_msat = 3;


    pub fn get_outgoing_amount_msat(&self) -> u64 {
        self.outgoing_amount_msat
    }
    pub fn clear_outgoing_amount_msat(&mut self) {
        self.outgoing_amount_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_amount_msat(&mut self, v: u64) {
        self.outgoing_amount_msat = v;
    }

    // uint32 outgoing_expiry = 4;


    pub fn get_outgoing_expiry(&self) -> u32 {
        self.outgoing_expiry
    }
    pub fn clear_outgoing_expiry(&mut self) {
        self.outgoing_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_expiry(&mut self, v: u32) {
        self.outgoing_expiry = v;
    }

    // repeated .routerrpc.ForwardHtlcInterceptRequest.CustomRecordsEntry custom_records = 8;


    pub fn get_custom_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.custom_records
    }
    pub fn clear_custom_records(&mut self) {
        self.custom_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.custom_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.custom_records
    }

    // Take field
    pub fn take_custom_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.custom_records, ::std::collections::HashMap::new())
    }

    // bytes onion_blob = 9;


    pub fn get_onion_blob(&self) -> &[u8] {
        &self.onion_blob
    }
    pub fn clear_onion_blob(&mut self) {
        self.onion_blob.clear();
    }

    // Param is passed by value, moved
    pub fn set_onion_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.onion_blob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onion_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.onion_blob
    }

    // Take field
    pub fn take_onion_blob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.onion_blob, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ForwardHtlcInterceptRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.incoming_circuit_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.incoming_circuit_key)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.incoming_amount_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.incoming_expiry = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_requested_chan_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_amount_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.outgoing_expiry = tmp;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.custom_records)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.onion_blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.incoming_circuit_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.incoming_amount_msat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.incoming_amount_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.incoming_expiry != 0 {
            my_size += ::protobuf::rt::value_size(6, self.incoming_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payment_hash);
        }
        if self.outgoing_requested_chan_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.outgoing_requested_chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_amount_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.outgoing_amount_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.outgoing_expiry != 0 {
            my_size += ::protobuf::rt::value_size(4, self.outgoing_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(8, &self.custom_records);
        if !self.onion_blob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.onion_blob);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.incoming_circuit_key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.incoming_amount_msat != 0 {
            os.write_uint64(5, self.incoming_amount_msat)?;
        }
        if self.incoming_expiry != 0 {
            os.write_uint32(6, self.incoming_expiry)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(2, &self.payment_hash)?;
        }
        if self.outgoing_requested_chan_id != 0 {
            os.write_uint64(7, self.outgoing_requested_chan_id)?;
        }
        if self.outgoing_amount_msat != 0 {
            os.write_uint64(3, self.outgoing_amount_msat)?;
        }
        if self.outgoing_expiry != 0 {
            os.write_uint32(4, self.outgoing_expiry)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(8, &self.custom_records, os)?;
        if !self.onion_blob.is_empty() {
            os.write_bytes(9, &self.onion_blob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardHtlcInterceptRequest {
        ForwardHtlcInterceptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CircuitKey>>(
                "incoming_circuit_key",
                |m: &ForwardHtlcInterceptRequest| { &m.incoming_circuit_key },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.incoming_circuit_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "incoming_amount_msat",
                |m: &ForwardHtlcInterceptRequest| { &m.incoming_amount_msat },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.incoming_amount_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "incoming_expiry",
                |m: &ForwardHtlcInterceptRequest| { &m.incoming_expiry },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.incoming_expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &ForwardHtlcInterceptRequest| { &m.payment_hash },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_requested_chan_id",
                |m: &ForwardHtlcInterceptRequest| { &m.outgoing_requested_chan_id },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.outgoing_requested_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_amount_msat",
                |m: &ForwardHtlcInterceptRequest| { &m.outgoing_amount_msat },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.outgoing_amount_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "outgoing_expiry",
                |m: &ForwardHtlcInterceptRequest| { &m.outgoing_expiry },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.outgoing_expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                "custom_records",
                |m: &ForwardHtlcInterceptRequest| { &m.custom_records },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.custom_records },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "onion_blob",
                |m: &ForwardHtlcInterceptRequest| { &m.onion_blob },
                |m: &mut ForwardHtlcInterceptRequest| { &mut m.onion_blob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardHtlcInterceptRequest>(
                "ForwardHtlcInterceptRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardHtlcInterceptRequest {
        static instance: ::protobuf::rt::LazyV2<ForwardHtlcInterceptRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardHtlcInterceptRequest::new)
    }
}

impl ::protobuf::Clear for ForwardHtlcInterceptRequest {
    fn clear(&mut self) {
        self.incoming_circuit_key.clear();
        self.incoming_amount_msat = 0;
        self.incoming_expiry = 0;
        self.payment_hash.clear();
        self.outgoing_requested_chan_id = 0;
        self.outgoing_amount_msat = 0;
        self.outgoing_expiry = 0;
        self.custom_records.clear();
        self.onion_blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardHtlcInterceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardHtlcInterceptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardHtlcInterceptResponse {
    // message fields
    pub incoming_circuit_key: ::protobuf::SingularPtrField<CircuitKey>,
    pub action: ResolveHoldForwardAction,
    pub preimage: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardHtlcInterceptResponse {
    fn default() -> &'a ForwardHtlcInterceptResponse {
        <ForwardHtlcInterceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl ForwardHtlcInterceptResponse {
    pub fn new() -> ForwardHtlcInterceptResponse {
        ::std::default::Default::default()
    }

    // .routerrpc.CircuitKey incoming_circuit_key = 1;


    pub fn get_incoming_circuit_key(&self) -> &CircuitKey {
        self.incoming_circuit_key.as_ref().unwrap_or_else(|| <CircuitKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_incoming_circuit_key(&mut self) {
        self.incoming_circuit_key.clear();
    }

    pub fn has_incoming_circuit_key(&self) -> bool {
        self.incoming_circuit_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incoming_circuit_key(&mut self, v: CircuitKey) {
        self.incoming_circuit_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_incoming_circuit_key(&mut self) -> &mut CircuitKey {
        if self.incoming_circuit_key.is_none() {
            self.incoming_circuit_key.set_default();
        }
        self.incoming_circuit_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_incoming_circuit_key(&mut self) -> CircuitKey {
        self.incoming_circuit_key.take().unwrap_or_else(|| CircuitKey::new())
    }

    // .routerrpc.ResolveHoldForwardAction action = 2;


    pub fn get_action(&self) -> ResolveHoldForwardAction {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ResolveHoldForwardAction::SETTLE;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ResolveHoldForwardAction) {
        self.action = v;
    }

    // bytes preimage = 3;


    pub fn get_preimage(&self) -> &[u8] {
        &self.preimage
    }
    pub fn clear_preimage(&mut self) {
        self.preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.preimage
    }

    // Take field
    pub fn take_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.preimage, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ForwardHtlcInterceptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.incoming_circuit_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.incoming_circuit_key)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.preimage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.incoming_circuit_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.action != ResolveHoldForwardAction::SETTLE {
            my_size += ::protobuf::rt::enum_size(2, self.action);
        }
        if !self.preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.preimage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.incoming_circuit_key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.action != ResolveHoldForwardAction::SETTLE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if !self.preimage.is_empty() {
            os.write_bytes(3, &self.preimage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardHtlcInterceptResponse {
        ForwardHtlcInterceptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CircuitKey>>(
                "incoming_circuit_key",
                |m: &ForwardHtlcInterceptResponse| { &m.incoming_circuit_key },
                |m: &mut ForwardHtlcInterceptResponse| { &mut m.incoming_circuit_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResolveHoldForwardAction>>(
                "action",
                |m: &ForwardHtlcInterceptResponse| { &m.action },
                |m: &mut ForwardHtlcInterceptResponse| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "preimage",
                |m: &ForwardHtlcInterceptResponse| { &m.preimage },
                |m: &mut ForwardHtlcInterceptResponse| { &mut m.preimage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardHtlcInterceptResponse>(
                "ForwardHtlcInterceptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardHtlcInterceptResponse {
        static instance: ::protobuf::rt::LazyV2<ForwardHtlcInterceptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardHtlcInterceptResponse::new)
    }
}

impl ::protobuf::Clear for ForwardHtlcInterceptResponse {
    fn clear(&mut self) {
        self.incoming_circuit_key.clear();
        self.action = ResolveHoldForwardAction::SETTLE;
        self.preimage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardHtlcInterceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardHtlcInterceptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateChanStatusRequest {
    // message fields
    pub chan_point: ::protobuf::SingularPtrField<super::lightning::ChannelPoint>,
    pub action: ChanStatusAction,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateChanStatusRequest {
    fn default() -> &'a UpdateChanStatusRequest {
        <UpdateChanStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateChanStatusRequest {
    pub fn new() -> UpdateChanStatusRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint chan_point = 1;


    pub fn get_chan_point(&self) -> &super::lightning::ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| <super::lightning::ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: super::lightning::ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut super::lightning::ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> super::lightning::ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| super::lightning::ChannelPoint::new())
    }

    // .routerrpc.ChanStatusAction action = 2;


    pub fn get_action(&self) -> ChanStatusAction {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ChanStatusAction::ENABLE;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ChanStatusAction) {
        self.action = v;
    }
}

impl ::protobuf::Message for UpdateChanStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.action != ChanStatusAction::ENABLE {
            my_size += ::protobuf::rt::enum_size(2, self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.action != ChanStatusAction::ENABLE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateChanStatusRequest {
        UpdateChanStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lightning::ChannelPoint>>(
                "chan_point",
                |m: &UpdateChanStatusRequest| { &m.chan_point },
                |m: &mut UpdateChanStatusRequest| { &mut m.chan_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChanStatusAction>>(
                "action",
                |m: &UpdateChanStatusRequest| { &m.action },
                |m: &mut UpdateChanStatusRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateChanStatusRequest>(
                "UpdateChanStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateChanStatusRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateChanStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateChanStatusRequest::new)
    }
}

impl ::protobuf::Clear for UpdateChanStatusRequest {
    fn clear(&mut self) {
        self.chan_point.clear();
        self.action = ChanStatusAction::ENABLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateChanStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateChanStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateChanStatusResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateChanStatusResponse {
    fn default() -> &'a UpdateChanStatusResponse {
        <UpdateChanStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateChanStatusResponse {
    pub fn new() -> UpdateChanStatusResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateChanStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateChanStatusResponse {
        UpdateChanStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateChanStatusResponse>(
                "UpdateChanStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateChanStatusResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateChanStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateChanStatusResponse::new)
    }
}

impl ::protobuf::Clear for UpdateChanStatusResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateChanStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateChanStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FailureDetail {
    UNKNOWN = 0,
    NO_DETAIL = 1,
    ONION_DECODE = 2,
    LINK_NOT_ELIGIBLE = 3,
    ON_CHAIN_TIMEOUT = 4,
    HTLC_EXCEEDS_MAX = 5,
    INSUFFICIENT_BALANCE = 6,
    INCOMPLETE_FORWARD = 7,
    HTLC_ADD_FAILED = 8,
    FORWARDS_DISABLED = 9,
    INVOICE_CANCELED = 10,
    INVOICE_UNDERPAID = 11,
    INVOICE_EXPIRY_TOO_SOON = 12,
    INVOICE_NOT_OPEN = 13,
    MPP_INVOICE_TIMEOUT = 14,
    ADDRESS_MISMATCH = 15,
    SET_TOTAL_MISMATCH = 16,
    SET_TOTAL_TOO_LOW = 17,
    SET_OVERPAID = 18,
    UNKNOWN_INVOICE = 19,
    INVALID_KEYSEND = 20,
    MPP_IN_PROGRESS = 21,
    CIRCULAR_ROUTE = 22,
}

impl ::protobuf::ProtobufEnum for FailureDetail {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FailureDetail> {
        match value {
            0 => ::std::option::Option::Some(FailureDetail::UNKNOWN),
            1 => ::std::option::Option::Some(FailureDetail::NO_DETAIL),
            2 => ::std::option::Option::Some(FailureDetail::ONION_DECODE),
            3 => ::std::option::Option::Some(FailureDetail::LINK_NOT_ELIGIBLE),
            4 => ::std::option::Option::Some(FailureDetail::ON_CHAIN_TIMEOUT),
            5 => ::std::option::Option::Some(FailureDetail::HTLC_EXCEEDS_MAX),
            6 => ::std::option::Option::Some(FailureDetail::INSUFFICIENT_BALANCE),
            7 => ::std::option::Option::Some(FailureDetail::INCOMPLETE_FORWARD),
            8 => ::std::option::Option::Some(FailureDetail::HTLC_ADD_FAILED),
            9 => ::std::option::Option::Some(FailureDetail::FORWARDS_DISABLED),
            10 => ::std::option::Option::Some(FailureDetail::INVOICE_CANCELED),
            11 => ::std::option::Option::Some(FailureDetail::INVOICE_UNDERPAID),
            12 => ::std::option::Option::Some(FailureDetail::INVOICE_EXPIRY_TOO_SOON),
            13 => ::std::option::Option::Some(FailureDetail::INVOICE_NOT_OPEN),
            14 => ::std::option::Option::Some(FailureDetail::MPP_INVOICE_TIMEOUT),
            15 => ::std::option::Option::Some(FailureDetail::ADDRESS_MISMATCH),
            16 => ::std::option::Option::Some(FailureDetail::SET_TOTAL_MISMATCH),
            17 => ::std::option::Option::Some(FailureDetail::SET_TOTAL_TOO_LOW),
            18 => ::std::option::Option::Some(FailureDetail::SET_OVERPAID),
            19 => ::std::option::Option::Some(FailureDetail::UNKNOWN_INVOICE),
            20 => ::std::option::Option::Some(FailureDetail::INVALID_KEYSEND),
            21 => ::std::option::Option::Some(FailureDetail::MPP_IN_PROGRESS),
            22 => ::std::option::Option::Some(FailureDetail::CIRCULAR_ROUTE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FailureDetail] = &[
            FailureDetail::UNKNOWN,
            FailureDetail::NO_DETAIL,
            FailureDetail::ONION_DECODE,
            FailureDetail::LINK_NOT_ELIGIBLE,
            FailureDetail::ON_CHAIN_TIMEOUT,
            FailureDetail::HTLC_EXCEEDS_MAX,
            FailureDetail::INSUFFICIENT_BALANCE,
            FailureDetail::INCOMPLETE_FORWARD,
            FailureDetail::HTLC_ADD_FAILED,
            FailureDetail::FORWARDS_DISABLED,
            FailureDetail::INVOICE_CANCELED,
            FailureDetail::INVOICE_UNDERPAID,
            FailureDetail::INVOICE_EXPIRY_TOO_SOON,
            FailureDetail::INVOICE_NOT_OPEN,
            FailureDetail::MPP_INVOICE_TIMEOUT,
            FailureDetail::ADDRESS_MISMATCH,
            FailureDetail::SET_TOTAL_MISMATCH,
            FailureDetail::SET_TOTAL_TOO_LOW,
            FailureDetail::SET_OVERPAID,
            FailureDetail::UNKNOWN_INVOICE,
            FailureDetail::INVALID_KEYSEND,
            FailureDetail::MPP_IN_PROGRESS,
            FailureDetail::CIRCULAR_ROUTE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FailureDetail>("FailureDetail", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FailureDetail {
}

impl ::std::default::Default for FailureDetail {
    fn default() -> Self {
        FailureDetail::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for FailureDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PaymentState {
    IN_FLIGHT = 0,
    SUCCEEDED = 1,
    FAILED_TIMEOUT = 2,
    FAILED_NO_ROUTE = 3,
    FAILED_ERROR = 4,
    FAILED_INCORRECT_PAYMENT_DETAILS = 5,
    FAILED_INSUFFICIENT_BALANCE = 6,
}

impl ::protobuf::ProtobufEnum for PaymentState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PaymentState> {
        match value {
            0 => ::std::option::Option::Some(PaymentState::IN_FLIGHT),
            1 => ::std::option::Option::Some(PaymentState::SUCCEEDED),
            2 => ::std::option::Option::Some(PaymentState::FAILED_TIMEOUT),
            3 => ::std::option::Option::Some(PaymentState::FAILED_NO_ROUTE),
            4 => ::std::option::Option::Some(PaymentState::FAILED_ERROR),
            5 => ::std::option::Option::Some(PaymentState::FAILED_INCORRECT_PAYMENT_DETAILS),
            6 => ::std::option::Option::Some(PaymentState::FAILED_INSUFFICIENT_BALANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PaymentState] = &[
            PaymentState::IN_FLIGHT,
            PaymentState::SUCCEEDED,
            PaymentState::FAILED_TIMEOUT,
            PaymentState::FAILED_NO_ROUTE,
            PaymentState::FAILED_ERROR,
            PaymentState::FAILED_INCORRECT_PAYMENT_DETAILS,
            PaymentState::FAILED_INSUFFICIENT_BALANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PaymentState>("PaymentState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PaymentState {
}

impl ::std::default::Default for PaymentState {
    fn default() -> Self {
        PaymentState::IN_FLIGHT
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ResolveHoldForwardAction {
    SETTLE = 0,
    FAIL = 1,
    RESUME = 2,
}

impl ::protobuf::ProtobufEnum for ResolveHoldForwardAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResolveHoldForwardAction> {
        match value {
            0 => ::std::option::Option::Some(ResolveHoldForwardAction::SETTLE),
            1 => ::std::option::Option::Some(ResolveHoldForwardAction::FAIL),
            2 => ::std::option::Option::Some(ResolveHoldForwardAction::RESUME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResolveHoldForwardAction] = &[
            ResolveHoldForwardAction::SETTLE,
            ResolveHoldForwardAction::FAIL,
            ResolveHoldForwardAction::RESUME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResolveHoldForwardAction>("ResolveHoldForwardAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResolveHoldForwardAction {
}

impl ::std::default::Default for ResolveHoldForwardAction {
    fn default() -> Self {
        ResolveHoldForwardAction::SETTLE
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveHoldForwardAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ChanStatusAction {
    ENABLE = 0,
    DISABLE = 1,
    AUTO = 2,
}

impl ::protobuf::ProtobufEnum for ChanStatusAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChanStatusAction> {
        match value {
            0 => ::std::option::Option::Some(ChanStatusAction::ENABLE),
            1 => ::std::option::Option::Some(ChanStatusAction::DISABLE),
            2 => ::std::option::Option::Some(ChanStatusAction::AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChanStatusAction] = &[
            ChanStatusAction::ENABLE,
            ChanStatusAction::DISABLE,
            ChanStatusAction::AUTO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChanStatusAction>("ChanStatusAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChanStatusAction {
}

impl ::std::default::Default for ChanStatusAction {
    fn default() -> Self {
        ChanStatusAction::ENABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanStatusAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0crouter.proto\x12\trouterrpc\x1a\x0flightning.proto\"\xd7\x07\n\x12\
    SendPaymentRequest\x12\x12\n\x04dest\x18\x01\x20\x01(\x0cR\x04dest\x12\
    \x10\n\x03amt\x18\x02\x20\x01(\x03R\x03amt\x12\x19\n\x08amt_msat\x18\x0c\
    \x20\x01(\x03R\x07amtMsat\x12!\n\x0cpayment_hash\x18\x03\x20\x01(\x0cR\
    \x0bpaymentHash\x12(\n\x10final_cltv_delta\x18\x04\x20\x01(\x05R\x0efina\
    lCltvDelta\x12!\n\x0cpayment_addr\x18\x14\x20\x01(\x0cR\x0bpaymentAddr\
    \x12'\n\x0fpayment_request\x18\x05\x20\x01(\tR\x0epaymentRequest\x12'\n\
    \x0ftimeout_seconds\x18\x06\x20\x01(\x05R\x0etimeoutSeconds\x12\"\n\rfee\
    _limit_sat\x18\x07\x20\x01(\x03R\x0bfeeLimitSat\x12$\n\x0efee_limit_msat\
    \x18\r\x20\x01(\x03R\x0cfeeLimitMsat\x12.\n\x10outgoing_chan_id\x18\x08\
    \x20\x01(\x04R\x0eoutgoingChanIdB\x040\x01\x18\x01\x12*\n\x11outgoing_ch\
    an_ids\x18\x13\x20\x03(\x04R\x0foutgoingChanIds\x12&\n\x0flast_hop_pubke\
    y\x18\x0e\x20\x01(\x0cR\rlastHopPubkey\x12\x1d\n\ncltv_limit\x18\t\x20\
    \x01(\x05R\tcltvLimit\x121\n\x0broute_hints\x18\n\x20\x03(\x0b2\x10.lnrp\
    c.RouteHintR\nrouteHints\x12d\n\x13dest_custom_records\x18\x0b\x20\x03(\
    \x0b24.routerrpc.SendPaymentRequest.DestCustomRecordsEntryR\x11destCusto\
    mRecords\x12,\n\x12allow_self_payment\x18\x0f\x20\x01(\x08R\x10allowSelf\
    Payment\x126\n\rdest_features\x18\x10\x20\x03(\x0e2\x11.lnrpc.FeatureBit\
    R\x0cdestFeatures\x12\x1b\n\tmax_parts\x18\x11\x20\x01(\rR\x08maxParts\
    \x12.\n\x13no_inflight_updates\x18\x12\x20\x01(\x08R\x11noInflightUpdate\
    s\x12-\n\x13max_shard_size_msat\x18\x15\x20\x01(\x04R\x10maxShardSizeMsa\
    t\x12\x10\n\x03amp\x18\x16\x20\x01(\x08R\x03amp\x1aD\n\x16DestCustomReco\
    rdsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\"h\n\x13TrackPaymentRequest\
    \x12!\n\x0cpayment_hash\x18\x01\x20\x01(\x0cR\x0bpaymentHash\x12.\n\x13n\
    o_inflight_updates\x18\x02\x20\x01(\x08R\x11noInflightUpdates\">\n\x0fRo\
    uteFeeRequest\x12\x12\n\x04dest\x18\x01\x20\x01(\x0cR\x04dest\x12\x17\n\
    \x07amt_sat\x18\x02\x20\x01(\x03R\x06amtSat\"d\n\x10RouteFeeResponse\x12\
    (\n\x10routing_fee_msat\x18\x01\x20\x01(\x03R\x0eroutingFeeMsat\x12&\n\
    \x0ftime_lock_delay\x18\x02\x20\x01(\x03R\rtimeLockDelay\"[\n\x12SendToR\
    outeRequest\x12!\n\x0cpayment_hash\x18\x01\x20\x01(\x0cR\x0bpaymentHash\
    \x12\"\n\x05route\x18\x02\x20\x01(\x0b2\x0c.lnrpc.RouteR\x05route\"[\n\
    \x13SendToRouteResponse\x12\x1a\n\x08preimage\x18\x01\x20\x01(\x0cR\x08p\
    reimage\x12(\n\x07failure\x18\x02\x20\x01(\x0b2\x0e.lnrpc.FailureR\x07fa\
    ilure\"\x1c\n\x1aResetMissionControlRequest\"\x1d\n\x1bResetMissionContr\
    olResponse\"\x1c\n\x1aQueryMissionControlRequest\"Q\n\x1bQueryMissionCon\
    trolResponse\x12,\n\x05pairs\x18\x02\x20\x03(\x0b2\x16.routerrpc.PairHis\
    toryR\x05pairsJ\x04\x08\x01\x10\x02\"L\n\x1cXImportMissionControlRequest\
    \x12,\n\x05pairs\x18\x01\x20\x03(\x0b2\x16.routerrpc.PairHistoryR\x05pai\
    rs\"\x1f\n\x1dXImportMissionControlResponse\"\x8a\x01\n\x0bPairHistory\
    \x12\x1b\n\tnode_from\x18\x01\x20\x01(\x0cR\x08nodeFrom\x12\x17\n\x07nod\
    e_to\x18\x02\x20\x01(\x0cR\x06nodeTo\x12-\n\x07history\x18\x07\x20\x01(\
    \x0b2\x13.routerrpc.PairDataR\x07historyJ\x04\x08\x03\x10\x04J\x04\x08\
    \x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07\"\xe8\x01\n\x08Pa\
    irData\x12\x1b\n\tfail_time\x18\x01\x20\x01(\x03R\x08failTime\x12\x20\n\
    \x0cfail_amt_sat\x18\x02\x20\x01(\x03R\nfailAmtSat\x12\"\n\rfail_amt_msa\
    t\x18\x04\x20\x01(\x03R\x0bfailAmtMsat\x12!\n\x0csuccess_time\x18\x05\
    \x20\x01(\x03R\x0bsuccessTime\x12&\n\x0fsuccess_amt_sat\x18\x06\x20\x01(\
    \x03R\rsuccessAmtSat\x12(\n\x10success_amt_msat\x18\x07\x20\x01(\x03R\
    \x0esuccessAmtMsatJ\x04\x08\x03\x10\x04\"\x20\n\x1eGetMissionControlConf\
    igRequest\"Z\n\x1fGetMissionControlConfigResponse\x127\n\x06config\x18\
    \x01\x20\x01(\x0b2\x1f.routerrpc.MissionControlConfigR\x06config\"Y\n\
    \x1eSetMissionControlConfigRequest\x127\n\x06config\x18\x01\x20\x01(\x0b\
    2\x1f.routerrpc.MissionControlConfigR\x06config\"!\n\x1fSetMissionContro\
    lConfigResponse\"\x80\x02\n\x14MissionControlConfig\x12*\n\x11half_life_\
    seconds\x18\x01\x20\x01(\x04R\x0fhalfLifeSeconds\x12'\n\x0fhop_probabili\
    ty\x18\x02\x20\x01(\x02R\x0ehopProbability\x12\x16\n\x06weight\x18\x03\
    \x20\x01(\x02R\x06weight\x126\n\x17maximum_payment_results\x18\x04\x20\
    \x01(\rR\x15maximumPaymentResults\x12C\n\x1eminimum_failure_relax_interv\
    al\x18\x05\x20\x01(\x04R\x1bminimumFailureRelaxInterval\"j\n\x17QueryPro\
    babilityRequest\x12\x1b\n\tfrom_node\x18\x01\x20\x01(\x0cR\x08fromNode\
    \x12\x17\n\x07to_node\x18\x02\x20\x01(\x0cR\x06toNode\x12\x19\n\x08amt_m\
    sat\x18\x03\x20\x01(\x03R\x07amtMsat\"k\n\x18QueryProbabilityResponse\
    \x12\x20\n\x0bprobability\x18\x01\x20\x01(\x01R\x0bprobability\x12-\n\
    \x07history\x18\x02\x20\x01(\x0b2\x13.routerrpc.PairDataR\x07history\"\
    \xca\x01\n\x11BuildRouteRequest\x12\x19\n\x08amt_msat\x18\x01\x20\x01(\
    \x03R\x07amtMsat\x12(\n\x10final_cltv_delta\x18\x02\x20\x01(\x05R\x0efin\
    alCltvDelta\x12,\n\x10outgoing_chan_id\x18\x03\x20\x01(\x04R\x0eoutgoing\
    ChanIdB\x020\x01\x12\x1f\n\x0bhop_pubkeys\x18\x04\x20\x03(\x0cR\nhopPubk\
    eys\x12!\n\x0cpayment_addr\x18\x05\x20\x01(\x0cR\x0bpaymentAddr\"8\n\x12\
    BuildRouteResponse\x12\"\n\x05route\x18\x01\x20\x01(\x0b2\x0c.lnrpc.Rout\
    eR\x05route\"\x1c\n\x1aSubscribeHtlcEventsRequest\"\xf6\x04\n\tHtlcEvent\
    \x12.\n\x13incoming_channel_id\x18\x01\x20\x01(\x04R\x11incomingChannelI\
    d\x12.\n\x13outgoing_channel_id\x18\x02\x20\x01(\x04R\x11outgoingChannel\
    Id\x12(\n\x10incoming_htlc_id\x18\x03\x20\x01(\x04R\x0eincomingHtlcId\
    \x12(\n\x10outgoing_htlc_id\x18\x04\x20\x01(\x04R\x0eoutgoingHtlcId\x12!\
    \n\x0ctimestamp_ns\x18\x05\x20\x01(\x04R\x0btimestampNs\x12=\n\nevent_ty\
    pe\x18\x06\x20\x01(\x0e2\x1e.routerrpc.HtlcEvent.EventTypeR\teventType\
    \x12>\n\rforward_event\x18\x07\x20\x01(\x0b2\x17.routerrpc.ForwardEventH\
    \0R\x0cforwardEvent\x12K\n\x12forward_fail_event\x18\x08\x20\x01(\x0b2\
    \x1b.routerrpc.ForwardFailEventH\0R\x10forwardFailEvent\x12;\n\x0csettle\
    _event\x18\t\x20\x01(\x0b2\x16.routerrpc.SettleEventH\0R\x0bsettleEvent\
    \x12B\n\x0flink_fail_event\x18\n\x20\x01(\x0b2\x18.routerrpc.LinkFailEve\
    ntH\0R\rlinkFailEvent\"<\n\tEventType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\
    \n\x04SEND\x10\x01\x12\x0b\n\x07RECEIVE\x10\x02\x12\x0b\n\x07FORWARD\x10\
    \x03B\x07\n\x05event\"\xbc\x01\n\x08HtlcInfo\x12+\n\x11incoming_timelock\
    \x18\x01\x20\x01(\rR\x10incomingTimelock\x12+\n\x11outgoing_timelock\x18\
    \x02\x20\x01(\rR\x10outgoingTimelock\x12*\n\x11incoming_amt_msat\x18\x03\
    \x20\x01(\x04R\x0fincomingAmtMsat\x12*\n\x11outgoing_amt_msat\x18\x04\
    \x20\x01(\x04R\x0foutgoingAmtMsat\"7\n\x0cForwardEvent\x12'\n\x04info\
    \x18\x01\x20\x01(\x0b2\x13.routerrpc.HtlcInfoR\x04info\"\x12\n\x10Forwar\
    dFailEvent\")\n\x0bSettleEvent\x12\x1a\n\x08preimage\x18\x01\x20\x01(\
    \x0cR\x08preimage\"\xdf\x01\n\rLinkFailEvent\x12'\n\x04info\x18\x01\x20\
    \x01(\x0b2\x13.routerrpc.HtlcInfoR\x04info\x12=\n\x0cwire_failure\x18\
    \x02\x20\x01(\x0e2\x1a.lnrpc.Failure.FailureCodeR\x0bwireFailure\x12?\n\
    \x0efailure_detail\x18\x03\x20\x01(\x0e2\x18.routerrpc.FailureDetailR\rf\
    ailureDetail\x12%\n\x0efailure_string\x18\x04\x20\x01(\tR\rfailureString\
    \"\x8a\x01\n\rPaymentStatus\x12-\n\x05state\x18\x01\x20\x01(\x0e2\x17.ro\
    uterrpc.PaymentStateR\x05state\x12\x1a\n\x08preimage\x18\x02\x20\x01(\
    \x0cR\x08preimage\x12(\n\x05htlcs\x18\x04\x20\x03(\x0b2\x12.lnrpc.HTLCAt\
    temptR\x05htlcsJ\x04\x08\x03\x10\x04\">\n\nCircuitKey\x12\x17\n\x07chan_\
    id\x18\x01\x20\x01(\x04R\x06chanId\x12\x17\n\x07htlc_id\x18\x02\x20\x01(\
    \x04R\x06htlcId\"\xbf\x04\n\x1bForwardHtlcInterceptRequest\x12G\n\x14inc\
    oming_circuit_key\x18\x01\x20\x01(\x0b2\x15.routerrpc.CircuitKeyR\x12inc\
    omingCircuitKey\x120\n\x14incoming_amount_msat\x18\x05\x20\x01(\x04R\x12\
    incomingAmountMsat\x12'\n\x0fincoming_expiry\x18\x06\x20\x01(\rR\x0einco\
    mingExpiry\x12!\n\x0cpayment_hash\x18\x02\x20\x01(\x0cR\x0bpaymentHash\
    \x12;\n\x1aoutgoing_requested_chan_id\x18\x07\x20\x01(\x04R\x17outgoingR\
    equestedChanId\x120\n\x14outgoing_amount_msat\x18\x03\x20\x01(\x04R\x12o\
    utgoingAmountMsat\x12'\n\x0foutgoing_expiry\x18\x04\x20\x01(\rR\x0eoutgo\
    ingExpiry\x12`\n\x0ecustom_records\x18\x08\x20\x03(\x0b29.routerrpc.Forw\
    ardHtlcInterceptRequest.CustomRecordsEntryR\rcustomRecords\x12\x1d\n\non\
    ion_blob\x18\t\x20\x01(\x0cR\tonionBlob\x1a@\n\x12CustomRecordsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x0cR\x05value:\x028\x01\"\xc0\x01\n\x1cForwardHtlcInterceptRes\
    ponse\x12G\n\x14incoming_circuit_key\x18\x01\x20\x01(\x0b2\x15.routerrpc\
    .CircuitKeyR\x12incomingCircuitKey\x12;\n\x06action\x18\x02\x20\x01(\x0e\
    2#.routerrpc.ResolveHoldForwardActionR\x06action\x12\x1a\n\x08preimage\
    \x18\x03\x20\x01(\x0cR\x08preimage\"\x82\x01\n\x17UpdateChanStatusReques\
    t\x122\n\nchan_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tchan\
    Point\x123\n\x06action\x18\x02\x20\x01(\x0e2\x1b.routerrpc.ChanStatusAct\
    ionR\x06action\"\x1a\n\x18UpdateChanStatusResponse*\x81\x04\n\rFailureDe\
    tail\x12\x0b\n\x07UNKNOWN\x10\0\x12\r\n\tNO_DETAIL\x10\x01\x12\x10\n\x0c\
    ONION_DECODE\x10\x02\x12\x15\n\x11LINK_NOT_ELIGIBLE\x10\x03\x12\x14\n\
    \x10ON_CHAIN_TIMEOUT\x10\x04\x12\x14\n\x10HTLC_EXCEEDS_MAX\x10\x05\x12\
    \x18\n\x14INSUFFICIENT_BALANCE\x10\x06\x12\x16\n\x12INCOMPLETE_FORWARD\
    \x10\x07\x12\x13\n\x0fHTLC_ADD_FAILED\x10\x08\x12\x15\n\x11FORWARDS_DISA\
    BLED\x10\t\x12\x14\n\x10INVOICE_CANCELED\x10\n\x12\x15\n\x11INVOICE_UNDE\
    RPAID\x10\x0b\x12\x1b\n\x17INVOICE_EXPIRY_TOO_SOON\x10\x0c\x12\x14\n\x10\
    INVOICE_NOT_OPEN\x10\r\x12\x17\n\x13MPP_INVOICE_TIMEOUT\x10\x0e\x12\x14\
    \n\x10ADDRESS_MISMATCH\x10\x0f\x12\x16\n\x12SET_TOTAL_MISMATCH\x10\x10\
    \x12\x15\n\x11SET_TOTAL_TOO_LOW\x10\x11\x12\x10\n\x0cSET_OVERPAID\x10\
    \x12\x12\x13\n\x0fUNKNOWN_INVOICE\x10\x13\x12\x13\n\x0fINVALID_KEYSEND\
    \x10\x14\x12\x13\n\x0fMPP_IN_PROGRESS\x10\x15\x12\x12\n\x0eCIRCULAR_ROUT\
    E\x10\x16*\xae\x01\n\x0cPaymentState\x12\r\n\tIN_FLIGHT\x10\0\x12\r\n\tS\
    UCCEEDED\x10\x01\x12\x12\n\x0eFAILED_TIMEOUT\x10\x02\x12\x13\n\x0fFAILED\
    _NO_ROUTE\x10\x03\x12\x10\n\x0cFAILED_ERROR\x10\x04\x12$\n\x20FAILED_INC\
    ORRECT_PAYMENT_DETAILS\x10\x05\x12\x1f\n\x1bFAILED_INSUFFICIENT_BALANCE\
    \x10\x06*<\n\x18ResolveHoldForwardAction\x12\n\n\x06SETTLE\x10\0\x12\x08\
    \n\x04FAIL\x10\x01\x12\n\n\x06RESUME\x10\x02*5\n\x10ChanStatusAction\x12\
    \n\n\x06ENABLE\x10\0\x12\x0b\n\x07DISABLE\x10\x01\x12\x08\n\x04AUTO\x10\
    \x022\xf1\x0b\n\x06Router\x12@\n\rSendPaymentV2\x12\x1d.routerrpc.SendPa\
    ymentRequest\x1a\x0e.lnrpc.Payment0\x01\x12B\n\x0eTrackPaymentV2\x12\x1e\
    .routerrpc.TrackPaymentRequest\x1a\x0e.lnrpc.Payment0\x01\x12K\n\x10Esti\
    mateRouteFee\x12\x1a.routerrpc.RouteFeeRequest\x1a\x1b.routerrpc.RouteFe\
    eResponse\x12Q\n\x0bSendToRoute\x12\x1d.routerrpc.SendToRouteRequest\x1a\
    \x1e.routerrpc.SendToRouteResponse\"\x03\x88\x02\x01\x12B\n\rSendToRoute\
    V2\x12\x1d.routerrpc.SendToRouteRequest\x1a\x12.lnrpc.HTLCAttempt\x12d\n\
    \x13ResetMissionControl\x12%.routerrpc.ResetMissionControlRequest\x1a&.r\
    outerrpc.ResetMissionControlResponse\x12d\n\x13QueryMissionControl\x12%.\
    routerrpc.QueryMissionControlRequest\x1a&.routerrpc.QueryMissionControlR\
    esponse\x12j\n\x15XImportMissionControl\x12'.routerrpc.XImportMissionCon\
    trolRequest\x1a(.routerrpc.XImportMissionControlResponse\x12p\n\x17GetMi\
    ssionControlConfig\x12).routerrpc.GetMissionControlConfigRequest\x1a*.ro\
    uterrpc.GetMissionControlConfigResponse\x12p\n\x17SetMissionControlConfi\
    g\x12).routerrpc.SetMissionControlConfigRequest\x1a*.routerrpc.SetMissio\
    nControlConfigResponse\x12[\n\x10QueryProbability\x12\".routerrpc.QueryP\
    robabilityRequest\x1a#.routerrpc.QueryProbabilityResponse\x12I\n\nBuildR\
    oute\x12\x1c.routerrpc.BuildRouteRequest\x1a\x1d.routerrpc.BuildRouteRes\
    ponse\x12T\n\x13SubscribeHtlcEvents\x12%.routerrpc.SubscribeHtlcEventsRe\
    quest\x1a\x14.routerrpc.HtlcEvent0\x01\x12M\n\x0bSendPayment\x12\x1d.rou\
    terrpc.SendPaymentRequest\x1a\x18.routerrpc.PaymentStatus\"\x03\x88\x02\
    \x010\x01\x12O\n\x0cTrackPayment\x12\x1e.routerrpc.TrackPaymentRequest\
    \x1a\x18.routerrpc.PaymentStatus\"\x03\x88\x02\x010\x01\x12f\n\x0fHtlcIn\
    terceptor\x12'.routerrpc.ForwardHtlcInterceptResponse\x1a&.routerrpc.For\
    wardHtlcInterceptRequest(\x010\x01\x12[\n\x10UpdateChanStatus\x12\".rout\
    errpc.UpdateChanStatusRequest\x1a#.routerrpc.UpdateChanStatusResponseB1Z\
    /github.com/lightningnetwork/lnd/lnrpc/routerrpcb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
