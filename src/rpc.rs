// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Utxo {
    // message fields
    pub address_type: AddressType,
    pub address: ::std::string::String,
    pub amount_sat: i64,
    pub pk_script: ::std::string::String,
    pub outpoint: ::protobuf::SingularPtrField<OutPoint>,
    pub confirmations: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Utxo {
    fn default() -> &'a Utxo {
        <Utxo as ::protobuf::Message>::default_instance()
    }
}

impl Utxo {
    pub fn new() -> Utxo {
        ::std::default::Default::default()
    }

    // .lnrpc.AddressType address_type = 1;


    pub fn get_address_type(&self) -> AddressType {
        self.address_type
    }
    pub fn clear_address_type(&mut self) {
        self.address_type = AddressType::WITNESS_PUBKEY_HASH;
    }

    // Param is passed by value, moved
    pub fn set_address_type(&mut self, v: AddressType) {
        self.address_type = v;
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 amount_sat = 3;


    pub fn get_amount_sat(&self) -> i64 {
        self.amount_sat
    }
    pub fn clear_amount_sat(&mut self) {
        self.amount_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount_sat(&mut self, v: i64) {
        self.amount_sat = v;
    }

    // string pk_script = 4;


    pub fn get_pk_script(&self) -> &str {
        &self.pk_script
    }
    pub fn clear_pk_script(&mut self) {
        self.pk_script.clear();
    }

    // Param is passed by value, moved
    pub fn set_pk_script(&mut self, v: ::std::string::String) {
        self.pk_script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pk_script(&mut self) -> &mut ::std::string::String {
        &mut self.pk_script
    }

    // Take field
    pub fn take_pk_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pk_script, ::std::string::String::new())
    }

    // .lnrpc.OutPoint outpoint = 5;


    pub fn get_outpoint(&self) -> &OutPoint {
        self.outpoint.as_ref().unwrap_or_else(|| <OutPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    pub fn has_outpoint(&self) -> bool {
        self.outpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: OutPoint) {
        self.outpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut OutPoint {
        if self.outpoint.is_none() {
            self.outpoint.set_default();
        }
        self.outpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_outpoint(&mut self) -> OutPoint {
        self.outpoint.take().unwrap_or_else(|| OutPoint::new())
    }

    // int64 confirmations = 6;


    pub fn get_confirmations(&self) -> i64 {
        self.confirmations
    }
    pub fn clear_confirmations(&mut self) {
        self.confirmations = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmations(&mut self, v: i64) {
        self.confirmations = v;
    }
}

impl ::protobuf::Message for Utxo {
    fn is_initialized(&self) -> bool {
        for v in &self.outpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.address_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount_sat = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pk_script)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outpoint)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.confirmations = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address_type != AddressType::WITNESS_PUBKEY_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.address_type);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if self.amount_sat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pk_script.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pk_script);
        }
        if let Some(ref v) = self.outpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confirmations != 0 {
            my_size += ::protobuf::rt::value_size(6, self.confirmations, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.address_type != AddressType::WITNESS_PUBKEY_HASH {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.address_type))?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if self.amount_sat != 0 {
            os.write_int64(3, self.amount_sat)?;
        }
        if !self.pk_script.is_empty() {
            os.write_string(4, &self.pk_script)?;
        }
        if let Some(ref v) = self.outpoint.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confirmations != 0 {
            os.write_int64(6, self.confirmations)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Utxo {
        Utxo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressType>>(
                "address_type",
                |m: &Utxo| { &m.address_type },
                |m: &mut Utxo| { &mut m.address_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Utxo| { &m.address },
                |m: &mut Utxo| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount_sat",
                |m: &Utxo| { &m.amount_sat },
                |m: &mut Utxo| { &mut m.amount_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pk_script",
                |m: &Utxo| { &m.pk_script },
                |m: &mut Utxo| { &mut m.pk_script },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutPoint>>(
                "outpoint",
                |m: &Utxo| { &m.outpoint },
                |m: &mut Utxo| { &mut m.outpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "confirmations",
                |m: &Utxo| { &m.confirmations },
                |m: &mut Utxo| { &mut m.confirmations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Utxo>(
                "Utxo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Utxo {
        static instance: ::protobuf::rt::LazyV2<Utxo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Utxo::new)
    }
}

impl ::protobuf::Clear for Utxo {
    fn clear(&mut self) {
        self.address_type = AddressType::WITNESS_PUBKEY_HASH;
        self.address.clear();
        self.amount_sat = 0;
        self.pk_script.clear();
        self.outpoint.clear();
        self.confirmations = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Utxo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Utxo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Transaction {
    // message fields
    pub tx_hash: ::std::string::String,
    pub amount: i64,
    pub num_confirmations: i32,
    pub block_hash: ::std::string::String,
    pub block_height: i32,
    pub time_stamp: i64,
    pub total_fees: i64,
    pub dest_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub raw_tx_hex: ::std::string::String,
    pub label: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // string tx_hash = 1;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // int32 num_confirmations = 3;


    pub fn get_num_confirmations(&self) -> i32 {
        self.num_confirmations
    }
    pub fn clear_num_confirmations(&mut self) {
        self.num_confirmations = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confirmations(&mut self, v: i32) {
        self.num_confirmations = v;
    }

    // string block_hash = 4;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // int32 block_height = 5;


    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    // int64 time_stamp = 6;


    pub fn get_time_stamp(&self) -> i64 {
        self.time_stamp
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: i64) {
        self.time_stamp = v;
    }

    // int64 total_fees = 7;


    pub fn get_total_fees(&self) -> i64 {
        self.total_fees
    }
    pub fn clear_total_fees(&mut self) {
        self.total_fees = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees(&mut self, v: i64) {
        self.total_fees = v;
    }

    // repeated string dest_addresses = 8;


    pub fn get_dest_addresses(&self) -> &[::std::string::String] {
        &self.dest_addresses
    }
    pub fn clear_dest_addresses(&mut self) {
        self.dest_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dest_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dest_addresses
    }

    // Take field
    pub fn take_dest_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dest_addresses, ::protobuf::RepeatedField::new())
    }

    // string raw_tx_hex = 9;


    pub fn get_raw_tx_hex(&self) -> &str {
        &self.raw_tx_hex
    }
    pub fn clear_raw_tx_hex(&mut self) {
        self.raw_tx_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_tx_hex(&mut self, v: ::std::string::String) {
        self.raw_tx_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_tx_hex(&mut self) -> &mut ::std::string::String {
        &mut self.raw_tx_hex
    }

    // Take field
    pub fn take_raw_tx_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.raw_tx_hex, ::std::string::String::new())
    }

    // string label = 10;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_confirmations = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_stamp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dest_addresses)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.raw_tx_hex)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_hash);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confirmations != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confirmations, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_stamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.time_stamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_fees != 0 {
            my_size += ::protobuf::rt::value_size(7, self.total_fees, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dest_addresses {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.raw_tx_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.raw_tx_hex);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_hash.is_empty() {
            os.write_string(1, &self.tx_hash)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.num_confirmations != 0 {
            os.write_int32(3, self.num_confirmations)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if self.block_height != 0 {
            os.write_int32(5, self.block_height)?;
        }
        if self.time_stamp != 0 {
            os.write_int64(6, self.time_stamp)?;
        }
        if self.total_fees != 0 {
            os.write_int64(7, self.total_fees)?;
        }
        for v in &self.dest_addresses {
            os.write_string(8, &v)?;
        };
        if !self.raw_tx_hex.is_empty() {
            os.write_string(9, &self.raw_tx_hex)?;
        }
        if !self.label.is_empty() {
            os.write_string(10, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tx_hash",
                |m: &Transaction| { &m.tx_hash },
                |m: &mut Transaction| { &mut m.tx_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &Transaction| { &m.amount },
                |m: &mut Transaction| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_confirmations",
                |m: &Transaction| { &m.num_confirmations },
                |m: &mut Transaction| { &mut m.num_confirmations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "block_hash",
                |m: &Transaction| { &m.block_hash },
                |m: &mut Transaction| { &mut m.block_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_height",
                |m: &Transaction| { &m.block_height },
                |m: &mut Transaction| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "time_stamp",
                |m: &Transaction| { &m.time_stamp },
                |m: &mut Transaction| { &mut m.time_stamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_fees",
                |m: &Transaction| { &m.total_fees },
                |m: &mut Transaction| { &mut m.total_fees },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dest_addresses",
                |m: &Transaction| { &m.dest_addresses },
                |m: &mut Transaction| { &mut m.dest_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "raw_tx_hex",
                |m: &Transaction| { &m.raw_tx_hex },
                |m: &mut Transaction| { &mut m.raw_tx_hex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &Transaction| { &m.label },
                |m: &mut Transaction| { &mut m.label },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                "Transaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction {
        static instance: ::protobuf::rt::LazyV2<Transaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction::new)
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.tx_hash.clear();
        self.amount = 0;
        self.num_confirmations = 0;
        self.block_hash.clear();
        self.block_height = 0;
        self.time_stamp = 0;
        self.total_fees = 0;
        self.dest_addresses.clear();
        self.raw_tx_hex.clear();
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetTransactionsRequest {
    // message fields
    pub start_height: i32,
    pub end_height: i32,
    pub account: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTransactionsRequest {
    fn default() -> &'a GetTransactionsRequest {
        <GetTransactionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionsRequest {
    pub fn new() -> GetTransactionsRequest {
        ::std::default::Default::default()
    }

    // int32 start_height = 1;


    pub fn get_start_height(&self) -> i32 {
        self.start_height
    }
    pub fn clear_start_height(&mut self) {
        self.start_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_height(&mut self, v: i32) {
        self.start_height = v;
    }

    // int32 end_height = 2;


    pub fn get_end_height(&self) -> i32 {
        self.end_height
    }
    pub fn clear_end_height(&mut self) {
        self.end_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_height(&mut self, v: i32) {
        self.end_height = v;
    }

    // string account = 3;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTransactionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_height = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_height = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_height != 0 {
            os.write_int32(1, self.start_height)?;
        }
        if self.end_height != 0 {
            os.write_int32(2, self.end_height)?;
        }
        if !self.account.is_empty() {
            os.write_string(3, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionsRequest {
        GetTransactionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start_height",
                |m: &GetTransactionsRequest| { &m.start_height },
                |m: &mut GetTransactionsRequest| { &mut m.start_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end_height",
                |m: &GetTransactionsRequest| { &m.end_height },
                |m: &mut GetTransactionsRequest| { &mut m.end_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account",
                |m: &GetTransactionsRequest| { &m.account },
                |m: &mut GetTransactionsRequest| { &mut m.account },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTransactionsRequest>(
                "GetTransactionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTransactionsRequest {
        static instance: ::protobuf::rt::LazyV2<GetTransactionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTransactionsRequest::new)
    }
}

impl ::protobuf::Clear for GetTransactionsRequest {
    fn clear(&mut self) {
        self.start_height = 0;
        self.end_height = 0;
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TransactionDetails {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionDetails {
    fn default() -> &'a TransactionDetails {
        <TransactionDetails as ::protobuf::Message>::default_instance()
    }
}

impl TransactionDetails {
    pub fn new() -> TransactionDetails {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Transaction transactions = 1;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionDetails {
        TransactionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transactions",
                |m: &TransactionDetails| { &m.transactions },
                |m: &mut TransactionDetails| { &mut m.transactions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionDetails>(
                "TransactionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionDetails {
        static instance: ::protobuf::rt::LazyV2<TransactionDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionDetails::new)
    }
}

impl ::protobuf::Clear for TransactionDetails {
    fn clear(&mut self) {
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FeeLimit {
    // message oneof groups
    pub limit: ::std::option::Option<FeeLimit_oneof_limit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeLimit {
    fn default() -> &'a FeeLimit {
        <FeeLimit as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FeeLimit_oneof_limit {
    fixed(i64),
    fixed_msat(i64),
    percent(i64),
}

impl FeeLimit {
    pub fn new() -> FeeLimit {
        ::std::default::Default::default()
    }

    // int64 fixed = 1;


    pub fn get_fixed(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_fixed(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_fixed(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(v))
    }

    // int64 fixed_msat = 3;


    pub fn get_fixed_msat(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed_msat(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_fixed_msat(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_fixed_msat(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed_msat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed_msat(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed_msat(v))
    }

    // int64 percent = 2;


    pub fn get_percent(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::percent(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_percent(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_percent(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::percent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::percent(v))
    }
}

impl ::protobuf::Message for FeeLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(is.read_int64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed_msat(is.read_int64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::percent(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.limit {
            match v {
                &FeeLimit_oneof_limit::fixed(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeeLimit_oneof_limit::fixed_msat(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeeLimit_oneof_limit::percent(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.limit {
            match v {
                &FeeLimit_oneof_limit::fixed(v) => {
                    os.write_int64(1, v)?;
                },
                &FeeLimit_oneof_limit::fixed_msat(v) => {
                    os.write_int64(3, v)?;
                },
                &FeeLimit_oneof_limit::percent(v) => {
                    os.write_int64(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeLimit {
        FeeLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "fixed",
                FeeLimit::has_fixed,
                FeeLimit::get_fixed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "fixed_msat",
                FeeLimit::has_fixed_msat,
                FeeLimit::get_fixed_msat,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "percent",
                FeeLimit::has_percent,
                FeeLimit::get_percent,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeeLimit>(
                "FeeLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeeLimit {
        static instance: ::protobuf::rt::LazyV2<FeeLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeLimit::new)
    }
}

impl ::protobuf::Clear for FeeLimit {
    fn clear(&mut self) {
        self.limit = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendRequest {
    // message fields
    pub dest: ::std::vec::Vec<u8>,
    pub dest_string: ::std::string::String,
    pub amt: i64,
    pub amt_msat: i64,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub payment_request: ::std::string::String,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<FeeLimit>,
    pub outgoing_chan_id: u64,
    pub last_hop_pubkey: ::std::vec::Vec<u8>,
    pub cltv_limit: u32,
    pub dest_custom_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    pub allow_self_payment: bool,
    pub dest_features: ::std::vec::Vec<FeatureBit>,
    pub payment_addr: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendRequest {
    fn default() -> &'a SendRequest {
        <SendRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendRequest {
    pub fn new() -> SendRequest {
        ::std::default::Default::default()
    }

    // bytes dest = 1;


    pub fn get_dest(&self) -> &[u8] {
        &self.dest
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dest
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dest, ::std::vec::Vec::new())
    }

    // string dest_string = 2;


    pub fn get_dest_string(&self) -> &str {
        &self.dest_string
    }
    pub fn clear_dest_string(&mut self) {
        self.dest_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_string(&mut self, v: ::std::string::String) {
        self.dest_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_string(&mut self) -> &mut ::std::string::String {
        &mut self.dest_string
    }

    // Take field
    pub fn take_dest_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dest_string, ::std::string::String::new())
    }

    // int64 amt = 3;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int64 amt_msat = 12;


    pub fn get_amt_msat(&self) -> i64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: i64) {
        self.amt_msat = v;
    }

    // bytes payment_hash = 4;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // string payment_hash_string = 5;


    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }
    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    // string payment_request = 6;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // int32 final_cltv_delta = 7;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // .lnrpc.FeeLimit fee_limit = 8;


    pub fn get_fee_limit(&self) -> &FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| <FeeLimit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| FeeLimit::new())
    }

    // uint64 outgoing_chan_id = 9;


    pub fn get_outgoing_chan_id(&self) -> u64 {
        self.outgoing_chan_id
    }
    pub fn clear_outgoing_chan_id(&mut self) {
        self.outgoing_chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_id(&mut self, v: u64) {
        self.outgoing_chan_id = v;
    }

    // bytes last_hop_pubkey = 13;


    pub fn get_last_hop_pubkey(&self) -> &[u8] {
        &self.last_hop_pubkey
    }
    pub fn clear_last_hop_pubkey(&mut self) {
        self.last_hop_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_hop_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_hop_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_hop_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.last_hop_pubkey
    }

    // Take field
    pub fn take_last_hop_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.last_hop_pubkey, ::std::vec::Vec::new())
    }

    // uint32 cltv_limit = 10;


    pub fn get_cltv_limit(&self) -> u32 {
        self.cltv_limit
    }
    pub fn clear_cltv_limit(&mut self) {
        self.cltv_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_limit(&mut self, v: u32) {
        self.cltv_limit = v;
    }

    // repeated .lnrpc.SendRequest.DestCustomRecordsEntry dest_custom_records = 11;


    pub fn get_dest_custom_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.dest_custom_records
    }
    pub fn clear_dest_custom_records(&mut self) {
        self.dest_custom_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_custom_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.dest_custom_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_custom_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.dest_custom_records
    }

    // Take field
    pub fn take_dest_custom_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.dest_custom_records, ::std::collections::HashMap::new())
    }

    // bool allow_self_payment = 14;


    pub fn get_allow_self_payment(&self) -> bool {
        self.allow_self_payment
    }
    pub fn clear_allow_self_payment(&mut self) {
        self.allow_self_payment = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_self_payment(&mut self, v: bool) {
        self.allow_self_payment = v;
    }

    // repeated .lnrpc.FeatureBit dest_features = 15;


    pub fn get_dest_features(&self) -> &[FeatureBit] {
        &self.dest_features
    }
    pub fn clear_dest_features(&mut self) {
        self.dest_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_features(&mut self, v: ::std::vec::Vec<FeatureBit>) {
        self.dest_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_features(&mut self) -> &mut ::std::vec::Vec<FeatureBit> {
        &mut self.dest_features
    }

    // Take field
    pub fn take_dest_features(&mut self) -> ::std::vec::Vec<FeatureBit> {
        ::std::mem::replace(&mut self.dest_features, ::std::vec::Vec::new())
    }

    // bytes payment_addr = 16;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SendRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dest_string)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_msat = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_chan_id = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.last_hop_pubkey)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_limit = tmp;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.dest_custom_records)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_self_payment = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.dest_features, 15, &mut self.unknown_fields)?
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.dest);
        }
        if !self.dest_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dest_string);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(12, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payment_hash_string);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_request);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(7, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.outgoing_chan_id != 0 {
            my_size += ::protobuf::rt::value_size(9, self.outgoing_chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.last_hop_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.last_hop_pubkey);
        }
        if self.cltv_limit != 0 {
            my_size += ::protobuf::rt::value_size(10, self.cltv_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_custom_records);
        if self.allow_self_payment != false {
            my_size += 2;
        }
        for value in &self.dest_features {
            my_size += ::protobuf::rt::enum_size(15, *value);
        };
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.payment_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dest.is_empty() {
            os.write_bytes(1, &self.dest)?;
        }
        if !self.dest_string.is_empty() {
            os.write_string(2, &self.dest_string)?;
        }
        if self.amt != 0 {
            os.write_int64(3, self.amt)?;
        }
        if self.amt_msat != 0 {
            os.write_int64(12, self.amt_msat)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(4, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(5, &self.payment_hash_string)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(6, &self.payment_request)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(7, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.outgoing_chan_id != 0 {
            os.write_uint64(9, self.outgoing_chan_id)?;
        }
        if !self.last_hop_pubkey.is_empty() {
            os.write_bytes(13, &self.last_hop_pubkey)?;
        }
        if self.cltv_limit != 0 {
            os.write_uint32(10, self.cltv_limit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_custom_records, os)?;
        if self.allow_self_payment != false {
            os.write_bool(14, self.allow_self_payment)?;
        }
        for v in &self.dest_features {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(v))?;
        };
        if !self.payment_addr.is_empty() {
            os.write_bytes(16, &self.payment_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendRequest {
        SendRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dest",
                |m: &SendRequest| { &m.dest },
                |m: &mut SendRequest| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dest_string",
                |m: &SendRequest| { &m.dest_string },
                |m: &mut SendRequest| { &mut m.dest_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &SendRequest| { &m.amt },
                |m: &mut SendRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_msat",
                |m: &SendRequest| { &m.amt_msat },
                |m: &mut SendRequest| { &mut m.amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &SendRequest| { &m.payment_hash },
                |m: &mut SendRequest| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_hash_string",
                |m: &SendRequest| { &m.payment_hash_string },
                |m: &mut SendRequest| { &mut m.payment_hash_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_request",
                |m: &SendRequest| { &m.payment_request },
                |m: &mut SendRequest| { &mut m.payment_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "final_cltv_delta",
                |m: &SendRequest| { &m.final_cltv_delta },
                |m: &mut SendRequest| { &mut m.final_cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeLimit>>(
                "fee_limit",
                |m: &SendRequest| { &m.fee_limit },
                |m: &mut SendRequest| { &mut m.fee_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_chan_id",
                |m: &SendRequest| { &m.outgoing_chan_id },
                |m: &mut SendRequest| { &mut m.outgoing_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "last_hop_pubkey",
                |m: &SendRequest| { &m.last_hop_pubkey },
                |m: &mut SendRequest| { &mut m.last_hop_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cltv_limit",
                |m: &SendRequest| { &m.cltv_limit },
                |m: &mut SendRequest| { &mut m.cltv_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                "dest_custom_records",
                |m: &SendRequest| { &m.dest_custom_records },
                |m: &mut SendRequest| { &mut m.dest_custom_records },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_self_payment",
                |m: &SendRequest| { &m.allow_self_payment },
                |m: &mut SendRequest| { &mut m.allow_self_payment },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FeatureBit>>(
                "dest_features",
                |m: &SendRequest| { &m.dest_features },
                |m: &mut SendRequest| { &mut m.dest_features },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &SendRequest| { &m.payment_addr },
                |m: &mut SendRequest| { &mut m.payment_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendRequest>(
                "SendRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendRequest {
        static instance: ::protobuf::rt::LazyV2<SendRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendRequest::new)
    }
}

impl ::protobuf::Clear for SendRequest {
    fn clear(&mut self) {
        self.dest.clear();
        self.dest_string.clear();
        self.amt = 0;
        self.amt_msat = 0;
        self.payment_hash.clear();
        self.payment_hash_string.clear();
        self.payment_request.clear();
        self.final_cltv_delta = 0;
        self.fee_limit.clear();
        self.outgoing_chan_id = 0;
        self.last_hop_pubkey.clear();
        self.cltv_limit = 0;
        self.dest_custom_records.clear();
        self.allow_self_payment = false;
        self.dest_features.clear();
        self.payment_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendResponse {
    // message fields
    pub payment_error: ::std::string::String,
    pub payment_preimage: ::std::vec::Vec<u8>,
    pub payment_route: ::protobuf::SingularPtrField<Route>,
    pub payment_hash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendResponse {
    fn default() -> &'a SendResponse {
        <SendResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendResponse {
    pub fn new() -> SendResponse {
        ::std::default::Default::default()
    }

    // string payment_error = 1;


    pub fn get_payment_error(&self) -> &str {
        &self.payment_error
    }
    pub fn clear_payment_error(&mut self) {
        self.payment_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_error(&mut self, v: ::std::string::String) {
        self.payment_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_error(&mut self) -> &mut ::std::string::String {
        &mut self.payment_error
    }

    // Take field
    pub fn take_payment_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_error, ::std::string::String::new())
    }

    // bytes payment_preimage = 2;


    pub fn get_payment_preimage(&self) -> &[u8] {
        &self.payment_preimage
    }
    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_preimage, ::std::vec::Vec::new())
    }

    // .lnrpc.Route payment_route = 3;


    pub fn get_payment_route(&self) -> &Route {
        self.payment_route.as_ref().unwrap_or_else(|| <Route as ::protobuf::Message>::default_instance())
    }
    pub fn clear_payment_route(&mut self) {
        self.payment_route.clear();
    }

    pub fn has_payment_route(&self) -> bool {
        self.payment_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_route(&mut self, v: Route) {
        self.payment_route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_route(&mut self) -> &mut Route {
        if self.payment_route.is_none() {
            self.payment_route.set_default();
        }
        self.payment_route.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_route(&mut self) -> Route {
        self.payment_route.take().unwrap_or_else(|| Route::new())
    }

    // bytes payment_hash = 4;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SendResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_preimage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payment_route)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_error);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payment_preimage);
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_error.is_empty() {
            os.write_string(1, &self.payment_error)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_bytes(2, &self.payment_preimage)?;
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(4, &self.payment_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendResponse {
        SendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_error",
                |m: &SendResponse| { &m.payment_error },
                |m: &mut SendResponse| { &mut m.payment_error },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_preimage",
                |m: &SendResponse| { &m.payment_preimage },
                |m: &mut SendResponse| { &mut m.payment_preimage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                "payment_route",
                |m: &SendResponse| { &m.payment_route },
                |m: &mut SendResponse| { &mut m.payment_route },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &SendResponse| { &m.payment_hash },
                |m: &mut SendResponse| { &mut m.payment_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendResponse>(
                "SendResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendResponse {
        static instance: ::protobuf::rt::LazyV2<SendResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendResponse::new)
    }
}

impl ::protobuf::Clear for SendResponse {
    fn clear(&mut self) {
        self.payment_error.clear();
        self.payment_preimage.clear();
        self.payment_route.clear();
        self.payment_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendToRouteRequest {
    // message fields
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub route: ::protobuf::SingularPtrField<Route>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToRouteRequest {
    fn default() -> &'a SendToRouteRequest {
        <SendToRouteRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendToRouteRequest {
    pub fn new() -> SendToRouteRequest {
        ::std::default::Default::default()
    }

    // bytes payment_hash = 1;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // string payment_hash_string = 2;


    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }
    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    // .lnrpc.Route route = 4;


    pub fn get_route(&self) -> &Route {
        self.route.as_ref().unwrap_or_else(|| <Route as ::protobuf::Message>::default_instance())
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: Route) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut Route {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> Route {
        self.route.take().unwrap_or_else(|| Route::new())
    }
}

impl ::protobuf::Message for SendToRouteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash_string);
        }
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_bytes(1, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(2, &self.payment_hash_string)?;
        }
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToRouteRequest {
        SendToRouteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_hash",
                |m: &SendToRouteRequest| { &m.payment_hash },
                |m: &mut SendToRouteRequest| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_hash_string",
                |m: &SendToRouteRequest| { &m.payment_hash_string },
                |m: &mut SendToRouteRequest| { &mut m.payment_hash_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                "route",
                |m: &SendToRouteRequest| { &m.route },
                |m: &mut SendToRouteRequest| { &mut m.route },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendToRouteRequest>(
                "SendToRouteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendToRouteRequest {
        static instance: ::protobuf::rt::LazyV2<SendToRouteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendToRouteRequest::new)
    }
}

impl ::protobuf::Clear for SendToRouteRequest {
    fn clear(&mut self) {
        self.payment_hash.clear();
        self.payment_hash_string.clear();
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToRouteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToRouteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelAcceptRequest {
    // message fields
    pub node_pubkey: ::std::vec::Vec<u8>,
    pub chain_hash: ::std::vec::Vec<u8>,
    pub pending_chan_id: ::std::vec::Vec<u8>,
    pub funding_amt: u64,
    pub push_amt: u64,
    pub dust_limit: u64,
    pub max_value_in_flight: u64,
    pub channel_reserve: u64,
    pub min_htlc: u64,
    pub fee_per_kw: u64,
    pub csv_delay: u32,
    pub max_accepted_htlcs: u32,
    pub channel_flags: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelAcceptRequest {
    fn default() -> &'a ChannelAcceptRequest {
        <ChannelAcceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelAcceptRequest {
    pub fn new() -> ChannelAcceptRequest {
        ::std::default::Default::default()
    }

    // bytes node_pubkey = 1;


    pub fn get_node_pubkey(&self) -> &[u8] {
        &self.node_pubkey
    }
    pub fn clear_node_pubkey(&mut self) {
        self.node_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_pubkey
    }

    // Take field
    pub fn take_node_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_pubkey, ::std::vec::Vec::new())
    }

    // bytes chain_hash = 2;


    pub fn get_chain_hash(&self) -> &[u8] {
        &self.chain_hash
    }
    pub fn clear_chain_hash(&mut self) {
        self.chain_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.chain_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.chain_hash
    }

    // Take field
    pub fn take_chain_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.chain_hash, ::std::vec::Vec::new())
    }

    // bytes pending_chan_id = 3;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }

    // uint64 funding_amt = 4;


    pub fn get_funding_amt(&self) -> u64 {
        self.funding_amt
    }
    pub fn clear_funding_amt(&mut self) {
        self.funding_amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_funding_amt(&mut self, v: u64) {
        self.funding_amt = v;
    }

    // uint64 push_amt = 5;


    pub fn get_push_amt(&self) -> u64 {
        self.push_amt
    }
    pub fn clear_push_amt(&mut self) {
        self.push_amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_push_amt(&mut self, v: u64) {
        self.push_amt = v;
    }

    // uint64 dust_limit = 6;


    pub fn get_dust_limit(&self) -> u64 {
        self.dust_limit
    }
    pub fn clear_dust_limit(&mut self) {
        self.dust_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_dust_limit(&mut self, v: u64) {
        self.dust_limit = v;
    }

    // uint64 max_value_in_flight = 7;


    pub fn get_max_value_in_flight(&self) -> u64 {
        self.max_value_in_flight
    }
    pub fn clear_max_value_in_flight(&mut self) {
        self.max_value_in_flight = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_value_in_flight(&mut self, v: u64) {
        self.max_value_in_flight = v;
    }

    // uint64 channel_reserve = 8;


    pub fn get_channel_reserve(&self) -> u64 {
        self.channel_reserve
    }
    pub fn clear_channel_reserve(&mut self) {
        self.channel_reserve = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_reserve(&mut self, v: u64) {
        self.channel_reserve = v;
    }

    // uint64 min_htlc = 9;


    pub fn get_min_htlc(&self) -> u64 {
        self.min_htlc
    }
    pub fn clear_min_htlc(&mut self) {
        self.min_htlc = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc(&mut self, v: u64) {
        self.min_htlc = v;
    }

    // uint64 fee_per_kw = 10;


    pub fn get_fee_per_kw(&self) -> u64 {
        self.fee_per_kw
    }
    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: u64) {
        self.fee_per_kw = v;
    }

    // uint32 csv_delay = 11;


    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }
    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    // uint32 max_accepted_htlcs = 12;


    pub fn get_max_accepted_htlcs(&self) -> u32 {
        self.max_accepted_htlcs
    }
    pub fn clear_max_accepted_htlcs(&mut self) {
        self.max_accepted_htlcs = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_accepted_htlcs(&mut self, v: u32) {
        self.max_accepted_htlcs = v;
    }

    // uint32 channel_flags = 13;


    pub fn get_channel_flags(&self) -> u32 {
        self.channel_flags
    }
    pub fn clear_channel_flags(&mut self) {
        self.channel_flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_flags(&mut self, v: u32) {
        self.channel_flags = v;
    }
}

impl ::protobuf::Message for ChannelAcceptRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.chain_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.funding_amt = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.push_amt = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dust_limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_value_in_flight = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_reserve = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_htlc = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee_per_kw = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_accepted_htlcs = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_flags = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.node_pubkey);
        }
        if !self.chain_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.chain_hash);
        }
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pending_chan_id);
        }
        if self.funding_amt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.funding_amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.push_amt != 0 {
            my_size += ::protobuf::rt::value_size(5, self.push_amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dust_limit != 0 {
            my_size += ::protobuf::rt::value_size(6, self.dust_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_value_in_flight != 0 {
            my_size += ::protobuf::rt::value_size(7, self.max_value_in_flight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel_reserve != 0 {
            my_size += ::protobuf::rt::value_size(8, self.channel_reserve, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc != 0 {
            my_size += ::protobuf::rt::value_size(9, self.min_htlc, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(10, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(11, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_accepted_htlcs != 0 {
            my_size += ::protobuf::rt::value_size(12, self.max_accepted_htlcs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel_flags != 0 {
            my_size += ::protobuf::rt::value_size(13, self.channel_flags, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_pubkey.is_empty() {
            os.write_bytes(1, &self.node_pubkey)?;
        }
        if !self.chain_hash.is_empty() {
            os.write_bytes(2, &self.chain_hash)?;
        }
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(3, &self.pending_chan_id)?;
        }
        if self.funding_amt != 0 {
            os.write_uint64(4, self.funding_amt)?;
        }
        if self.push_amt != 0 {
            os.write_uint64(5, self.push_amt)?;
        }
        if self.dust_limit != 0 {
            os.write_uint64(6, self.dust_limit)?;
        }
        if self.max_value_in_flight != 0 {
            os.write_uint64(7, self.max_value_in_flight)?;
        }
        if self.channel_reserve != 0 {
            os.write_uint64(8, self.channel_reserve)?;
        }
        if self.min_htlc != 0 {
            os.write_uint64(9, self.min_htlc)?;
        }
        if self.fee_per_kw != 0 {
            os.write_uint64(10, self.fee_per_kw)?;
        }
        if self.csv_delay != 0 {
            os.write_uint32(11, self.csv_delay)?;
        }
        if self.max_accepted_htlcs != 0 {
            os.write_uint32(12, self.max_accepted_htlcs)?;
        }
        if self.channel_flags != 0 {
            os.write_uint32(13, self.channel_flags)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelAcceptRequest {
        ChannelAcceptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "node_pubkey",
                |m: &ChannelAcceptRequest| { &m.node_pubkey },
                |m: &mut ChannelAcceptRequest| { &mut m.node_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chain_hash",
                |m: &ChannelAcceptRequest| { &m.chain_hash },
                |m: &mut ChannelAcceptRequest| { &mut m.chain_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &ChannelAcceptRequest| { &m.pending_chan_id },
                |m: &mut ChannelAcceptRequest| { &mut m.pending_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "funding_amt",
                |m: &ChannelAcceptRequest| { &m.funding_amt },
                |m: &mut ChannelAcceptRequest| { &mut m.funding_amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "push_amt",
                |m: &ChannelAcceptRequest| { &m.push_amt },
                |m: &mut ChannelAcceptRequest| { &mut m.push_amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dust_limit",
                |m: &ChannelAcceptRequest| { &m.dust_limit },
                |m: &mut ChannelAcceptRequest| { &mut m.dust_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_value_in_flight",
                |m: &ChannelAcceptRequest| { &m.max_value_in_flight },
                |m: &mut ChannelAcceptRequest| { &mut m.max_value_in_flight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "channel_reserve",
                |m: &ChannelAcceptRequest| { &m.channel_reserve },
                |m: &mut ChannelAcceptRequest| { &mut m.channel_reserve },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "min_htlc",
                |m: &ChannelAcceptRequest| { &m.min_htlc },
                |m: &mut ChannelAcceptRequest| { &mut m.min_htlc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee_per_kw",
                |m: &ChannelAcceptRequest| { &m.fee_per_kw },
                |m: &mut ChannelAcceptRequest| { &mut m.fee_per_kw },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "csv_delay",
                |m: &ChannelAcceptRequest| { &m.csv_delay },
                |m: &mut ChannelAcceptRequest| { &mut m.csv_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_accepted_htlcs",
                |m: &ChannelAcceptRequest| { &m.max_accepted_htlcs },
                |m: &mut ChannelAcceptRequest| { &mut m.max_accepted_htlcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_flags",
                |m: &ChannelAcceptRequest| { &m.channel_flags },
                |m: &mut ChannelAcceptRequest| { &mut m.channel_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelAcceptRequest>(
                "ChannelAcceptRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelAcceptRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelAcceptRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelAcceptRequest::new)
    }
}

impl ::protobuf::Clear for ChannelAcceptRequest {
    fn clear(&mut self) {
        self.node_pubkey.clear();
        self.chain_hash.clear();
        self.pending_chan_id.clear();
        self.funding_amt = 0;
        self.push_amt = 0;
        self.dust_limit = 0;
        self.max_value_in_flight = 0;
        self.channel_reserve = 0;
        self.min_htlc = 0;
        self.fee_per_kw = 0;
        self.csv_delay = 0;
        self.max_accepted_htlcs = 0;
        self.channel_flags = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelAcceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelAcceptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelAcceptResponse {
    // message fields
    pub accept: bool,
    pub pending_chan_id: ::std::vec::Vec<u8>,
    pub error: ::std::string::String,
    pub upfront_shutdown: ::std::string::String,
    pub csv_delay: u32,
    pub reserve_sat: u64,
    pub in_flight_max_msat: u64,
    pub max_htlc_count: u32,
    pub min_htlc_in: u64,
    pub min_accept_depth: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelAcceptResponse {
    fn default() -> &'a ChannelAcceptResponse {
        <ChannelAcceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelAcceptResponse {
    pub fn new() -> ChannelAcceptResponse {
        ::std::default::Default::default()
    }

    // bool accept = 1;


    pub fn get_accept(&self) -> bool {
        self.accept
    }
    pub fn clear_accept(&mut self) {
        self.accept = false;
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = v;
    }

    // bytes pending_chan_id = 2;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }

    // string error = 3;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // string upfront_shutdown = 4;


    pub fn get_upfront_shutdown(&self) -> &str {
        &self.upfront_shutdown
    }
    pub fn clear_upfront_shutdown(&mut self) {
        self.upfront_shutdown.clear();
    }

    // Param is passed by value, moved
    pub fn set_upfront_shutdown(&mut self, v: ::std::string::String) {
        self.upfront_shutdown = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upfront_shutdown(&mut self) -> &mut ::std::string::String {
        &mut self.upfront_shutdown
    }

    // Take field
    pub fn take_upfront_shutdown(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upfront_shutdown, ::std::string::String::new())
    }

    // uint32 csv_delay = 5;


    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }
    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    // uint64 reserve_sat = 6;


    pub fn get_reserve_sat(&self) -> u64 {
        self.reserve_sat
    }
    pub fn clear_reserve_sat(&mut self) {
        self.reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_reserve_sat(&mut self, v: u64) {
        self.reserve_sat = v;
    }

    // uint64 in_flight_max_msat = 7;


    pub fn get_in_flight_max_msat(&self) -> u64 {
        self.in_flight_max_msat
    }
    pub fn clear_in_flight_max_msat(&mut self) {
        self.in_flight_max_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_in_flight_max_msat(&mut self, v: u64) {
        self.in_flight_max_msat = v;
    }

    // uint32 max_htlc_count = 8;


    pub fn get_max_htlc_count(&self) -> u32 {
        self.max_htlc_count
    }
    pub fn clear_max_htlc_count(&mut self) {
        self.max_htlc_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_htlc_count(&mut self, v: u32) {
        self.max_htlc_count = v;
    }

    // uint64 min_htlc_in = 9;


    pub fn get_min_htlc_in(&self) -> u64 {
        self.min_htlc_in
    }
    pub fn clear_min_htlc_in(&mut self) {
        self.min_htlc_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_in(&mut self, v: u64) {
        self.min_htlc_in = v;
    }

    // uint32 min_accept_depth = 10;


    pub fn get_min_accept_depth(&self) -> u32 {
        self.min_accept_depth
    }
    pub fn clear_min_accept_depth(&mut self) {
        self.min_accept_depth = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_accept_depth(&mut self, v: u32) {
        self.min_accept_depth = v;
    }
}

impl ::protobuf::Message for ChannelAcceptResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.accept = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upfront_shutdown)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reserve_sat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.in_flight_max_msat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_htlc_count = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_htlc_in = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_accept_depth = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.accept != false {
            my_size += 2;
        }
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pending_chan_id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        if !self.upfront_shutdown.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.upfront_shutdown);
        }
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(5, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.in_flight_max_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.in_flight_max_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_htlc_count != 0 {
            my_size += ::protobuf::rt::value_size(8, self.max_htlc_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc_in != 0 {
            my_size += ::protobuf::rt::value_size(9, self.min_htlc_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_accept_depth != 0 {
            my_size += ::protobuf::rt::value_size(10, self.min_accept_depth, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.accept != false {
            os.write_bool(1, self.accept)?;
        }
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(2, &self.pending_chan_id)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        if !self.upfront_shutdown.is_empty() {
            os.write_string(4, &self.upfront_shutdown)?;
        }
        if self.csv_delay != 0 {
            os.write_uint32(5, self.csv_delay)?;
        }
        if self.reserve_sat != 0 {
            os.write_uint64(6, self.reserve_sat)?;
        }
        if self.in_flight_max_msat != 0 {
            os.write_uint64(7, self.in_flight_max_msat)?;
        }
        if self.max_htlc_count != 0 {
            os.write_uint32(8, self.max_htlc_count)?;
        }
        if self.min_htlc_in != 0 {
            os.write_uint64(9, self.min_htlc_in)?;
        }
        if self.min_accept_depth != 0 {
            os.write_uint32(10, self.min_accept_depth)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelAcceptResponse {
        ChannelAcceptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "accept",
                |m: &ChannelAcceptResponse| { &m.accept },
                |m: &mut ChannelAcceptResponse| { &mut m.accept },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &ChannelAcceptResponse| { &m.pending_chan_id },
                |m: &mut ChannelAcceptResponse| { &mut m.pending_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &ChannelAcceptResponse| { &m.error },
                |m: &mut ChannelAcceptResponse| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upfront_shutdown",
                |m: &ChannelAcceptResponse| { &m.upfront_shutdown },
                |m: &mut ChannelAcceptResponse| { &mut m.upfront_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "csv_delay",
                |m: &ChannelAcceptResponse| { &m.csv_delay },
                |m: &mut ChannelAcceptResponse| { &mut m.csv_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "reserve_sat",
                |m: &ChannelAcceptResponse| { &m.reserve_sat },
                |m: &mut ChannelAcceptResponse| { &mut m.reserve_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "in_flight_max_msat",
                |m: &ChannelAcceptResponse| { &m.in_flight_max_msat },
                |m: &mut ChannelAcceptResponse| { &mut m.in_flight_max_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_htlc_count",
                |m: &ChannelAcceptResponse| { &m.max_htlc_count },
                |m: &mut ChannelAcceptResponse| { &mut m.max_htlc_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "min_htlc_in",
                |m: &ChannelAcceptResponse| { &m.min_htlc_in },
                |m: &mut ChannelAcceptResponse| { &mut m.min_htlc_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "min_accept_depth",
                |m: &ChannelAcceptResponse| { &m.min_accept_depth },
                |m: &mut ChannelAcceptResponse| { &mut m.min_accept_depth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelAcceptResponse>(
                "ChannelAcceptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelAcceptResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelAcceptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelAcceptResponse::new)
    }
}

impl ::protobuf::Clear for ChannelAcceptResponse {
    fn clear(&mut self) {
        self.accept = false;
        self.pending_chan_id.clear();
        self.error.clear();
        self.upfront_shutdown.clear();
        self.csv_delay = 0;
        self.reserve_sat = 0;
        self.in_flight_max_msat = 0;
        self.max_htlc_count = 0;
        self.min_htlc_in = 0;
        self.min_accept_depth = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelAcceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelAcceptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelPoint {
    // message fields
    pub output_index: u32,
    // message oneof groups
    pub funding_txid: ::std::option::Option<ChannelPoint_oneof_funding_txid>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelPoint {
    fn default() -> &'a ChannelPoint {
        <ChannelPoint as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ChannelPoint_oneof_funding_txid {
    funding_txid_bytes(::std::vec::Vec<u8>),
    funding_txid_str(::std::string::String),
}

impl ChannelPoint {
    pub fn new() -> ChannelPoint {
        ::std::default::Default::default()
    }

    // bytes funding_txid_bytes = 1;


    pub fn get_funding_txid_bytes(&self) -> &[u8] {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_funding_txid_bytes(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_bytes(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(::std::vec::Vec::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_funding_txid_bytes() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // string funding_txid_str = 2;


    pub fn get_funding_txid_str(&self) -> &str {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_funding_txid_str(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_str(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_str(&mut self, v: ::std::string::String) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_str(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(::std::string::String::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_str(&mut self) -> ::std::string::String {
        if self.has_funding_txid_str() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 output_index = 3;


    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }
}

impl ::protobuf::Message for ChannelPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelPoint {
        ChannelPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "funding_txid_bytes",
                ChannelPoint::has_funding_txid_bytes,
                ChannelPoint::get_funding_txid_bytes,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "funding_txid_str",
                ChannelPoint::has_funding_txid_str,
                ChannelPoint::get_funding_txid_str,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "output_index",
                |m: &ChannelPoint| { &m.output_index },
                |m: &mut ChannelPoint| { &mut m.output_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelPoint>(
                "ChannelPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelPoint {
        static instance: ::protobuf::rt::LazyV2<ChannelPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelPoint::new)
    }
}

impl ::protobuf::Clear for ChannelPoint {
    fn clear(&mut self) {
        self.funding_txid = ::std::option::Option::None;
        self.funding_txid = ::std::option::Option::None;
        self.output_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OutPoint {
    // message fields
    pub txid_bytes: ::std::vec::Vec<u8>,
    pub txid_str: ::std::string::String,
    pub output_index: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutPoint {
    fn default() -> &'a OutPoint {
        <OutPoint as ::protobuf::Message>::default_instance()
    }
}

impl OutPoint {
    pub fn new() -> OutPoint {
        ::std::default::Default::default()
    }

    // bytes txid_bytes = 1;


    pub fn get_txid_bytes(&self) -> &[u8] {
        &self.txid_bytes
    }
    pub fn clear_txid_bytes(&mut self) {
        self.txid_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid_bytes
    }

    // Take field
    pub fn take_txid_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid_bytes, ::std::vec::Vec::new())
    }

    // string txid_str = 2;


    pub fn get_txid_str(&self) -> &str {
        &self.txid_str
    }
    pub fn clear_txid_str(&mut self) {
        self.txid_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid_str(&mut self, v: ::std::string::String) {
        self.txid_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid_str(&mut self) -> &mut ::std::string::String {
        &mut self.txid_str
    }

    // Take field
    pub fn take_txid_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid_str, ::std::string::String::new())
    }

    // uint32 output_index = 3;


    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }
}

impl ::protobuf::Message for OutPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid_bytes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid_str)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid_bytes);
        }
        if !self.txid_str.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid_str);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid_bytes.is_empty() {
            os.write_bytes(1, &self.txid_bytes)?;
        }
        if !self.txid_str.is_empty() {
            os.write_string(2, &self.txid_str)?;
        }
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutPoint {
        OutPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid_bytes",
                |m: &OutPoint| { &m.txid_bytes },
                |m: &mut OutPoint| { &mut m.txid_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "txid_str",
                |m: &OutPoint| { &m.txid_str },
                |m: &mut OutPoint| { &mut m.txid_str },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "output_index",
                |m: &OutPoint| { &m.output_index },
                |m: &mut OutPoint| { &mut m.output_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutPoint>(
                "OutPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutPoint {
        static instance: ::protobuf::rt::LazyV2<OutPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutPoint::new)
    }
}

impl ::protobuf::Clear for OutPoint {
    fn clear(&mut self) {
        self.txid_bytes.clear();
        self.txid_str.clear();
        self.output_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LightningAddress {
    // message fields
    pub pubkey: ::std::string::String,
    pub host: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightningAddress {
    fn default() -> &'a LightningAddress {
        <LightningAddress as ::protobuf::Message>::default_instance()
    }
}

impl LightningAddress {
    pub fn new() -> LightningAddress {
        ::std::default::Default::default()
    }

    // string pubkey = 1;


    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightningAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pubkey);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pubkey.is_empty() {
            os.write_string(1, &self.pubkey)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningAddress {
        LightningAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pubkey",
                |m: &LightningAddress| { &m.pubkey },
                |m: &mut LightningAddress| { &mut m.pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &LightningAddress| { &m.host },
                |m: &mut LightningAddress| { &mut m.host },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LightningAddress>(
                "LightningAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LightningAddress {
        static instance: ::protobuf::rt::LazyV2<LightningAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LightningAddress::new)
    }
}

impl ::protobuf::Clear for LightningAddress {
    fn clear(&mut self) {
        self.pubkey.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EstimateFeeRequest {
    // message fields
    pub AddrToAmount: ::std::collections::HashMap<::std::string::String, i64>,
    pub target_conf: i32,
    pub min_confs: i32,
    pub spend_unconfirmed: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EstimateFeeRequest {
    fn default() -> &'a EstimateFeeRequest {
        <EstimateFeeRequest as ::protobuf::Message>::default_instance()
    }
}

impl EstimateFeeRequest {
    pub fn new() -> EstimateFeeRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.EstimateFeeRequest.AddrToAmountEntry AddrToAmount = 1;


    pub fn get_AddrToAmount(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.AddrToAmount
    }
    pub fn clear_AddrToAmount(&mut self) {
        self.AddrToAmount.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddrToAmount(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.AddrToAmount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddrToAmount(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.AddrToAmount
    }

    // Take field
    pub fn take_AddrToAmount(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.AddrToAmount, ::std::collections::HashMap::new())
    }

    // int32 target_conf = 2;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int32 min_confs = 3;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // bool spend_unconfirmed = 4;


    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }
}

impl ::protobuf::Message for EstimateFeeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.AddrToAmount)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount);
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(2, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(3, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount, os)?;
        if self.target_conf != 0 {
            os.write_int32(2, self.target_conf)?;
        }
        if self.min_confs != 0 {
            os.write_int32(3, self.min_confs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(4, self.spend_unconfirmed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EstimateFeeRequest {
        EstimateFeeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "AddrToAmount",
                |m: &EstimateFeeRequest| { &m.AddrToAmount },
                |m: &mut EstimateFeeRequest| { &mut m.AddrToAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target_conf",
                |m: &EstimateFeeRequest| { &m.target_conf },
                |m: &mut EstimateFeeRequest| { &mut m.target_conf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_confs",
                |m: &EstimateFeeRequest| { &m.min_confs },
                |m: &mut EstimateFeeRequest| { &mut m.min_confs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spend_unconfirmed",
                |m: &EstimateFeeRequest| { &m.spend_unconfirmed },
                |m: &mut EstimateFeeRequest| { &mut m.spend_unconfirmed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EstimateFeeRequest>(
                "EstimateFeeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EstimateFeeRequest {
        static instance: ::protobuf::rt::LazyV2<EstimateFeeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EstimateFeeRequest::new)
    }
}

impl ::protobuf::Clear for EstimateFeeRequest {
    fn clear(&mut self) {
        self.AddrToAmount.clear();
        self.target_conf = 0;
        self.min_confs = 0;
        self.spend_unconfirmed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EstimateFeeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EstimateFeeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EstimateFeeResponse {
    // message fields
    pub fee_sat: i64,
    pub feerate_sat_per_byte: i64,
    pub sat_per_vbyte: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EstimateFeeResponse {
    fn default() -> &'a EstimateFeeResponse {
        <EstimateFeeResponse as ::protobuf::Message>::default_instance()
    }
}

impl EstimateFeeResponse {
    pub fn new() -> EstimateFeeResponse {
        ::std::default::Default::default()
    }

    // int64 fee_sat = 1;


    pub fn get_fee_sat(&self) -> i64 {
        self.fee_sat
    }
    pub fn clear_fee_sat(&mut self) {
        self.fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_sat(&mut self, v: i64) {
        self.fee_sat = v;
    }

    // int64 feerate_sat_per_byte = 2;


    pub fn get_feerate_sat_per_byte(&self) -> i64 {
        self.feerate_sat_per_byte
    }
    pub fn clear_feerate_sat_per_byte(&mut self) {
        self.feerate_sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_feerate_sat_per_byte(&mut self, v: i64) {
        self.feerate_sat_per_byte = v;
    }

    // uint64 sat_per_vbyte = 3;


    pub fn get_sat_per_vbyte(&self) -> u64 {
        self.sat_per_vbyte
    }
    pub fn clear_sat_per_vbyte(&mut self) {
        self.sat_per_vbyte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_vbyte(&mut self, v: u64) {
        self.sat_per_vbyte = v;
    }
}

impl ::protobuf::Message for EstimateFeeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_sat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.feerate_sat_per_byte = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sat_per_vbyte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.feerate_sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(2, self.feerate_sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_vbyte != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sat_per_vbyte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fee_sat != 0 {
            os.write_int64(1, self.fee_sat)?;
        }
        if self.feerate_sat_per_byte != 0 {
            os.write_int64(2, self.feerate_sat_per_byte)?;
        }
        if self.sat_per_vbyte != 0 {
            os.write_uint64(3, self.sat_per_vbyte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EstimateFeeResponse {
        EstimateFeeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_sat",
                |m: &EstimateFeeResponse| { &m.fee_sat },
                |m: &mut EstimateFeeResponse| { &mut m.fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "feerate_sat_per_byte",
                |m: &EstimateFeeResponse| { &m.feerate_sat_per_byte },
                |m: &mut EstimateFeeResponse| { &mut m.feerate_sat_per_byte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sat_per_vbyte",
                |m: &EstimateFeeResponse| { &m.sat_per_vbyte },
                |m: &mut EstimateFeeResponse| { &mut m.sat_per_vbyte },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EstimateFeeResponse>(
                "EstimateFeeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EstimateFeeResponse {
        static instance: ::protobuf::rt::LazyV2<EstimateFeeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EstimateFeeResponse::new)
    }
}

impl ::protobuf::Clear for EstimateFeeResponse {
    fn clear(&mut self) {
        self.fee_sat = 0;
        self.feerate_sat_per_byte = 0;
        self.sat_per_vbyte = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EstimateFeeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EstimateFeeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendManyRequest {
    // message fields
    pub AddrToAmount: ::std::collections::HashMap<::std::string::String, i64>,
    pub target_conf: i32,
    pub sat_per_vbyte: u64,
    pub sat_per_byte: i64,
    pub label: ::std::string::String,
    pub min_confs: i32,
    pub spend_unconfirmed: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendManyRequest {
    fn default() -> &'a SendManyRequest {
        <SendManyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendManyRequest {
    pub fn new() -> SendManyRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.SendManyRequest.AddrToAmountEntry AddrToAmount = 1;


    pub fn get_AddrToAmount(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.AddrToAmount
    }
    pub fn clear_AddrToAmount(&mut self) {
        self.AddrToAmount.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddrToAmount(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.AddrToAmount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddrToAmount(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.AddrToAmount
    }

    // Take field
    pub fn take_AddrToAmount(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.AddrToAmount, ::std::collections::HashMap::new())
    }

    // int32 target_conf = 3;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // uint64 sat_per_vbyte = 4;


    pub fn get_sat_per_vbyte(&self) -> u64 {
        self.sat_per_vbyte
    }
    pub fn clear_sat_per_vbyte(&mut self) {
        self.sat_per_vbyte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_vbyte(&mut self, v: u64) {
        self.sat_per_vbyte = v;
    }

    // int64 sat_per_byte = 5;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    // string label = 6;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // int32 min_confs = 7;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // bool spend_unconfirmed = 8;


    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }
}

impl ::protobuf::Message for SendManyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.AddrToAmount)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sat_per_vbyte = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount);
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_vbyte != 0 {
            my_size += ::protobuf::rt::value_size(4, self.sat_per_vbyte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.label);
        }
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(7, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount, os)?;
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_vbyte != 0 {
            os.write_uint64(4, self.sat_per_vbyte)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(5, self.sat_per_byte)?;
        }
        if !self.label.is_empty() {
            os.write_string(6, &self.label)?;
        }
        if self.min_confs != 0 {
            os.write_int32(7, self.min_confs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(8, self.spend_unconfirmed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyRequest {
        SendManyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "AddrToAmount",
                |m: &SendManyRequest| { &m.AddrToAmount },
                |m: &mut SendManyRequest| { &mut m.AddrToAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target_conf",
                |m: &SendManyRequest| { &m.target_conf },
                |m: &mut SendManyRequest| { &mut m.target_conf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sat_per_vbyte",
                |m: &SendManyRequest| { &m.sat_per_vbyte },
                |m: &mut SendManyRequest| { &mut m.sat_per_vbyte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sat_per_byte",
                |m: &SendManyRequest| { &m.sat_per_byte },
                |m: &mut SendManyRequest| { &mut m.sat_per_byte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &SendManyRequest| { &m.label },
                |m: &mut SendManyRequest| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_confs",
                |m: &SendManyRequest| { &m.min_confs },
                |m: &mut SendManyRequest| { &mut m.min_confs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spend_unconfirmed",
                |m: &SendManyRequest| { &m.spend_unconfirmed },
                |m: &mut SendManyRequest| { &mut m.spend_unconfirmed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendManyRequest>(
                "SendManyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendManyRequest {
        static instance: ::protobuf::rt::LazyV2<SendManyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendManyRequest::new)
    }
}

impl ::protobuf::Clear for SendManyRequest {
    fn clear(&mut self) {
        self.AddrToAmount.clear();
        self.target_conf = 0;
        self.sat_per_vbyte = 0;
        self.sat_per_byte = 0;
        self.label.clear();
        self.min_confs = 0;
        self.spend_unconfirmed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendManyResponse {
    // message fields
    pub txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendManyResponse {
    fn default() -> &'a SendManyResponse {
        <SendManyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendManyResponse {
    pub fn new() -> SendManyResponse {
        ::std::default::Default::default()
    }

    // string txid = 1;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendManyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_string(1, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyResponse {
        SendManyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "txid",
                |m: &SendManyResponse| { &m.txid },
                |m: &mut SendManyResponse| { &mut m.txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendManyResponse>(
                "SendManyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendManyResponse {
        static instance: ::protobuf::rt::LazyV2<SendManyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendManyResponse::new)
    }
}

impl ::protobuf::Clear for SendManyResponse {
    fn clear(&mut self) {
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendCoinsRequest {
    // message fields
    pub addr: ::std::string::String,
    pub amount: i64,
    pub target_conf: i32,
    pub sat_per_vbyte: u64,
    pub sat_per_byte: i64,
    pub send_all: bool,
    pub label: ::std::string::String,
    pub min_confs: i32,
    pub spend_unconfirmed: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendCoinsRequest {
    fn default() -> &'a SendCoinsRequest {
        <SendCoinsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendCoinsRequest {
    pub fn new() -> SendCoinsRequest {
        ::std::default::Default::default()
    }

    // string addr = 1;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // int32 target_conf = 3;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // uint64 sat_per_vbyte = 4;


    pub fn get_sat_per_vbyte(&self) -> u64 {
        self.sat_per_vbyte
    }
    pub fn clear_sat_per_vbyte(&mut self) {
        self.sat_per_vbyte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_vbyte(&mut self, v: u64) {
        self.sat_per_vbyte = v;
    }

    // int64 sat_per_byte = 5;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    // bool send_all = 6;


    pub fn get_send_all(&self) -> bool {
        self.send_all
    }
    pub fn clear_send_all(&mut self) {
        self.send_all = false;
    }

    // Param is passed by value, moved
    pub fn set_send_all(&mut self, v: bool) {
        self.send_all = v;
    }

    // string label = 7;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // int32 min_confs = 8;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // bool spend_unconfirmed = 9;


    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }
}

impl ::protobuf::Message for SendCoinsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sat_per_vbyte = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_all = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.addr);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_vbyte != 0 {
            my_size += ::protobuf::rt::value_size(4, self.sat_per_vbyte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.send_all != false {
            my_size += 2;
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.label);
        }
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(8, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.addr.is_empty() {
            os.write_string(1, &self.addr)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_vbyte != 0 {
            os.write_uint64(4, self.sat_per_vbyte)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(5, self.sat_per_byte)?;
        }
        if self.send_all != false {
            os.write_bool(6, self.send_all)?;
        }
        if !self.label.is_empty() {
            os.write_string(7, &self.label)?;
        }
        if self.min_confs != 0 {
            os.write_int32(8, self.min_confs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(9, self.spend_unconfirmed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCoinsRequest {
        SendCoinsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addr",
                |m: &SendCoinsRequest| { &m.addr },
                |m: &mut SendCoinsRequest| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &SendCoinsRequest| { &m.amount },
                |m: &mut SendCoinsRequest| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target_conf",
                |m: &SendCoinsRequest| { &m.target_conf },
                |m: &mut SendCoinsRequest| { &mut m.target_conf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sat_per_vbyte",
                |m: &SendCoinsRequest| { &m.sat_per_vbyte },
                |m: &mut SendCoinsRequest| { &mut m.sat_per_vbyte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sat_per_byte",
                |m: &SendCoinsRequest| { &m.sat_per_byte },
                |m: &mut SendCoinsRequest| { &mut m.sat_per_byte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_all",
                |m: &SendCoinsRequest| { &m.send_all },
                |m: &mut SendCoinsRequest| { &mut m.send_all },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &SendCoinsRequest| { &m.label },
                |m: &mut SendCoinsRequest| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_confs",
                |m: &SendCoinsRequest| { &m.min_confs },
                |m: &mut SendCoinsRequest| { &mut m.min_confs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spend_unconfirmed",
                |m: &SendCoinsRequest| { &m.spend_unconfirmed },
                |m: &mut SendCoinsRequest| { &mut m.spend_unconfirmed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendCoinsRequest>(
                "SendCoinsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendCoinsRequest {
        static instance: ::protobuf::rt::LazyV2<SendCoinsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendCoinsRequest::new)
    }
}

impl ::protobuf::Clear for SendCoinsRequest {
    fn clear(&mut self) {
        self.addr.clear();
        self.amount = 0;
        self.target_conf = 0;
        self.sat_per_vbyte = 0;
        self.sat_per_byte = 0;
        self.send_all = false;
        self.label.clear();
        self.min_confs = 0;
        self.spend_unconfirmed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCoinsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCoinsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SendCoinsResponse {
    // message fields
    pub txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendCoinsResponse {
    fn default() -> &'a SendCoinsResponse {
        <SendCoinsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendCoinsResponse {
    pub fn new() -> SendCoinsResponse {
        ::std::default::Default::default()
    }

    // string txid = 1;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendCoinsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_string(1, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCoinsResponse {
        SendCoinsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "txid",
                |m: &SendCoinsResponse| { &m.txid },
                |m: &mut SendCoinsResponse| { &mut m.txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendCoinsResponse>(
                "SendCoinsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendCoinsResponse {
        static instance: ::protobuf::rt::LazyV2<SendCoinsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendCoinsResponse::new)
    }
}

impl ::protobuf::Clear for SendCoinsResponse {
    fn clear(&mut self) {
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCoinsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCoinsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListUnspentRequest {
    // message fields
    pub min_confs: i32,
    pub max_confs: i32,
    pub account: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUnspentRequest {
    fn default() -> &'a ListUnspentRequest {
        <ListUnspentRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUnspentRequest {
    pub fn new() -> ListUnspentRequest {
        ::std::default::Default::default()
    }

    // int32 min_confs = 1;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // int32 max_confs = 2;


    pub fn get_max_confs(&self) -> i32 {
        self.max_confs
    }
    pub fn clear_max_confs(&mut self) {
        self.max_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_confs(&mut self, v: i32) {
        self.max_confs = v;
    }

    // string account = 3;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListUnspentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_confs = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(1, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_confs != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_confs != 0 {
            os.write_int32(1, self.min_confs)?;
        }
        if self.max_confs != 0 {
            os.write_int32(2, self.max_confs)?;
        }
        if !self.account.is_empty() {
            os.write_string(3, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUnspentRequest {
        ListUnspentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_confs",
                |m: &ListUnspentRequest| { &m.min_confs },
                |m: &mut ListUnspentRequest| { &mut m.min_confs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_confs",
                |m: &ListUnspentRequest| { &m.max_confs },
                |m: &mut ListUnspentRequest| { &mut m.max_confs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account",
                |m: &ListUnspentRequest| { &m.account },
                |m: &mut ListUnspentRequest| { &mut m.account },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUnspentRequest>(
                "ListUnspentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUnspentRequest {
        static instance: ::protobuf::rt::LazyV2<ListUnspentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUnspentRequest::new)
    }
}

impl ::protobuf::Clear for ListUnspentRequest {
    fn clear(&mut self) {
        self.min_confs = 0;
        self.max_confs = 0;
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUnspentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUnspentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListUnspentResponse {
    // message fields
    pub utxos: ::protobuf::RepeatedField<Utxo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUnspentResponse {
    fn default() -> &'a ListUnspentResponse {
        <ListUnspentResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListUnspentResponse {
    pub fn new() -> ListUnspentResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Utxo utxos = 1;


    pub fn get_utxos(&self) -> &[Utxo] {
        &self.utxos
    }
    pub fn clear_utxos(&mut self) {
        self.utxos.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxos(&mut self, v: ::protobuf::RepeatedField<Utxo>) {
        self.utxos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_utxos(&mut self) -> &mut ::protobuf::RepeatedField<Utxo> {
        &mut self.utxos
    }

    // Take field
    pub fn take_utxos(&mut self) -> ::protobuf::RepeatedField<Utxo> {
        ::std::mem::replace(&mut self.utxos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListUnspentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.utxos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.utxos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.utxos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.utxos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUnspentResponse {
        ListUnspentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Utxo>>(
                "utxos",
                |m: &ListUnspentResponse| { &m.utxos },
                |m: &mut ListUnspentResponse| { &mut m.utxos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUnspentResponse>(
                "ListUnspentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUnspentResponse {
        static instance: ::protobuf::rt::LazyV2<ListUnspentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUnspentResponse::new)
    }
}

impl ::protobuf::Clear for ListUnspentResponse {
    fn clear(&mut self) {
        self.utxos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUnspentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUnspentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NewAddressRequest {
    // message fields
    pub field_type: AddressType,
    pub account: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewAddressRequest {
    fn default() -> &'a NewAddressRequest {
        <NewAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl NewAddressRequest {
    pub fn new() -> NewAddressRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.AddressType type = 1;


    pub fn get_field_type(&self) -> AddressType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AddressType::WITNESS_PUBKEY_HASH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AddressType) {
        self.field_type = v;
    }

    // string account = 2;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NewAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != AddressType::WITNESS_PUBKEY_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != AddressType::WITNESS_PUBKEY_HASH {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.account.is_empty() {
            os.write_string(2, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewAddressRequest {
        NewAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressType>>(
                "type",
                |m: &NewAddressRequest| { &m.field_type },
                |m: &mut NewAddressRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account",
                |m: &NewAddressRequest| { &m.account },
                |m: &mut NewAddressRequest| { &mut m.account },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewAddressRequest>(
                "NewAddressRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewAddressRequest {
        static instance: ::protobuf::rt::LazyV2<NewAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewAddressRequest::new)
    }
}

impl ::protobuf::Clear for NewAddressRequest {
    fn clear(&mut self) {
        self.field_type = AddressType::WITNESS_PUBKEY_HASH;
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NewAddressResponse {
    // message fields
    pub address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewAddressResponse {
    fn default() -> &'a NewAddressResponse {
        <NewAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl NewAddressResponse {
    pub fn new() -> NewAddressResponse {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NewAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewAddressResponse {
        NewAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &NewAddressResponse| { &m.address },
                |m: &mut NewAddressResponse| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewAddressResponse>(
                "NewAddressResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewAddressResponse {
        static instance: ::protobuf::rt::LazyV2<NewAddressResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewAddressResponse::new)
    }
}

impl ::protobuf::Clear for NewAddressResponse {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SignMessageRequest {
    // message fields
    pub msg: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageRequest {
    fn default() -> &'a SignMessageRequest {
        <SignMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageRequest {
    pub fn new() -> SignMessageRequest {
        ::std::default::Default::default()
    }

    // bytes msg = 1;


    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.msg.is_empty() {
            os.write_bytes(1, &self.msg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageRequest {
        SignMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "msg",
                |m: &SignMessageRequest| { &m.msg },
                |m: &mut SignMessageRequest| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignMessageRequest>(
                "SignMessageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignMessageRequest {
        static instance: ::protobuf::rt::LazyV2<SignMessageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignMessageRequest::new)
    }
}

impl ::protobuf::Clear for SignMessageRequest {
    fn clear(&mut self) {
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SignMessageResponse {
    // message fields
    pub signature: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageResponse {
    fn default() -> &'a SignMessageResponse {
        <SignMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageResponse {
    pub fn new() -> SignMessageResponse {
        ::std::default::Default::default()
    }

    // string signature = 1;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_string(1, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageResponse {
        SignMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &SignMessageResponse| { &m.signature },
                |m: &mut SignMessageResponse| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignMessageResponse>(
                "SignMessageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignMessageResponse {
        static instance: ::protobuf::rt::LazyV2<SignMessageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignMessageResponse::new)
    }
}

impl ::protobuf::Clear for SignMessageResponse {
    fn clear(&mut self) {
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VerifyMessageRequest {
    // message fields
    pub msg: ::std::vec::Vec<u8>,
    pub signature: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyMessageRequest {
    fn default() -> &'a VerifyMessageRequest {
        <VerifyMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyMessageRequest {
    pub fn new() -> VerifyMessageRequest {
        ::std::default::Default::default()
    }

    // bytes msg = 1;


    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }

    // string signature = 2;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.msg);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.msg.is_empty() {
            os.write_bytes(1, &self.msg)?;
        }
        if !self.signature.is_empty() {
            os.write_string(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageRequest {
        VerifyMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "msg",
                |m: &VerifyMessageRequest| { &m.msg },
                |m: &mut VerifyMessageRequest| { &mut m.msg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &VerifyMessageRequest| { &m.signature },
                |m: &mut VerifyMessageRequest| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyMessageRequest>(
                "VerifyMessageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyMessageRequest {
        static instance: ::protobuf::rt::LazyV2<VerifyMessageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyMessageRequest::new)
    }
}

impl ::protobuf::Clear for VerifyMessageRequest {
    fn clear(&mut self) {
        self.msg.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VerifyMessageResponse {
    // message fields
    pub valid: bool,
    pub pubkey: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyMessageResponse {
    fn default() -> &'a VerifyMessageResponse {
        <VerifyMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyMessageResponse {
    pub fn new() -> VerifyMessageResponse {
        ::std::default::Default::default()
    }

    // bool valid = 1;


    pub fn get_valid(&self) -> bool {
        self.valid
    }
    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    // string pubkey = 2;


    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valid != false {
            my_size += 2;
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pubkey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valid != false {
            os.write_bool(1, self.valid)?;
        }
        if !self.pubkey.is_empty() {
            os.write_string(2, &self.pubkey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageResponse {
        VerifyMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "valid",
                |m: &VerifyMessageResponse| { &m.valid },
                |m: &mut VerifyMessageResponse| { &mut m.valid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pubkey",
                |m: &VerifyMessageResponse| { &m.pubkey },
                |m: &mut VerifyMessageResponse| { &mut m.pubkey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyMessageResponse>(
                "VerifyMessageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyMessageResponse {
        static instance: ::protobuf::rt::LazyV2<VerifyMessageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyMessageResponse::new)
    }
}

impl ::protobuf::Clear for VerifyMessageResponse {
    fn clear(&mut self) {
        self.valid = false;
        self.pubkey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConnectPeerRequest {
    // message fields
    pub addr: ::protobuf::SingularPtrField<LightningAddress>,
    pub perm: bool,
    pub timeout: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectPeerRequest {
    fn default() -> &'a ConnectPeerRequest {
        <ConnectPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectPeerRequest {
    pub fn new() -> ConnectPeerRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.LightningAddress addr = 1;


    pub fn get_addr(&self) -> &LightningAddress {
        self.addr.as_ref().unwrap_or_else(|| <LightningAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: LightningAddress) {
        self.addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut LightningAddress {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> LightningAddress {
        self.addr.take().unwrap_or_else(|| LightningAddress::new())
    }

    // bool perm = 2;


    pub fn get_perm(&self) -> bool {
        self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm = false;
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: bool) {
        self.perm = v;
    }

    // uint64 timeout = 3;


    pub fn get_timeout(&self) -> u64 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u64) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for ConnectPeerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.addr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perm = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.perm != false {
            my_size += 2;
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.perm != false {
            os.write_bool(2, self.perm)?;
        }
        if self.timeout != 0 {
            os.write_uint64(3, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerRequest {
        ConnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningAddress>>(
                "addr",
                |m: &ConnectPeerRequest| { &m.addr },
                |m: &mut ConnectPeerRequest| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "perm",
                |m: &ConnectPeerRequest| { &m.perm },
                |m: &mut ConnectPeerRequest| { &mut m.perm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeout",
                |m: &ConnectPeerRequest| { &m.timeout },
                |m: &mut ConnectPeerRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectPeerRequest>(
                "ConnectPeerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectPeerRequest {
        static instance: ::protobuf::rt::LazyV2<ConnectPeerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectPeerRequest::new)
    }
}

impl ::protobuf::Clear for ConnectPeerRequest {
    fn clear(&mut self) {
        self.addr.clear();
        self.perm = false;
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConnectPeerResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectPeerResponse {
    fn default() -> &'a ConnectPeerResponse {
        <ConnectPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectPeerResponse {
    pub fn new() -> ConnectPeerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConnectPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerResponse {
        ConnectPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectPeerResponse>(
                "ConnectPeerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectPeerResponse {
        static instance: ::protobuf::rt::LazyV2<ConnectPeerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectPeerResponse::new)
    }
}

impl ::protobuf::Clear for ConnectPeerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DisconnectPeerRequest {
    // message fields
    pub pub_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectPeerRequest {
    fn default() -> &'a DisconnectPeerRequest {
        <DisconnectPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectPeerRequest {
    pub fn new() -> DisconnectPeerRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisconnectPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectPeerRequest {
        DisconnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &DisconnectPeerRequest| { &m.pub_key },
                |m: &mut DisconnectPeerRequest| { &mut m.pub_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectPeerRequest>(
                "DisconnectPeerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectPeerRequest {
        static instance: ::protobuf::rt::LazyV2<DisconnectPeerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectPeerRequest::new)
    }
}

impl ::protobuf::Clear for DisconnectPeerRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DisconnectPeerResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectPeerResponse {
    fn default() -> &'a DisconnectPeerResponse {
        <DisconnectPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectPeerResponse {
    pub fn new() -> DisconnectPeerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectPeerResponse {
        DisconnectPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectPeerResponse>(
                "DisconnectPeerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectPeerResponse {
        static instance: ::protobuf::rt::LazyV2<DisconnectPeerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectPeerResponse::new)
    }
}

impl ::protobuf::Clear for DisconnectPeerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HTLC {
    // message fields
    pub incoming: bool,
    pub amount: i64,
    pub hash_lock: ::std::vec::Vec<u8>,
    pub expiration_height: u32,
    pub htlc_index: u64,
    pub forwarding_channel: u64,
    pub forwarding_htlc_index: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTLC {
    fn default() -> &'a HTLC {
        <HTLC as ::protobuf::Message>::default_instance()
    }
}

impl HTLC {
    pub fn new() -> HTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;


    pub fn get_incoming(&self) -> bool {
        self.incoming
    }
    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // bytes hash_lock = 3;


    pub fn get_hash_lock(&self) -> &[u8] {
        &self.hash_lock
    }
    pub fn clear_hash_lock(&mut self) {
        self.hash_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_lock
    }

    // Take field
    pub fn take_hash_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_lock, ::std::vec::Vec::new())
    }

    // uint32 expiration_height = 4;


    pub fn get_expiration_height(&self) -> u32 {
        self.expiration_height
    }
    pub fn clear_expiration_height(&mut self) {
        self.expiration_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_height(&mut self, v: u32) {
        self.expiration_height = v;
    }

    // uint64 htlc_index = 5;


    pub fn get_htlc_index(&self) -> u64 {
        self.htlc_index
    }
    pub fn clear_htlc_index(&mut self) {
        self.htlc_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_index(&mut self, v: u64) {
        self.htlc_index = v;
    }

    // uint64 forwarding_channel = 6;


    pub fn get_forwarding_channel(&self) -> u64 {
        self.forwarding_channel
    }
    pub fn clear_forwarding_channel(&mut self) {
        self.forwarding_channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_forwarding_channel(&mut self, v: u64) {
        self.forwarding_channel = v;
    }

    // uint64 forwarding_htlc_index = 7;


    pub fn get_forwarding_htlc_index(&self) -> u64 {
        self.forwarding_htlc_index
    }
    pub fn clear_forwarding_htlc_index(&mut self) {
        self.forwarding_htlc_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_forwarding_htlc_index(&mut self, v: u64) {
        self.forwarding_htlc_index = v;
    }
}

impl ::protobuf::Message for HTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash_lock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_index = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.forwarding_channel = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.forwarding_htlc_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash_lock);
        }
        if self.expiration_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.htlc_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.forwarding_channel != 0 {
            my_size += ::protobuf::rt::value_size(6, self.forwarding_channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.forwarding_htlc_index != 0 {
            my_size += ::protobuf::rt::value_size(7, self.forwarding_htlc_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if !self.hash_lock.is_empty() {
            os.write_bytes(3, &self.hash_lock)?;
        }
        if self.expiration_height != 0 {
            os.write_uint32(4, self.expiration_height)?;
        }
        if self.htlc_index != 0 {
            os.write_uint64(5, self.htlc_index)?;
        }
        if self.forwarding_channel != 0 {
            os.write_uint64(6, self.forwarding_channel)?;
        }
        if self.forwarding_htlc_index != 0 {
            os.write_uint64(7, self.forwarding_htlc_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTLC {
        HTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "incoming",
                |m: &HTLC| { &m.incoming },
                |m: &mut HTLC| { &mut m.incoming },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &HTLC| { &m.amount },
                |m: &mut HTLC| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash_lock",
                |m: &HTLC| { &m.hash_lock },
                |m: &mut HTLC| { &mut m.hash_lock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expiration_height",
                |m: &HTLC| { &m.expiration_height },
                |m: &mut HTLC| { &mut m.expiration_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "htlc_index",
                |m: &HTLC| { &m.htlc_index },
                |m: &mut HTLC| { &mut m.htlc_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "forwarding_channel",
                |m: &HTLC| { &m.forwarding_channel },
                |m: &mut HTLC| { &mut m.forwarding_channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "forwarding_htlc_index",
                |m: &HTLC| { &m.forwarding_htlc_index },
                |m: &mut HTLC| { &mut m.forwarding_htlc_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTLC>(
                "HTLC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTLC {
        static instance: ::protobuf::rt::LazyV2<HTLC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTLC::new)
    }
}

impl ::protobuf::Clear for HTLC {
    fn clear(&mut self) {
        self.incoming = false;
        self.amount = 0;
        self.hash_lock.clear();
        self.expiration_height = 0;
        self.htlc_index = 0;
        self.forwarding_channel = 0;
        self.forwarding_htlc_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelConstraints {
    // message fields
    pub csv_delay: u32,
    pub chan_reserve_sat: u64,
    pub dust_limit_sat: u64,
    pub max_pending_amt_msat: u64,
    pub min_htlc_msat: u64,
    pub max_accepted_htlcs: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelConstraints {
    fn default() -> &'a ChannelConstraints {
        <ChannelConstraints as ::protobuf::Message>::default_instance()
    }
}

impl ChannelConstraints {
    pub fn new() -> ChannelConstraints {
        ::std::default::Default::default()
    }

    // uint32 csv_delay = 1;


    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }
    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    // uint64 chan_reserve_sat = 2;


    pub fn get_chan_reserve_sat(&self) -> u64 {
        self.chan_reserve_sat
    }
    pub fn clear_chan_reserve_sat(&mut self) {
        self.chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_reserve_sat(&mut self, v: u64) {
        self.chan_reserve_sat = v;
    }

    // uint64 dust_limit_sat = 3;


    pub fn get_dust_limit_sat(&self) -> u64 {
        self.dust_limit_sat
    }
    pub fn clear_dust_limit_sat(&mut self) {
        self.dust_limit_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_dust_limit_sat(&mut self, v: u64) {
        self.dust_limit_sat = v;
    }

    // uint64 max_pending_amt_msat = 4;


    pub fn get_max_pending_amt_msat(&self) -> u64 {
        self.max_pending_amt_msat
    }
    pub fn clear_max_pending_amt_msat(&mut self) {
        self.max_pending_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_pending_amt_msat(&mut self, v: u64) {
        self.max_pending_amt_msat = v;
    }

    // uint64 min_htlc_msat = 5;


    pub fn get_min_htlc_msat(&self) -> u64 {
        self.min_htlc_msat
    }
    pub fn clear_min_htlc_msat(&mut self) {
        self.min_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_msat(&mut self, v: u64) {
        self.min_htlc_msat = v;
    }

    // uint32 max_accepted_htlcs = 6;


    pub fn get_max_accepted_htlcs(&self) -> u32 {
        self.max_accepted_htlcs
    }
    pub fn clear_max_accepted_htlcs(&mut self) {
        self.max_accepted_htlcs = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_accepted_htlcs(&mut self, v: u32) {
        self.max_accepted_htlcs = v;
    }
}

impl ::protobuf::Message for ChannelConstraints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_reserve_sat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dust_limit_sat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_pending_amt_msat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_htlc_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_accepted_htlcs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(1, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dust_limit_sat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dust_limit_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_pending_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_pending_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.min_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_accepted_htlcs != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_accepted_htlcs, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.csv_delay != 0 {
            os.write_uint32(1, self.csv_delay)?;
        }
        if self.chan_reserve_sat != 0 {
            os.write_uint64(2, self.chan_reserve_sat)?;
        }
        if self.dust_limit_sat != 0 {
            os.write_uint64(3, self.dust_limit_sat)?;
        }
        if self.max_pending_amt_msat != 0 {
            os.write_uint64(4, self.max_pending_amt_msat)?;
        }
        if self.min_htlc_msat != 0 {
            os.write_uint64(5, self.min_htlc_msat)?;
        }
        if self.max_accepted_htlcs != 0 {
            os.write_uint32(6, self.max_accepted_htlcs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelConstraints {
        ChannelConstraints::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "csv_delay",
                |m: &ChannelConstraints| { &m.csv_delay },
                |m: &mut ChannelConstraints| { &mut m.csv_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_reserve_sat",
                |m: &ChannelConstraints| { &m.chan_reserve_sat },
                |m: &mut ChannelConstraints| { &mut m.chan_reserve_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dust_limit_sat",
                |m: &ChannelConstraints| { &m.dust_limit_sat },
                |m: &mut ChannelConstraints| { &mut m.dust_limit_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_pending_amt_msat",
                |m: &ChannelConstraints| { &m.max_pending_amt_msat },
                |m: &mut ChannelConstraints| { &mut m.max_pending_amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "min_htlc_msat",
                |m: &ChannelConstraints| { &m.min_htlc_msat },
                |m: &mut ChannelConstraints| { &mut m.min_htlc_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_accepted_htlcs",
                |m: &ChannelConstraints| { &m.max_accepted_htlcs },
                |m: &mut ChannelConstraints| { &mut m.max_accepted_htlcs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelConstraints>(
                "ChannelConstraints",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelConstraints {
        static instance: ::protobuf::rt::LazyV2<ChannelConstraints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelConstraints::new)
    }
}

impl ::protobuf::Clear for ChannelConstraints {
    fn clear(&mut self) {
        self.csv_delay = 0;
        self.chan_reserve_sat = 0;
        self.dust_limit_sat = 0;
        self.max_pending_amt_msat = 0;
        self.min_htlc_msat = 0;
        self.max_accepted_htlcs = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelConstraints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelConstraints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Channel {
    // message fields
    pub active: bool,
    pub remote_pubkey: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub chan_id: u64,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    pub unsettled_balance: i64,
    pub total_satoshis_sent: i64,
    pub total_satoshis_received: i64,
    pub num_updates: u64,
    pub pending_htlcs: ::protobuf::RepeatedField<HTLC>,
    pub csv_delay: u32,
    pub private: bool,
    pub initiator: bool,
    pub chan_status_flags: ::std::string::String,
    pub local_chan_reserve_sat: i64,
    pub remote_chan_reserve_sat: i64,
    pub static_remote_key: bool,
    pub commitment_type: CommitmentType,
    pub lifetime: i64,
    pub uptime: i64,
    pub close_address: ::std::string::String,
    pub push_amount_sat: u64,
    pub thaw_height: u32,
    pub local_constraints: ::protobuf::SingularPtrField<ChannelConstraints>,
    pub remote_constraints: ::protobuf::SingularPtrField<ChannelConstraints>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel {
    fn default() -> &'a Channel {
        <Channel as ::protobuf::Message>::default_instance()
    }
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // bool active = 1;


    pub fn get_active(&self) -> bool {
        self.active
    }
    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }

    // string remote_pubkey = 2;


    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }
    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    // string channel_point = 3;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // uint64 chan_id = 4;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // int64 capacity = 5;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // int64 local_balance = 6;


    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }
    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    // int64 remote_balance = 7;


    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }
    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    // int64 commit_fee = 8;


    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }
    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    // int64 commit_weight = 9;


    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }
    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    // int64 fee_per_kw = 10;


    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }
    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }

    // int64 unsettled_balance = 11;


    pub fn get_unsettled_balance(&self) -> i64 {
        self.unsettled_balance
    }
    pub fn clear_unsettled_balance(&mut self) {
        self.unsettled_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unsettled_balance(&mut self, v: i64) {
        self.unsettled_balance = v;
    }

    // int64 total_satoshis_sent = 12;


    pub fn get_total_satoshis_sent(&self) -> i64 {
        self.total_satoshis_sent
    }
    pub fn clear_total_satoshis_sent(&mut self) {
        self.total_satoshis_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_satoshis_sent(&mut self, v: i64) {
        self.total_satoshis_sent = v;
    }

    // int64 total_satoshis_received = 13;


    pub fn get_total_satoshis_received(&self) -> i64 {
        self.total_satoshis_received
    }
    pub fn clear_total_satoshis_received(&mut self) {
        self.total_satoshis_received = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_satoshis_received(&mut self, v: i64) {
        self.total_satoshis_received = v;
    }

    // uint64 num_updates = 14;


    pub fn get_num_updates(&self) -> u64 {
        self.num_updates
    }
    pub fn clear_num_updates(&mut self) {
        self.num_updates = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_updates(&mut self, v: u64) {
        self.num_updates = v;
    }

    // repeated .lnrpc.HTLC pending_htlcs = 15;


    pub fn get_pending_htlcs(&self) -> &[HTLC] {
        &self.pending_htlcs
    }
    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<HTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<HTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<HTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    // uint32 csv_delay = 16;


    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }
    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    // bool private = 17;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    // bool initiator = 18;


    pub fn get_initiator(&self) -> bool {
        self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator = false;
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: bool) {
        self.initiator = v;
    }

    // string chan_status_flags = 19;


    pub fn get_chan_status_flags(&self) -> &str {
        &self.chan_status_flags
    }
    pub fn clear_chan_status_flags(&mut self) {
        self.chan_status_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_status_flags(&mut self, v: ::std::string::String) {
        self.chan_status_flags = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_status_flags(&mut self) -> &mut ::std::string::String {
        &mut self.chan_status_flags
    }

    // Take field
    pub fn take_chan_status_flags(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_status_flags, ::std::string::String::new())
    }

    // int64 local_chan_reserve_sat = 20;


    pub fn get_local_chan_reserve_sat(&self) -> i64 {
        self.local_chan_reserve_sat
    }
    pub fn clear_local_chan_reserve_sat(&mut self) {
        self.local_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_chan_reserve_sat(&mut self, v: i64) {
        self.local_chan_reserve_sat = v;
    }

    // int64 remote_chan_reserve_sat = 21;


    pub fn get_remote_chan_reserve_sat(&self) -> i64 {
        self.remote_chan_reserve_sat
    }
    pub fn clear_remote_chan_reserve_sat(&mut self) {
        self.remote_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_chan_reserve_sat(&mut self, v: i64) {
        self.remote_chan_reserve_sat = v;
    }

    // bool static_remote_key = 22;


    pub fn get_static_remote_key(&self) -> bool {
        self.static_remote_key
    }
    pub fn clear_static_remote_key(&mut self) {
        self.static_remote_key = false;
    }

    // Param is passed by value, moved
    pub fn set_static_remote_key(&mut self, v: bool) {
        self.static_remote_key = v;
    }

    // .lnrpc.CommitmentType commitment_type = 26;


    pub fn get_commitment_type(&self) -> CommitmentType {
        self.commitment_type
    }
    pub fn clear_commitment_type(&mut self) {
        self.commitment_type = CommitmentType::LEGACY;
    }

    // Param is passed by value, moved
    pub fn set_commitment_type(&mut self, v: CommitmentType) {
        self.commitment_type = v;
    }

    // int64 lifetime = 23;


    pub fn get_lifetime(&self) -> i64 {
        self.lifetime
    }
    pub fn clear_lifetime(&mut self) {
        self.lifetime = 0;
    }

    // Param is passed by value, moved
    pub fn set_lifetime(&mut self, v: i64) {
        self.lifetime = v;
    }

    // int64 uptime = 24;


    pub fn get_uptime(&self) -> i64 {
        self.uptime
    }
    pub fn clear_uptime(&mut self) {
        self.uptime = 0;
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: i64) {
        self.uptime = v;
    }

    // string close_address = 25;


    pub fn get_close_address(&self) -> &str {
        &self.close_address
    }
    pub fn clear_close_address(&mut self) {
        self.close_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_close_address(&mut self, v: ::std::string::String) {
        self.close_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_address(&mut self) -> &mut ::std::string::String {
        &mut self.close_address
    }

    // Take field
    pub fn take_close_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.close_address, ::std::string::String::new())
    }

    // uint64 push_amount_sat = 27;


    pub fn get_push_amount_sat(&self) -> u64 {
        self.push_amount_sat
    }
    pub fn clear_push_amount_sat(&mut self) {
        self.push_amount_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_push_amount_sat(&mut self, v: u64) {
        self.push_amount_sat = v;
    }

    // uint32 thaw_height = 28;


    pub fn get_thaw_height(&self) -> u32 {
        self.thaw_height
    }
    pub fn clear_thaw_height(&mut self) {
        self.thaw_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_thaw_height(&mut self, v: u32) {
        self.thaw_height = v;
    }

    // .lnrpc.ChannelConstraints local_constraints = 29;


    pub fn get_local_constraints(&self) -> &ChannelConstraints {
        self.local_constraints.as_ref().unwrap_or_else(|| <ChannelConstraints as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local_constraints(&mut self) {
        self.local_constraints.clear();
    }

    pub fn has_local_constraints(&self) -> bool {
        self.local_constraints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_constraints(&mut self, v: ChannelConstraints) {
        self.local_constraints = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_constraints(&mut self) -> &mut ChannelConstraints {
        if self.local_constraints.is_none() {
            self.local_constraints.set_default();
        }
        self.local_constraints.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_constraints(&mut self) -> ChannelConstraints {
        self.local_constraints.take().unwrap_or_else(|| ChannelConstraints::new())
    }

    // .lnrpc.ChannelConstraints remote_constraints = 30;


    pub fn get_remote_constraints(&self) -> &ChannelConstraints {
        self.remote_constraints.as_ref().unwrap_or_else(|| <ChannelConstraints as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remote_constraints(&mut self) {
        self.remote_constraints.clear();
    }

    pub fn has_remote_constraints(&self) -> bool {
        self.remote_constraints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_constraints(&mut self, v: ChannelConstraints) {
        self.remote_constraints = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_constraints(&mut self) -> &mut ChannelConstraints {
        if self.remote_constraints.is_none() {
            self.remote_constraints.set_default();
        }
        self.remote_constraints.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_constraints(&mut self) -> ChannelConstraints {
        self.remote_constraints.take().unwrap_or_else(|| ChannelConstraints::new())
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_constraints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_constraints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unsettled_balance = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_satoshis_sent = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_satoshis_received = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_updates = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.initiator = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_status_flags)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_chan_reserve_sat = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_chan_reserve_sat = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.static_remote_key = tmp;
                },
                26 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.commitment_type, 26, &mut self.unknown_fields)?
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lifetime = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.uptime = tmp;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.close_address)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.push_amount_sat = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.thaw_height = tmp;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_constraints)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_constraints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active != false {
            my_size += 2;
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.remote_pubkey);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.channel_point);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(7, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(8, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(9, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(10, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unsettled_balance != 0 {
            my_size += ::protobuf::rt::value_size(11, self.unsettled_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_satoshis_sent != 0 {
            my_size += ::protobuf::rt::value_size(12, self.total_satoshis_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_satoshis_received != 0 {
            my_size += ::protobuf::rt::value_size(13, self.total_satoshis_received, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_updates != 0 {
            my_size += ::protobuf::rt::value_size(14, self.num_updates, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(16, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 3;
        }
        if self.initiator != false {
            my_size += 3;
        }
        if !self.chan_status_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.chan_status_flags);
        }
        if self.local_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(20, self.local_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(21, self.remote_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.static_remote_key != false {
            my_size += 3;
        }
        if self.commitment_type != CommitmentType::LEGACY {
            my_size += ::protobuf::rt::enum_size(26, self.commitment_type);
        }
        if self.lifetime != 0 {
            my_size += ::protobuf::rt::value_size(23, self.lifetime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uptime != 0 {
            my_size += ::protobuf::rt::value_size(24, self.uptime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.close_address.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.close_address);
        }
        if self.push_amount_sat != 0 {
            my_size += ::protobuf::rt::value_size(27, self.push_amount_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.thaw_height != 0 {
            my_size += ::protobuf::rt::value_size(28, self.thaw_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.local_constraints.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_constraints.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.active != false {
            os.write_bool(1, self.active)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(2, &self.remote_pubkey)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(3, &self.channel_point)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(4, self.chan_id)?;
        }
        if self.capacity != 0 {
            os.write_int64(5, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(6, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(7, self.remote_balance)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(8, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(9, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(10, self.fee_per_kw)?;
        }
        if self.unsettled_balance != 0 {
            os.write_int64(11, self.unsettled_balance)?;
        }
        if self.total_satoshis_sent != 0 {
            os.write_int64(12, self.total_satoshis_sent)?;
        }
        if self.total_satoshis_received != 0 {
            os.write_int64(13, self.total_satoshis_received)?;
        }
        if self.num_updates != 0 {
            os.write_uint64(14, self.num_updates)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.csv_delay != 0 {
            os.write_uint32(16, self.csv_delay)?;
        }
        if self.private != false {
            os.write_bool(17, self.private)?;
        }
        if self.initiator != false {
            os.write_bool(18, self.initiator)?;
        }
        if !self.chan_status_flags.is_empty() {
            os.write_string(19, &self.chan_status_flags)?;
        }
        if self.local_chan_reserve_sat != 0 {
            os.write_int64(20, self.local_chan_reserve_sat)?;
        }
        if self.remote_chan_reserve_sat != 0 {
            os.write_int64(21, self.remote_chan_reserve_sat)?;
        }
        if self.static_remote_key != false {
            os.write_bool(22, self.static_remote_key)?;
        }
        if self.commitment_type != CommitmentType::LEGACY {
            os.write_enum(26, ::protobuf::ProtobufEnum::value(&self.commitment_type))?;
        }
        if self.lifetime != 0 {
            os.write_int64(23, self.lifetime)?;
        }
        if self.uptime != 0 {
            os.write_int64(24, self.uptime)?;
        }
        if !self.close_address.is_empty() {
            os.write_string(25, &self.close_address)?;
        }
        if self.push_amount_sat != 0 {
            os.write_uint64(27, self.push_amount_sat)?;
        }
        if self.thaw_height != 0 {
            os.write_uint32(28, self.thaw_height)?;
        }
        if let Some(ref v) = self.local_constraints.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_constraints.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &Channel| { &m.active },
                |m: &mut Channel| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_pubkey",
                |m: &Channel| { &m.remote_pubkey },
                |m: &mut Channel| { &mut m.remote_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_point",
                |m: &Channel| { &m.channel_point },
                |m: &mut Channel| { &mut m.channel_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &Channel| { &m.chan_id },
                |m: &mut Channel| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "capacity",
                |m: &Channel| { &m.capacity },
                |m: &mut Channel| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "local_balance",
                |m: &Channel| { &m.local_balance },
                |m: &mut Channel| { &mut m.local_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remote_balance",
                |m: &Channel| { &m.remote_balance },
                |m: &mut Channel| { &mut m.remote_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commit_fee",
                |m: &Channel| { &m.commit_fee },
                |m: &mut Channel| { &mut m.commit_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commit_weight",
                |m: &Channel| { &m.commit_weight },
                |m: &mut Channel| { &mut m.commit_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_per_kw",
                |m: &Channel| { &m.fee_per_kw },
                |m: &mut Channel| { &mut m.fee_per_kw },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unsettled_balance",
                |m: &Channel| { &m.unsettled_balance },
                |m: &mut Channel| { &mut m.unsettled_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_satoshis_sent",
                |m: &Channel| { &m.total_satoshis_sent },
                |m: &mut Channel| { &mut m.total_satoshis_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_satoshis_received",
                |m: &Channel| { &m.total_satoshis_received },
                |m: &mut Channel| { &mut m.total_satoshis_received },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_updates",
                |m: &Channel| { &m.num_updates },
                |m: &mut Channel| { &mut m.num_updates },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTLC>>(
                "pending_htlcs",
                |m: &Channel| { &m.pending_htlcs },
                |m: &mut Channel| { &mut m.pending_htlcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "csv_delay",
                |m: &Channel| { &m.csv_delay },
                |m: &mut Channel| { &mut m.csv_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "private",
                |m: &Channel| { &m.private },
                |m: &mut Channel| { &mut m.private },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "initiator",
                |m: &Channel| { &m.initiator },
                |m: &mut Channel| { &mut m.initiator },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chan_status_flags",
                |m: &Channel| { &m.chan_status_flags },
                |m: &mut Channel| { &mut m.chan_status_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "local_chan_reserve_sat",
                |m: &Channel| { &m.local_chan_reserve_sat },
                |m: &mut Channel| { &mut m.local_chan_reserve_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remote_chan_reserve_sat",
                |m: &Channel| { &m.remote_chan_reserve_sat },
                |m: &mut Channel| { &mut m.remote_chan_reserve_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "static_remote_key",
                |m: &Channel| { &m.static_remote_key },
                |m: &mut Channel| { &mut m.static_remote_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommitmentType>>(
                "commitment_type",
                |m: &Channel| { &m.commitment_type },
                |m: &mut Channel| { &mut m.commitment_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lifetime",
                |m: &Channel| { &m.lifetime },
                |m: &mut Channel| { &mut m.lifetime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "uptime",
                |m: &Channel| { &m.uptime },
                |m: &mut Channel| { &mut m.uptime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "close_address",
                |m: &Channel| { &m.close_address },
                |m: &mut Channel| { &mut m.close_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "push_amount_sat",
                |m: &Channel| { &m.push_amount_sat },
                |m: &mut Channel| { &mut m.push_amount_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "thaw_height",
                |m: &Channel| { &m.thaw_height },
                |m: &mut Channel| { &mut m.thaw_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelConstraints>>(
                "local_constraints",
                |m: &Channel| { &m.local_constraints },
                |m: &mut Channel| { &mut m.local_constraints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelConstraints>>(
                "remote_constraints",
                |m: &Channel| { &m.remote_constraints },
                |m: &mut Channel| { &mut m.remote_constraints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Channel>(
                "Channel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Channel {
        static instance: ::protobuf::rt::LazyV2<Channel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Channel::new)
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.active = false;
        self.remote_pubkey.clear();
        self.channel_point.clear();
        self.chan_id = 0;
        self.capacity = 0;
        self.local_balance = 0;
        self.remote_balance = 0;
        self.commit_fee = 0;
        self.commit_weight = 0;
        self.fee_per_kw = 0;
        self.unsettled_balance = 0;
        self.total_satoshis_sent = 0;
        self.total_satoshis_received = 0;
        self.num_updates = 0;
        self.pending_htlcs.clear();
        self.csv_delay = 0;
        self.private = false;
        self.initiator = false;
        self.chan_status_flags.clear();
        self.local_chan_reserve_sat = 0;
        self.remote_chan_reserve_sat = 0;
        self.static_remote_key = false;
        self.commitment_type = CommitmentType::LEGACY;
        self.lifetime = 0;
        self.uptime = 0;
        self.close_address.clear();
        self.push_amount_sat = 0;
        self.thaw_height = 0;
        self.local_constraints.clear();
        self.remote_constraints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListChannelsRequest {
    // message fields
    pub active_only: bool,
    pub inactive_only: bool,
    pub public_only: bool,
    pub private_only: bool,
    pub peer: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsRequest {
    fn default() -> &'a ListChannelsRequest {
        <ListChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsRequest {
    pub fn new() -> ListChannelsRequest {
        ::std::default::Default::default()
    }

    // bool active_only = 1;


    pub fn get_active_only(&self) -> bool {
        self.active_only
    }
    pub fn clear_active_only(&mut self) {
        self.active_only = false;
    }

    // Param is passed by value, moved
    pub fn set_active_only(&mut self, v: bool) {
        self.active_only = v;
    }

    // bool inactive_only = 2;


    pub fn get_inactive_only(&self) -> bool {
        self.inactive_only
    }
    pub fn clear_inactive_only(&mut self) {
        self.inactive_only = false;
    }

    // Param is passed by value, moved
    pub fn set_inactive_only(&mut self, v: bool) {
        self.inactive_only = v;
    }

    // bool public_only = 3;


    pub fn get_public_only(&self) -> bool {
        self.public_only
    }
    pub fn clear_public_only(&mut self) {
        self.public_only = false;
    }

    // Param is passed by value, moved
    pub fn set_public_only(&mut self, v: bool) {
        self.public_only = v;
    }

    // bool private_only = 4;


    pub fn get_private_only(&self) -> bool {
        self.private_only
    }
    pub fn clear_private_only(&mut self) {
        self.private_only = false;
    }

    // Param is passed by value, moved
    pub fn set_private_only(&mut self, v: bool) {
        self.private_only = v;
    }

    // bytes peer = 5;


    pub fn get_peer(&self) -> &[u8] {
        &self.peer
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: ::std::vec::Vec<u8>) {
        self.peer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.peer
    }

    // Take field
    pub fn take_peer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.peer, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active_only = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inactive_only = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.public_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private_only = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.peer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active_only != false {
            my_size += 2;
        }
        if self.inactive_only != false {
            my_size += 2;
        }
        if self.public_only != false {
            my_size += 2;
        }
        if self.private_only != false {
            my_size += 2;
        }
        if !self.peer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.peer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.active_only != false {
            os.write_bool(1, self.active_only)?;
        }
        if self.inactive_only != false {
            os.write_bool(2, self.inactive_only)?;
        }
        if self.public_only != false {
            os.write_bool(3, self.public_only)?;
        }
        if self.private_only != false {
            os.write_bool(4, self.private_only)?;
        }
        if !self.peer.is_empty() {
            os.write_bytes(5, &self.peer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsRequest {
        ListChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active_only",
                |m: &ListChannelsRequest| { &m.active_only },
                |m: &mut ListChannelsRequest| { &mut m.active_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inactive_only",
                |m: &ListChannelsRequest| { &m.inactive_only },
                |m: &mut ListChannelsRequest| { &mut m.inactive_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "public_only",
                |m: &ListChannelsRequest| { &m.public_only },
                |m: &mut ListChannelsRequest| { &mut m.public_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "private_only",
                |m: &ListChannelsRequest| { &m.private_only },
                |m: &mut ListChannelsRequest| { &mut m.private_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "peer",
                |m: &ListChannelsRequest| { &m.peer },
                |m: &mut ListChannelsRequest| { &mut m.peer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListChannelsRequest>(
                "ListChannelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListChannelsRequest {
        static instance: ::protobuf::rt::LazyV2<ListChannelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListChannelsRequest::new)
    }
}

impl ::protobuf::Clear for ListChannelsRequest {
    fn clear(&mut self) {
        self.active_only = false;
        self.inactive_only = false;
        self.public_only = false;
        self.private_only = false;
        self.peer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<Channel>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsResponse {
    fn default() -> &'a ListChannelsResponse {
        <ListChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsResponse {
    pub fn new() -> ListChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Channel channels = 11;


    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsResponse {
        ListChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channels",
                |m: &ListChannelsResponse| { &m.channels },
                |m: &mut ListChannelsResponse| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListChannelsResponse>(
                "ListChannelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListChannelsResponse {
        static instance: ::protobuf::rt::LazyV2<ListChannelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListChannelsResponse::new)
    }
}

impl ::protobuf::Clear for ListChannelsResponse {
    fn clear(&mut self) {
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelCloseSummary {
    // message fields
    pub channel_point: ::std::string::String,
    pub chan_id: u64,
    pub chain_hash: ::std::string::String,
    pub closing_tx_hash: ::std::string::String,
    pub remote_pubkey: ::std::string::String,
    pub capacity: i64,
    pub close_height: u32,
    pub settled_balance: i64,
    pub time_locked_balance: i64,
    pub close_type: ChannelCloseSummary_ClosureType,
    pub open_initiator: Initiator,
    pub close_initiator: Initiator,
    pub resolutions: ::protobuf::RepeatedField<Resolution>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelCloseSummary {
    fn default() -> &'a ChannelCloseSummary {
        <ChannelCloseSummary as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCloseSummary {
    pub fn new() -> ChannelCloseSummary {
        ::std::default::Default::default()
    }

    // string channel_point = 1;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // uint64 chan_id = 2;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // string chain_hash = 3;


    pub fn get_chain_hash(&self) -> &str {
        &self.chain_hash
    }
    pub fn clear_chain_hash(&mut self) {
        self.chain_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hash(&mut self, v: ::std::string::String) {
        self.chain_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hash(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hash
    }

    // Take field
    pub fn take_chain_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hash, ::std::string::String::new())
    }

    // string closing_tx_hash = 4;


    pub fn get_closing_tx_hash(&self) -> &str {
        &self.closing_tx_hash
    }
    pub fn clear_closing_tx_hash(&mut self) {
        self.closing_tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_tx_hash(&mut self, v: ::std::string::String) {
        self.closing_tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.closing_tx_hash
    }

    // Take field
    pub fn take_closing_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_tx_hash, ::std::string::String::new())
    }

    // string remote_pubkey = 5;


    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }
    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    // int64 capacity = 6;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // uint32 close_height = 7;


    pub fn get_close_height(&self) -> u32 {
        self.close_height
    }
    pub fn clear_close_height(&mut self) {
        self.close_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_close_height(&mut self, v: u32) {
        self.close_height = v;
    }

    // int64 settled_balance = 8;


    pub fn get_settled_balance(&self) -> i64 {
        self.settled_balance
    }
    pub fn clear_settled_balance(&mut self) {
        self.settled_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_settled_balance(&mut self, v: i64) {
        self.settled_balance = v;
    }

    // int64 time_locked_balance = 9;


    pub fn get_time_locked_balance(&self) -> i64 {
        self.time_locked_balance
    }
    pub fn clear_time_locked_balance(&mut self) {
        self.time_locked_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_locked_balance(&mut self, v: i64) {
        self.time_locked_balance = v;
    }

    // .lnrpc.ChannelCloseSummary.ClosureType close_type = 10;


    pub fn get_close_type(&self) -> ChannelCloseSummary_ClosureType {
        self.close_type
    }
    pub fn clear_close_type(&mut self) {
        self.close_type = ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_close_type(&mut self, v: ChannelCloseSummary_ClosureType) {
        self.close_type = v;
    }

    // .lnrpc.Initiator open_initiator = 11;


    pub fn get_open_initiator(&self) -> Initiator {
        self.open_initiator
    }
    pub fn clear_open_initiator(&mut self) {
        self.open_initiator = Initiator::INITIATOR_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_open_initiator(&mut self, v: Initiator) {
        self.open_initiator = v;
    }

    // .lnrpc.Initiator close_initiator = 12;


    pub fn get_close_initiator(&self) -> Initiator {
        self.close_initiator
    }
    pub fn clear_close_initiator(&mut self) {
        self.close_initiator = Initiator::INITIATOR_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_close_initiator(&mut self, v: Initiator) {
        self.close_initiator = v;
    }

    // repeated .lnrpc.Resolution resolutions = 13;


    pub fn get_resolutions(&self) -> &[Resolution] {
        &self.resolutions
    }
    pub fn clear_resolutions(&mut self) {
        self.resolutions.clear();
    }

    // Param is passed by value, moved
    pub fn set_resolutions(&mut self, v: ::protobuf::RepeatedField<Resolution>) {
        self.resolutions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resolutions(&mut self) -> &mut ::protobuf::RepeatedField<Resolution> {
        &mut self.resolutions
    }

    // Take field
    pub fn take_resolutions(&mut self) -> ::protobuf::RepeatedField<Resolution> {
        ::std::mem::replace(&mut self.resolutions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelCloseSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.resolutions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_tx_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.close_height = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settled_balance = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_locked_balance = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.close_type, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.open_initiator, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.close_initiator, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resolutions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_point);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chain_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.chain_hash);
        }
        if !self.closing_tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.closing_tx_hash);
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.remote_pubkey);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.close_height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.close_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settled_balance != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settled_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_locked_balance != 0 {
            my_size += ::protobuf::rt::value_size(9, self.time_locked_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.close_type != ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE {
            my_size += ::protobuf::rt::enum_size(10, self.close_type);
        }
        if self.open_initiator != Initiator::INITIATOR_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(11, self.open_initiator);
        }
        if self.close_initiator != Initiator::INITIATOR_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(12, self.close_initiator);
        }
        for value in &self.resolutions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_point.is_empty() {
            os.write_string(1, &self.channel_point)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if !self.chain_hash.is_empty() {
            os.write_string(3, &self.chain_hash)?;
        }
        if !self.closing_tx_hash.is_empty() {
            os.write_string(4, &self.closing_tx_hash)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(5, &self.remote_pubkey)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if self.close_height != 0 {
            os.write_uint32(7, self.close_height)?;
        }
        if self.settled_balance != 0 {
            os.write_int64(8, self.settled_balance)?;
        }
        if self.time_locked_balance != 0 {
            os.write_int64(9, self.time_locked_balance)?;
        }
        if self.close_type != ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.close_type))?;
        }
        if self.open_initiator != Initiator::INITIATOR_UNKNOWN {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.open_initiator))?;
        }
        if self.close_initiator != Initiator::INITIATOR_UNKNOWN {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.close_initiator))?;
        }
        for v in &self.resolutions {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseSummary {
        ChannelCloseSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_point",
                |m: &ChannelCloseSummary| { &m.channel_point },
                |m: &mut ChannelCloseSummary| { &mut m.channel_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &ChannelCloseSummary| { &m.chan_id },
                |m: &mut ChannelCloseSummary| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_hash",
                |m: &ChannelCloseSummary| { &m.chain_hash },
                |m: &mut ChannelCloseSummary| { &mut m.chain_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "closing_tx_hash",
                |m: &ChannelCloseSummary| { &m.closing_tx_hash },
                |m: &mut ChannelCloseSummary| { &mut m.closing_tx_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_pubkey",
                |m: &ChannelCloseSummary| { &m.remote_pubkey },
                |m: &mut ChannelCloseSummary| { &mut m.remote_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "capacity",
                |m: &ChannelCloseSummary| { &m.capacity },
                |m: &mut ChannelCloseSummary| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "close_height",
                |m: &ChannelCloseSummary| { &m.close_height },
                |m: &mut ChannelCloseSummary| { &mut m.close_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "settled_balance",
                |m: &ChannelCloseSummary| { &m.settled_balance },
                |m: &mut ChannelCloseSummary| { &mut m.settled_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "time_locked_balance",
                |m: &ChannelCloseSummary| { &m.time_locked_balance },
                |m: &mut ChannelCloseSummary| { &mut m.time_locked_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelCloseSummary_ClosureType>>(
                "close_type",
                |m: &ChannelCloseSummary| { &m.close_type },
                |m: &mut ChannelCloseSummary| { &mut m.close_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Initiator>>(
                "open_initiator",
                |m: &ChannelCloseSummary| { &m.open_initiator },
                |m: &mut ChannelCloseSummary| { &mut m.open_initiator },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Initiator>>(
                "close_initiator",
                |m: &ChannelCloseSummary| { &m.close_initiator },
                |m: &mut ChannelCloseSummary| { &mut m.close_initiator },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resolution>>(
                "resolutions",
                |m: &ChannelCloseSummary| { &m.resolutions },
                |m: &mut ChannelCloseSummary| { &mut m.resolutions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelCloseSummary>(
                "ChannelCloseSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelCloseSummary {
        static instance: ::protobuf::rt::LazyV2<ChannelCloseSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelCloseSummary::new)
    }
}

impl ::protobuf::Clear for ChannelCloseSummary {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.chan_id = 0;
        self.chain_hash.clear();
        self.closing_tx_hash.clear();
        self.remote_pubkey.clear();
        self.capacity = 0;
        self.close_height = 0;
        self.settled_balance = 0;
        self.time_locked_balance = 0;
        self.close_type = ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE;
        self.open_initiator = Initiator::INITIATOR_UNKNOWN;
        self.close_initiator = Initiator::INITIATOR_UNKNOWN;
        self.resolutions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ChannelCloseSummary_ClosureType {
    COOPERATIVE_CLOSE = 0,
    LOCAL_FORCE_CLOSE = 1,
    REMOTE_FORCE_CLOSE = 2,
    BREACH_CLOSE = 3,
    FUNDING_CANCELED = 4,
    ABANDONED = 5,
}

impl ::protobuf::ProtobufEnum for ChannelCloseSummary_ClosureType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelCloseSummary_ClosureType> {
        match value {
            0 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE),
            1 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::LOCAL_FORCE_CLOSE),
            2 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::REMOTE_FORCE_CLOSE),
            3 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::BREACH_CLOSE),
            4 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::FUNDING_CANCELED),
            5 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::ABANDONED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelCloseSummary_ClosureType] = &[
            ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE,
            ChannelCloseSummary_ClosureType::LOCAL_FORCE_CLOSE,
            ChannelCloseSummary_ClosureType::REMOTE_FORCE_CLOSE,
            ChannelCloseSummary_ClosureType::BREACH_CLOSE,
            ChannelCloseSummary_ClosureType::FUNDING_CANCELED,
            ChannelCloseSummary_ClosureType::ABANDONED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChannelCloseSummary_ClosureType>("ChannelCloseSummary.ClosureType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChannelCloseSummary_ClosureType {
}

impl ::std::default::Default for ChannelCloseSummary_ClosureType {
    fn default() -> Self {
        ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseSummary_ClosureType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Resolution {
    // message fields
    pub resolution_type: ResolutionType,
    pub outcome: ResolutionOutcome,
    pub outpoint: ::protobuf::SingularPtrField<OutPoint>,
    pub amount_sat: u64,
    pub sweep_txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Resolution {
    fn default() -> &'a Resolution {
        <Resolution as ::protobuf::Message>::default_instance()
    }
}

impl Resolution {
    pub fn new() -> Resolution {
        ::std::default::Default::default()
    }

    // .lnrpc.ResolutionType resolution_type = 1;


    pub fn get_resolution_type(&self) -> ResolutionType {
        self.resolution_type
    }
    pub fn clear_resolution_type(&mut self) {
        self.resolution_type = ResolutionType::TYPE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_resolution_type(&mut self, v: ResolutionType) {
        self.resolution_type = v;
    }

    // .lnrpc.ResolutionOutcome outcome = 2;


    pub fn get_outcome(&self) -> ResolutionOutcome {
        self.outcome
    }
    pub fn clear_outcome(&mut self) {
        self.outcome = ResolutionOutcome::OUTCOME_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_outcome(&mut self, v: ResolutionOutcome) {
        self.outcome = v;
    }

    // .lnrpc.OutPoint outpoint = 3;


    pub fn get_outpoint(&self) -> &OutPoint {
        self.outpoint.as_ref().unwrap_or_else(|| <OutPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    pub fn has_outpoint(&self) -> bool {
        self.outpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: OutPoint) {
        self.outpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut OutPoint {
        if self.outpoint.is_none() {
            self.outpoint.set_default();
        }
        self.outpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_outpoint(&mut self) -> OutPoint {
        self.outpoint.take().unwrap_or_else(|| OutPoint::new())
    }

    // uint64 amount_sat = 4;


    pub fn get_amount_sat(&self) -> u64 {
        self.amount_sat
    }
    pub fn clear_amount_sat(&mut self) {
        self.amount_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount_sat(&mut self, v: u64) {
        self.amount_sat = v;
    }

    // string sweep_txid = 5;


    pub fn get_sweep_txid(&self) -> &str {
        &self.sweep_txid
    }
    pub fn clear_sweep_txid(&mut self) {
        self.sweep_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_sweep_txid(&mut self, v: ::std::string::String) {
        self.sweep_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sweep_txid(&mut self) -> &mut ::std::string::String {
        &mut self.sweep_txid
    }

    // Take field
    pub fn take_sweep_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sweep_txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Resolution {
    fn is_initialized(&self) -> bool {
        for v in &self.outpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.resolution_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.outcome, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount_sat = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sweep_txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.resolution_type != ResolutionType::TYPE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.resolution_type);
        }
        if self.outcome != ResolutionOutcome::OUTCOME_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.outcome);
        }
        if let Some(ref v) = self.outpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.amount_sat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sweep_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sweep_txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.resolution_type != ResolutionType::TYPE_UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.resolution_type))?;
        }
        if self.outcome != ResolutionOutcome::OUTCOME_UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.outcome))?;
        }
        if let Some(ref v) = self.outpoint.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.amount_sat != 0 {
            os.write_uint64(4, self.amount_sat)?;
        }
        if !self.sweep_txid.is_empty() {
            os.write_string(5, &self.sweep_txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Resolution {
        Resolution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResolutionType>>(
                "resolution_type",
                |m: &Resolution| { &m.resolution_type },
                |m: &mut Resolution| { &mut m.resolution_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResolutionOutcome>>(
                "outcome",
                |m: &Resolution| { &m.outcome },
                |m: &mut Resolution| { &mut m.outcome },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutPoint>>(
                "outpoint",
                |m: &Resolution| { &m.outpoint },
                |m: &mut Resolution| { &mut m.outpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amount_sat",
                |m: &Resolution| { &m.amount_sat },
                |m: &mut Resolution| { &mut m.amount_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sweep_txid",
                |m: &Resolution| { &m.sweep_txid },
                |m: &mut Resolution| { &mut m.sweep_txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Resolution>(
                "Resolution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Resolution {
        static instance: ::protobuf::rt::LazyV2<Resolution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Resolution::new)
    }
}

impl ::protobuf::Clear for Resolution {
    fn clear(&mut self) {
        self.resolution_type = ResolutionType::TYPE_UNKNOWN;
        self.outcome = ResolutionOutcome::OUTCOME_UNKNOWN;
        self.outpoint.clear();
        self.amount_sat = 0;
        self.sweep_txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resolution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resolution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClosedChannelsRequest {
    // message fields
    pub cooperative: bool,
    pub local_force: bool,
    pub remote_force: bool,
    pub breach: bool,
    pub funding_canceled: bool,
    pub abandoned: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedChannelsRequest {
    fn default() -> &'a ClosedChannelsRequest {
        <ClosedChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClosedChannelsRequest {
    pub fn new() -> ClosedChannelsRequest {
        ::std::default::Default::default()
    }

    // bool cooperative = 1;


    pub fn get_cooperative(&self) -> bool {
        self.cooperative
    }
    pub fn clear_cooperative(&mut self) {
        self.cooperative = false;
    }

    // Param is passed by value, moved
    pub fn set_cooperative(&mut self, v: bool) {
        self.cooperative = v;
    }

    // bool local_force = 2;


    pub fn get_local_force(&self) -> bool {
        self.local_force
    }
    pub fn clear_local_force(&mut self) {
        self.local_force = false;
    }

    // Param is passed by value, moved
    pub fn set_local_force(&mut self, v: bool) {
        self.local_force = v;
    }

    // bool remote_force = 3;


    pub fn get_remote_force(&self) -> bool {
        self.remote_force
    }
    pub fn clear_remote_force(&mut self) {
        self.remote_force = false;
    }

    // Param is passed by value, moved
    pub fn set_remote_force(&mut self, v: bool) {
        self.remote_force = v;
    }

    // bool breach = 4;


    pub fn get_breach(&self) -> bool {
        self.breach
    }
    pub fn clear_breach(&mut self) {
        self.breach = false;
    }

    // Param is passed by value, moved
    pub fn set_breach(&mut self, v: bool) {
        self.breach = v;
    }

    // bool funding_canceled = 5;


    pub fn get_funding_canceled(&self) -> bool {
        self.funding_canceled
    }
    pub fn clear_funding_canceled(&mut self) {
        self.funding_canceled = false;
    }

    // Param is passed by value, moved
    pub fn set_funding_canceled(&mut self, v: bool) {
        self.funding_canceled = v;
    }

    // bool abandoned = 6;


    pub fn get_abandoned(&self) -> bool {
        self.abandoned
    }
    pub fn clear_abandoned(&mut self) {
        self.abandoned = false;
    }

    // Param is passed by value, moved
    pub fn set_abandoned(&mut self, v: bool) {
        self.abandoned = v;
    }
}

impl ::protobuf::Message for ClosedChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cooperative = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local_force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remote_force = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.breach = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.funding_canceled = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.abandoned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cooperative != false {
            my_size += 2;
        }
        if self.local_force != false {
            my_size += 2;
        }
        if self.remote_force != false {
            my_size += 2;
        }
        if self.breach != false {
            my_size += 2;
        }
        if self.funding_canceled != false {
            my_size += 2;
        }
        if self.abandoned != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cooperative != false {
            os.write_bool(1, self.cooperative)?;
        }
        if self.local_force != false {
            os.write_bool(2, self.local_force)?;
        }
        if self.remote_force != false {
            os.write_bool(3, self.remote_force)?;
        }
        if self.breach != false {
            os.write_bool(4, self.breach)?;
        }
        if self.funding_canceled != false {
            os.write_bool(5, self.funding_canceled)?;
        }
        if self.abandoned != false {
            os.write_bool(6, self.abandoned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelsRequest {
        ClosedChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cooperative",
                |m: &ClosedChannelsRequest| { &m.cooperative },
                |m: &mut ClosedChannelsRequest| { &mut m.cooperative },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local_force",
                |m: &ClosedChannelsRequest| { &m.local_force },
                |m: &mut ClosedChannelsRequest| { &mut m.local_force },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remote_force",
                |m: &ClosedChannelsRequest| { &m.remote_force },
                |m: &mut ClosedChannelsRequest| { &mut m.remote_force },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "breach",
                |m: &ClosedChannelsRequest| { &m.breach },
                |m: &mut ClosedChannelsRequest| { &mut m.breach },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "funding_canceled",
                |m: &ClosedChannelsRequest| { &m.funding_canceled },
                |m: &mut ClosedChannelsRequest| { &mut m.funding_canceled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "abandoned",
                |m: &ClosedChannelsRequest| { &m.abandoned },
                |m: &mut ClosedChannelsRequest| { &mut m.abandoned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClosedChannelsRequest>(
                "ClosedChannelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClosedChannelsRequest {
        static instance: ::protobuf::rt::LazyV2<ClosedChannelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClosedChannelsRequest::new)
    }
}

impl ::protobuf::Clear for ClosedChannelsRequest {
    fn clear(&mut self) {
        self.cooperative = false;
        self.local_force = false;
        self.remote_force = false;
        self.breach = false;
        self.funding_canceled = false;
        self.abandoned = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClosedChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<ChannelCloseSummary>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedChannelsResponse {
    fn default() -> &'a ClosedChannelsResponse {
        <ClosedChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClosedChannelsResponse {
    pub fn new() -> ClosedChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelCloseSummary channels = 1;


    pub fn get_channels(&self) -> &[ChannelCloseSummary] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<ChannelCloseSummary>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<ChannelCloseSummary> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<ChannelCloseSummary> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClosedChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelsResponse {
        ClosedChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelCloseSummary>>(
                "channels",
                |m: &ClosedChannelsResponse| { &m.channels },
                |m: &mut ClosedChannelsResponse| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClosedChannelsResponse>(
                "ClosedChannelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClosedChannelsResponse {
        static instance: ::protobuf::rt::LazyV2<ClosedChannelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClosedChannelsResponse::new)
    }
}

impl ::protobuf::Clear for ClosedChannelsResponse {
    fn clear(&mut self) {
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Peer {
    // message fields
    pub pub_key: ::std::string::String,
    pub address: ::std::string::String,
    pub bytes_sent: u64,
    pub bytes_recv: u64,
    pub sat_sent: i64,
    pub sat_recv: i64,
    pub inbound: bool,
    pub ping_time: i64,
    pub sync_type: Peer_SyncType,
    pub features: ::std::collections::HashMap<u32, Feature>,
    pub errors: ::protobuf::RepeatedField<TimestampedError>,
    pub flap_count: i32,
    pub last_flap_ns: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint64 bytes_sent = 4;


    pub fn get_bytes_sent(&self) -> u64 {
        self.bytes_sent
    }
    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: u64) {
        self.bytes_sent = v;
    }

    // uint64 bytes_recv = 5;


    pub fn get_bytes_recv(&self) -> u64 {
        self.bytes_recv
    }
    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: u64) {
        self.bytes_recv = v;
    }

    // int64 sat_sent = 6;


    pub fn get_sat_sent(&self) -> i64 {
        self.sat_sent
    }
    pub fn clear_sat_sent(&mut self) {
        self.sat_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_sent(&mut self, v: i64) {
        self.sat_sent = v;
    }

    // int64 sat_recv = 7;


    pub fn get_sat_recv(&self) -> i64 {
        self.sat_recv
    }
    pub fn clear_sat_recv(&mut self) {
        self.sat_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_recv(&mut self, v: i64) {
        self.sat_recv = v;
    }

    // bool inbound = 8;


    pub fn get_inbound(&self) -> bool {
        self.inbound
    }
    pub fn clear_inbound(&mut self) {
        self.inbound = false;
    }

    // Param is passed by value, moved
    pub fn set_inbound(&mut self, v: bool) {
        self.inbound = v;
    }

    // int64 ping_time = 9;


    pub fn get_ping_time(&self) -> i64 {
        self.ping_time
    }
    pub fn clear_ping_time(&mut self) {
        self.ping_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: i64) {
        self.ping_time = v;
    }

    // .lnrpc.Peer.SyncType sync_type = 10;


    pub fn get_sync_type(&self) -> Peer_SyncType {
        self.sync_type
    }
    pub fn clear_sync_type(&mut self) {
        self.sync_type = Peer_SyncType::UNKNOWN_SYNC;
    }

    // Param is passed by value, moved
    pub fn set_sync_type(&mut self, v: Peer_SyncType) {
        self.sync_type = v;
    }

    // repeated .lnrpc.Peer.FeaturesEntry features = 11;


    pub fn get_features(&self) -> &::std::collections::HashMap<u32, Feature> {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::collections::HashMap<u32, Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::std::collections::HashMap<u32, Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::collections::HashMap<u32, Feature> {
        ::std::mem::replace(&mut self.features, ::std::collections::HashMap::new())
    }

    // repeated .lnrpc.TimestampedError errors = 12;


    pub fn get_errors(&self) -> &[TimestampedError] {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::protobuf::RepeatedField<TimestampedError>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::protobuf::RepeatedField<TimestampedError> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::protobuf::RepeatedField<TimestampedError> {
        ::std::mem::replace(&mut self.errors, ::protobuf::RepeatedField::new())
    }

    // int32 flap_count = 13;


    pub fn get_flap_count(&self) -> i32 {
        self.flap_count
    }
    pub fn clear_flap_count(&mut self) {
        self.flap_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_flap_count(&mut self, v: i32) {
        self.flap_count = v;
    }

    // int64 last_flap_ns = 14;


    pub fn get_last_flap_ns(&self) -> i64 {
        self.last_flap_ns
    }
    pub fn clear_last_flap_ns(&mut self) {
        self.last_flap_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_flap_ns(&mut self, v: i64) {
        self.last_flap_ns = v;
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        for v in &self.errors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_sent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_recv = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_sent = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_recv = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inbound = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ping_time = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sync_type, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(wire_type, is, &mut self.features)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errors)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flap_count = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_flap_ns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.bytes_sent != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bytes_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_recv != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bytes_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_sent != 0 {
            my_size += ::protobuf::rt::value_size(6, self.sat_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_recv != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sat_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inbound != false {
            my_size += 2;
        }
        if self.ping_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.ping_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sync_type != Peer_SyncType::UNKNOWN_SYNC {
            my_size += ::protobuf::rt::enum_size(10, self.sync_type);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(11, &self.features);
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.flap_count != 0 {
            my_size += ::protobuf::rt::value_size(13, self.flap_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_flap_ns != 0 {
            my_size += ::protobuf::rt::value_size(14, self.last_flap_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.bytes_sent != 0 {
            os.write_uint64(4, self.bytes_sent)?;
        }
        if self.bytes_recv != 0 {
            os.write_uint64(5, self.bytes_recv)?;
        }
        if self.sat_sent != 0 {
            os.write_int64(6, self.sat_sent)?;
        }
        if self.sat_recv != 0 {
            os.write_int64(7, self.sat_recv)?;
        }
        if self.inbound != false {
            os.write_bool(8, self.inbound)?;
        }
        if self.ping_time != 0 {
            os.write_int64(9, self.ping_time)?;
        }
        if self.sync_type != Peer_SyncType::UNKNOWN_SYNC {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.sync_type))?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(11, &self.features, os)?;
        for v in &self.errors {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.flap_count != 0 {
            os.write_int32(13, self.flap_count)?;
        }
        if self.last_flap_ns != 0 {
            os.write_int64(14, self.last_flap_ns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &Peer| { &m.pub_key },
                |m: &mut Peer| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Peer| { &m.address },
                |m: &mut Peer| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_sent",
                |m: &Peer| { &m.bytes_sent },
                |m: &mut Peer| { &mut m.bytes_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_recv",
                |m: &Peer| { &m.bytes_recv },
                |m: &mut Peer| { &mut m.bytes_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sat_sent",
                |m: &Peer| { &m.sat_sent },
                |m: &mut Peer| { &mut m.sat_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sat_recv",
                |m: &Peer| { &m.sat_recv },
                |m: &mut Peer| { &mut m.sat_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inbound",
                |m: &Peer| { &m.inbound },
                |m: &mut Peer| { &mut m.inbound },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ping_time",
                |m: &Peer| { &m.ping_time },
                |m: &mut Peer| { &mut m.ping_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Peer_SyncType>>(
                "sync_type",
                |m: &Peer| { &m.sync_type },
                |m: &mut Peer| { &mut m.sync_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &Peer| { &m.features },
                |m: &mut Peer| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimestampedError>>(
                "errors",
                |m: &Peer| { &m.errors },
                |m: &mut Peer| { &mut m.errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flap_count",
                |m: &Peer| { &m.flap_count },
                |m: &mut Peer| { &mut m.flap_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_flap_ns",
                |m: &Peer| { &m.last_flap_ns },
                |m: &mut Peer| { &mut m.last_flap_ns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Peer>(
                "Peer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Peer {
        static instance: ::protobuf::rt::LazyV2<Peer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Peer::new)
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.address.clear();
        self.bytes_sent = 0;
        self.bytes_recv = 0;
        self.sat_sent = 0;
        self.sat_recv = 0;
        self.inbound = false;
        self.ping_time = 0;
        self.sync_type = Peer_SyncType::UNKNOWN_SYNC;
        self.features.clear();
        self.errors.clear();
        self.flap_count = 0;
        self.last_flap_ns = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Peer_SyncType {
    UNKNOWN_SYNC = 0,
    ACTIVE_SYNC = 1,
    PASSIVE_SYNC = 2,
    PINNED_SYNC = 3,
}

impl ::protobuf::ProtobufEnum for Peer_SyncType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Peer_SyncType> {
        match value {
            0 => ::std::option::Option::Some(Peer_SyncType::UNKNOWN_SYNC),
            1 => ::std::option::Option::Some(Peer_SyncType::ACTIVE_SYNC),
            2 => ::std::option::Option::Some(Peer_SyncType::PASSIVE_SYNC),
            3 => ::std::option::Option::Some(Peer_SyncType::PINNED_SYNC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Peer_SyncType] = &[
            Peer_SyncType::UNKNOWN_SYNC,
            Peer_SyncType::ACTIVE_SYNC,
            Peer_SyncType::PASSIVE_SYNC,
            Peer_SyncType::PINNED_SYNC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Peer_SyncType>("Peer.SyncType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Peer_SyncType {
}

impl ::std::default::Default for Peer_SyncType {
    fn default() -> Self {
        Peer_SyncType::UNKNOWN_SYNC
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer_SyncType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TimestampedError {
    // message fields
    pub timestamp: u64,
    pub error: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimestampedError {
    fn default() -> &'a TimestampedError {
        <TimestampedError as ::protobuf::Message>::default_instance()
    }
}

impl TimestampedError {
    pub fn new() -> TimestampedError {
        ::std::default::Default::default()
    }

    // uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TimestampedError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampedError {
        TimestampedError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &TimestampedError| { &m.timestamp },
                |m: &mut TimestampedError| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &TimestampedError| { &m.error },
                |m: &mut TimestampedError| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimestampedError>(
                "TimestampedError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimestampedError {
        static instance: ::protobuf::rt::LazyV2<TimestampedError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimestampedError::new)
    }
}

impl ::protobuf::Clear for TimestampedError {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampedError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampedError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListPeersRequest {
    // message fields
    pub latest_error: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPeersRequest {
    fn default() -> &'a ListPeersRequest {
        <ListPeersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPeersRequest {
    pub fn new() -> ListPeersRequest {
        ::std::default::Default::default()
    }

    // bool latest_error = 1;


    pub fn get_latest_error(&self) -> bool {
        self.latest_error
    }
    pub fn clear_latest_error(&mut self) {
        self.latest_error = false;
    }

    // Param is passed by value, moved
    pub fn set_latest_error(&mut self, v: bool) {
        self.latest_error = v;
    }
}

impl ::protobuf::Message for ListPeersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.latest_error = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latest_error != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.latest_error != false {
            os.write_bool(1, self.latest_error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeersRequest {
        ListPeersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "latest_error",
                |m: &ListPeersRequest| { &m.latest_error },
                |m: &mut ListPeersRequest| { &mut m.latest_error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPeersRequest>(
                "ListPeersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPeersRequest {
        static instance: ::protobuf::rt::LazyV2<ListPeersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPeersRequest::new)
    }
}

impl ::protobuf::Clear for ListPeersRequest {
    fn clear(&mut self) {
        self.latest_error = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListPeersResponse {
    // message fields
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPeersResponse {
    fn default() -> &'a ListPeersResponse {
        <ListPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPeersResponse {
    pub fn new() -> ListPeersResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Peer peers = 1;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListPeersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeersResponse {
        ListPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                "peers",
                |m: &ListPeersResponse| { &m.peers },
                |m: &mut ListPeersResponse| { &mut m.peers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPeersResponse>(
                "ListPeersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPeersResponse {
        static instance: ::protobuf::rt::LazyV2<ListPeersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPeersResponse::new)
    }
}

impl ::protobuf::Clear for ListPeersResponse {
    fn clear(&mut self) {
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PeerEventSubscription {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerEventSubscription {
    fn default() -> &'a PeerEventSubscription {
        <PeerEventSubscription as ::protobuf::Message>::default_instance()
    }
}

impl PeerEventSubscription {
    pub fn new() -> PeerEventSubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PeerEventSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerEventSubscription {
        PeerEventSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PeerEventSubscription>(
                "PeerEventSubscription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PeerEventSubscription {
        static instance: ::protobuf::rt::LazyV2<PeerEventSubscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PeerEventSubscription::new)
    }
}

impl ::protobuf::Clear for PeerEventSubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerEventSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerEventSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PeerEvent {
    // message fields
    pub pub_key: ::std::string::String,
    pub field_type: PeerEvent_EventType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerEvent {
    fn default() -> &'a PeerEvent {
        <PeerEvent as ::protobuf::Message>::default_instance()
    }
}

impl PeerEvent {
    pub fn new() -> PeerEvent {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // .lnrpc.PeerEvent.EventType type = 2;


    pub fn get_field_type(&self) -> PeerEvent_EventType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PeerEvent_EventType::PEER_ONLINE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PeerEvent_EventType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for PeerEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.field_type != PeerEvent_EventType::PEER_ONLINE {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.field_type != PeerEvent_EventType::PEER_ONLINE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerEvent {
        PeerEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &PeerEvent| { &m.pub_key },
                |m: &mut PeerEvent| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PeerEvent_EventType>>(
                "type",
                |m: &PeerEvent| { &m.field_type },
                |m: &mut PeerEvent| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PeerEvent>(
                "PeerEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PeerEvent {
        static instance: ::protobuf::rt::LazyV2<PeerEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PeerEvent::new)
    }
}

impl ::protobuf::Clear for PeerEvent {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.field_type = PeerEvent_EventType::PEER_ONLINE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PeerEvent_EventType {
    PEER_ONLINE = 0,
    PEER_OFFLINE = 1,
}

impl ::protobuf::ProtobufEnum for PeerEvent_EventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerEvent_EventType> {
        match value {
            0 => ::std::option::Option::Some(PeerEvent_EventType::PEER_ONLINE),
            1 => ::std::option::Option::Some(PeerEvent_EventType::PEER_OFFLINE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PeerEvent_EventType] = &[
            PeerEvent_EventType::PEER_ONLINE,
            PeerEvent_EventType::PEER_OFFLINE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PeerEvent_EventType>("PeerEvent.EventType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PeerEvent_EventType {
}

impl ::std::default::Default for PeerEvent_EventType {
    fn default() -> Self {
        PeerEvent_EventType::PEER_ONLINE
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerEvent_EventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetInfoRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoRequest {
    fn default() -> &'a GetInfoRequest {
        <GetInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoRequest {
    pub fn new() -> GetInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoRequest {
        GetInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInfoRequest>(
                "GetInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetInfoResponse {
    // message fields
    pub version: ::std::string::String,
    pub commit_hash: ::std::string::String,
    pub identity_pubkey: ::std::string::String,
    pub alias: ::std::string::String,
    pub color: ::std::string::String,
    pub num_pending_channels: u32,
    pub num_active_channels: u32,
    pub num_inactive_channels: u32,
    pub num_peers: u32,
    pub block_height: u32,
    pub block_hash: ::std::string::String,
    pub best_header_timestamp: i64,
    pub synced_to_chain: bool,
    pub synced_to_graph: bool,
    pub testnet: bool,
    pub chains: ::protobuf::RepeatedField<Chain>,
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    pub features: ::std::collections::HashMap<u32, Feature>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoResponse {
    fn default() -> &'a GetInfoResponse {
        <GetInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    // string version = 14;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string commit_hash = 20;


    pub fn get_commit_hash(&self) -> &str {
        &self.commit_hash
    }
    pub fn clear_commit_hash(&mut self) {
        self.commit_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_commit_hash(&mut self, v: ::std::string::String) {
        self.commit_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_hash(&mut self) -> &mut ::std::string::String {
        &mut self.commit_hash
    }

    // Take field
    pub fn take_commit_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.commit_hash, ::std::string::String::new())
    }

    // string identity_pubkey = 1;


    pub fn get_identity_pubkey(&self) -> &str {
        &self.identity_pubkey
    }
    pub fn clear_identity_pubkey(&mut self) {
        self.identity_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_pubkey(&mut self, v: ::std::string::String) {
        self.identity_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.identity_pubkey
    }

    // Take field
    pub fn take_identity_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_pubkey, ::std::string::String::new())
    }

    // string alias = 2;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // string color = 17;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }

    // uint32 num_pending_channels = 3;


    pub fn get_num_pending_channels(&self) -> u32 {
        self.num_pending_channels
    }
    pub fn clear_num_pending_channels(&mut self) {
        self.num_pending_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pending_channels(&mut self, v: u32) {
        self.num_pending_channels = v;
    }

    // uint32 num_active_channels = 4;


    pub fn get_num_active_channels(&self) -> u32 {
        self.num_active_channels
    }
    pub fn clear_num_active_channels(&mut self) {
        self.num_active_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_active_channels(&mut self, v: u32) {
        self.num_active_channels = v;
    }

    // uint32 num_inactive_channels = 15;


    pub fn get_num_inactive_channels(&self) -> u32 {
        self.num_inactive_channels
    }
    pub fn clear_num_inactive_channels(&mut self) {
        self.num_inactive_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_inactive_channels(&mut self, v: u32) {
        self.num_inactive_channels = v;
    }

    // uint32 num_peers = 5;


    pub fn get_num_peers(&self) -> u32 {
        self.num_peers
    }
    pub fn clear_num_peers(&mut self) {
        self.num_peers = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_peers(&mut self, v: u32) {
        self.num_peers = v;
    }

    // uint32 block_height = 6;


    pub fn get_block_height(&self) -> u32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u32) {
        self.block_height = v;
    }

    // string block_hash = 8;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // int64 best_header_timestamp = 13;


    pub fn get_best_header_timestamp(&self) -> i64 {
        self.best_header_timestamp
    }
    pub fn clear_best_header_timestamp(&mut self) {
        self.best_header_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_best_header_timestamp(&mut self, v: i64) {
        self.best_header_timestamp = v;
    }

    // bool synced_to_chain = 9;


    pub fn get_synced_to_chain(&self) -> bool {
        self.synced_to_chain
    }
    pub fn clear_synced_to_chain(&mut self) {
        self.synced_to_chain = false;
    }

    // Param is passed by value, moved
    pub fn set_synced_to_chain(&mut self, v: bool) {
        self.synced_to_chain = v;
    }

    // bool synced_to_graph = 18;


    pub fn get_synced_to_graph(&self) -> bool {
        self.synced_to_graph
    }
    pub fn clear_synced_to_graph(&mut self) {
        self.synced_to_graph = false;
    }

    // Param is passed by value, moved
    pub fn set_synced_to_graph(&mut self, v: bool) {
        self.synced_to_graph = v;
    }

    // bool testnet = 10;


    pub fn get_testnet(&self) -> bool {
        self.testnet
    }
    pub fn clear_testnet(&mut self) {
        self.testnet = false;
    }

    // Param is passed by value, moved
    pub fn set_testnet(&mut self, v: bool) {
        self.testnet = v;
    }

    // repeated .lnrpc.Chain chains = 16;


    pub fn get_chains(&self) -> &[Chain] {
        &self.chains
    }
    pub fn clear_chains(&mut self) {
        self.chains.clear();
    }

    // Param is passed by value, moved
    pub fn set_chains(&mut self, v: ::protobuf::RepeatedField<Chain>) {
        self.chains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chains(&mut self) -> &mut ::protobuf::RepeatedField<Chain> {
        &mut self.chains
    }

    // Take field
    pub fn take_chains(&mut self) -> ::protobuf::RepeatedField<Chain> {
        ::std::mem::replace(&mut self.chains, ::protobuf::RepeatedField::new())
    }

    // repeated string uris = 12;


    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.GetInfoResponse.FeaturesEntry features = 19;


    pub fn get_features(&self) -> &::std::collections::HashMap<u32, Feature> {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::collections::HashMap<u32, Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::std::collections::HashMap<u32, Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::collections::HashMap<u32, Feature> {
        ::std::mem::replace(&mut self.features, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for GetInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.chains {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.commit_hash)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_pending_channels = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_active_channels = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_inactive_channels = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_peers = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_height = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.best_header_timestamp = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.synced_to_chain = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.synced_to_graph = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.testnet = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chains)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                19 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(wire_type, is, &mut self.features)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.version);
        }
        if !self.commit_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.commit_hash);
        }
        if !self.identity_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_pubkey);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.alias);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.color);
        }
        if self.num_pending_channels != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_pending_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_active_channels != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_active_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_inactive_channels != 0 {
            my_size += ::protobuf::rt::value_size(15, self.num_inactive_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_peers != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_peers, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(6, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.block_hash);
        }
        if self.best_header_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(13, self.best_header_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.synced_to_chain != false {
            my_size += 2;
        }
        if self.synced_to_graph != false {
            my_size += 3;
        }
        if self.testnet != false {
            my_size += 2;
        }
        for value in &self.chains {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(19, &self.features);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(14, &self.version)?;
        }
        if !self.commit_hash.is_empty() {
            os.write_string(20, &self.commit_hash)?;
        }
        if !self.identity_pubkey.is_empty() {
            os.write_string(1, &self.identity_pubkey)?;
        }
        if !self.alias.is_empty() {
            os.write_string(2, &self.alias)?;
        }
        if !self.color.is_empty() {
            os.write_string(17, &self.color)?;
        }
        if self.num_pending_channels != 0 {
            os.write_uint32(3, self.num_pending_channels)?;
        }
        if self.num_active_channels != 0 {
            os.write_uint32(4, self.num_active_channels)?;
        }
        if self.num_inactive_channels != 0 {
            os.write_uint32(15, self.num_inactive_channels)?;
        }
        if self.num_peers != 0 {
            os.write_uint32(5, self.num_peers)?;
        }
        if self.block_height != 0 {
            os.write_uint32(6, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(8, &self.block_hash)?;
        }
        if self.best_header_timestamp != 0 {
            os.write_int64(13, self.best_header_timestamp)?;
        }
        if self.synced_to_chain != false {
            os.write_bool(9, self.synced_to_chain)?;
        }
        if self.synced_to_graph != false {
            os.write_bool(18, self.synced_to_graph)?;
        }
        if self.testnet != false {
            os.write_bool(10, self.testnet)?;
        }
        for v in &self.chains {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.uris {
            os.write_string(12, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(19, &self.features, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &GetInfoResponse| { &m.version },
                |m: &mut GetInfoResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "commit_hash",
                |m: &GetInfoResponse| { &m.commit_hash },
                |m: &mut GetInfoResponse| { &mut m.commit_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_pubkey",
                |m: &GetInfoResponse| { &m.identity_pubkey },
                |m: &mut GetInfoResponse| { &mut m.identity_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alias",
                |m: &GetInfoResponse| { &m.alias },
                |m: &mut GetInfoResponse| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &GetInfoResponse| { &m.color },
                |m: &mut GetInfoResponse| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_pending_channels",
                |m: &GetInfoResponse| { &m.num_pending_channels },
                |m: &mut GetInfoResponse| { &mut m.num_pending_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_active_channels",
                |m: &GetInfoResponse| { &m.num_active_channels },
                |m: &mut GetInfoResponse| { &mut m.num_active_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_inactive_channels",
                |m: &GetInfoResponse| { &m.num_inactive_channels },
                |m: &mut GetInfoResponse| { &mut m.num_inactive_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_peers",
                |m: &GetInfoResponse| { &m.num_peers },
                |m: &mut GetInfoResponse| { &mut m.num_peers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "block_height",
                |m: &GetInfoResponse| { &m.block_height },
                |m: &mut GetInfoResponse| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "block_hash",
                |m: &GetInfoResponse| { &m.block_hash },
                |m: &mut GetInfoResponse| { &mut m.block_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "best_header_timestamp",
                |m: &GetInfoResponse| { &m.best_header_timestamp },
                |m: &mut GetInfoResponse| { &mut m.best_header_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "synced_to_chain",
                |m: &GetInfoResponse| { &m.synced_to_chain },
                |m: &mut GetInfoResponse| { &mut m.synced_to_chain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "synced_to_graph",
                |m: &GetInfoResponse| { &m.synced_to_graph },
                |m: &mut GetInfoResponse| { &mut m.synced_to_graph },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "testnet",
                |m: &GetInfoResponse| { &m.testnet },
                |m: &mut GetInfoResponse| { &mut m.testnet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Chain>>(
                "chains",
                |m: &GetInfoResponse| { &m.chains },
                |m: &mut GetInfoResponse| { &mut m.chains },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uris",
                |m: &GetInfoResponse| { &m.uris },
                |m: &mut GetInfoResponse| { &mut m.uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &GetInfoResponse| { &m.features },
                |m: &mut GetInfoResponse| { &mut m.features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInfoResponse>(
                "GetInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetInfoResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.commit_hash.clear();
        self.identity_pubkey.clear();
        self.alias.clear();
        self.color.clear();
        self.num_pending_channels = 0;
        self.num_active_channels = 0;
        self.num_inactive_channels = 0;
        self.num_peers = 0;
        self.block_height = 0;
        self.block_hash.clear();
        self.best_header_timestamp = 0;
        self.synced_to_chain = false;
        self.synced_to_graph = false;
        self.testnet = false;
        self.chains.clear();
        self.uris.clear();
        self.features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetRecoveryInfoRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRecoveryInfoRequest {
    fn default() -> &'a GetRecoveryInfoRequest {
        <GetRecoveryInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRecoveryInfoRequest {
    pub fn new() -> GetRecoveryInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetRecoveryInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRecoveryInfoRequest {
        GetRecoveryInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRecoveryInfoRequest>(
                "GetRecoveryInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRecoveryInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetRecoveryInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRecoveryInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetRecoveryInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRecoveryInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRecoveryInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetRecoveryInfoResponse {
    // message fields
    pub recovery_mode: bool,
    pub recovery_finished: bool,
    pub progress: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRecoveryInfoResponse {
    fn default() -> &'a GetRecoveryInfoResponse {
        <GetRecoveryInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetRecoveryInfoResponse {
    pub fn new() -> GetRecoveryInfoResponse {
        ::std::default::Default::default()
    }

    // bool recovery_mode = 1;


    pub fn get_recovery_mode(&self) -> bool {
        self.recovery_mode
    }
    pub fn clear_recovery_mode(&mut self) {
        self.recovery_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_recovery_mode(&mut self, v: bool) {
        self.recovery_mode = v;
    }

    // bool recovery_finished = 2;


    pub fn get_recovery_finished(&self) -> bool {
        self.recovery_finished
    }
    pub fn clear_recovery_finished(&mut self) {
        self.recovery_finished = false;
    }

    // Param is passed by value, moved
    pub fn set_recovery_finished(&mut self, v: bool) {
        self.recovery_finished = v;
    }

    // double progress = 3;


    pub fn get_progress(&self) -> f64 {
        self.progress
    }
    pub fn clear_progress(&mut self) {
        self.progress = 0.;
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f64) {
        self.progress = v;
    }
}

impl ::protobuf::Message for GetRecoveryInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recovery_mode = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recovery_finished = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.progress = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.recovery_mode != false {
            my_size += 2;
        }
        if self.recovery_finished != false {
            my_size += 2;
        }
        if self.progress != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.recovery_mode != false {
            os.write_bool(1, self.recovery_mode)?;
        }
        if self.recovery_finished != false {
            os.write_bool(2, self.recovery_finished)?;
        }
        if self.progress != 0. {
            os.write_double(3, self.progress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRecoveryInfoResponse {
        GetRecoveryInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recovery_mode",
                |m: &GetRecoveryInfoResponse| { &m.recovery_mode },
                |m: &mut GetRecoveryInfoResponse| { &mut m.recovery_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recovery_finished",
                |m: &GetRecoveryInfoResponse| { &m.recovery_finished },
                |m: &mut GetRecoveryInfoResponse| { &mut m.recovery_finished },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "progress",
                |m: &GetRecoveryInfoResponse| { &m.progress },
                |m: &mut GetRecoveryInfoResponse| { &mut m.progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRecoveryInfoResponse>(
                "GetRecoveryInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRecoveryInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetRecoveryInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRecoveryInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetRecoveryInfoResponse {
    fn clear(&mut self) {
        self.recovery_mode = false;
        self.recovery_finished = false;
        self.progress = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRecoveryInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRecoveryInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Chain {
    // message fields
    pub chain: ::std::string::String,
    pub network: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chain {
    fn default() -> &'a Chain {
        <Chain as ::protobuf::Message>::default_instance()
    }
}

impl Chain {
    pub fn new() -> Chain {
        ::std::default::Default::default()
    }

    // string chain = 1;


    pub fn get_chain(&self) -> &str {
        &self.chain
    }
    pub fn clear_chain(&mut self) {
        self.chain.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: ::std::string::String) {
        self.chain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain(&mut self) -> &mut ::std::string::String {
        &mut self.chain
    }

    // Take field
    pub fn take_chain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain, ::std::string::String::new())
    }

    // string network = 2;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Chain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.chain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chain);
        }
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.network);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.chain.is_empty() {
            os.write_string(1, &self.chain)?;
        }
        if !self.network.is_empty() {
            os.write_string(2, &self.network)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chain {
        Chain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain",
                |m: &Chain| { &m.chain },
                |m: &mut Chain| { &mut m.chain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "network",
                |m: &Chain| { &m.network },
                |m: &mut Chain| { &mut m.network },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Chain>(
                "Chain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Chain {
        static instance: ::protobuf::rt::LazyV2<Chain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Chain::new)
    }
}

impl ::protobuf::Clear for Chain {
    fn clear(&mut self) {
        self.chain.clear();
        self.network.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConfirmationUpdate {
    // message fields
    pub block_sha: ::std::vec::Vec<u8>,
    pub block_height: i32,
    pub num_confs_left: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfirmationUpdate {
    fn default() -> &'a ConfirmationUpdate {
        <ConfirmationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ConfirmationUpdate {
    pub fn new() -> ConfirmationUpdate {
        ::std::default::Default::default()
    }

    // bytes block_sha = 1;


    pub fn get_block_sha(&self) -> &[u8] {
        &self.block_sha
    }
    pub fn clear_block_sha(&mut self) {
        self.block_sha.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_sha = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_sha
    }

    // Take field
    pub fn take_block_sha(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_sha, ::std::vec::Vec::new())
    }

    // int32 block_height = 2;


    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    // uint32 num_confs_left = 3;


    pub fn get_num_confs_left(&self) -> u32 {
        self.num_confs_left
    }
    pub fn clear_num_confs_left(&mut self) {
        self.num_confs_left = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confs_left(&mut self, v: u32) {
        self.num_confs_left = v;
    }
}

impl ::protobuf::Message for ConfirmationUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_sha)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_confs_left = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.block_sha.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block_sha);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confs_left != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confs_left, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.block_sha.is_empty() {
            os.write_bytes(1, &self.block_sha)?;
        }
        if self.block_height != 0 {
            os.write_int32(2, self.block_height)?;
        }
        if self.num_confs_left != 0 {
            os.write_uint32(3, self.num_confs_left)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfirmationUpdate {
        ConfirmationUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "block_sha",
                |m: &ConfirmationUpdate| { &m.block_sha },
                |m: &mut ConfirmationUpdate| { &mut m.block_sha },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_height",
                |m: &ConfirmationUpdate| { &m.block_height },
                |m: &mut ConfirmationUpdate| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_confs_left",
                |m: &ConfirmationUpdate| { &m.num_confs_left },
                |m: &mut ConfirmationUpdate| { &mut m.num_confs_left },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfirmationUpdate>(
                "ConfirmationUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfirmationUpdate {
        static instance: ::protobuf::rt::LazyV2<ConfirmationUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfirmationUpdate::new)
    }
}

impl ::protobuf::Clear for ConfirmationUpdate {
    fn clear(&mut self) {
        self.block_sha.clear();
        self.block_height = 0;
        self.num_confs_left = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfirmationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfirmationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelOpenUpdate {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelOpenUpdate {
    fn default() -> &'a ChannelOpenUpdate {
        <ChannelOpenUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelOpenUpdate {
    pub fn new() -> ChannelOpenUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;


    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for ChannelOpenUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelOpenUpdate {
        ChannelOpenUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "channel_point",
                |m: &ChannelOpenUpdate| { &m.channel_point },
                |m: &mut ChannelOpenUpdate| { &mut m.channel_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelOpenUpdate>(
                "ChannelOpenUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelOpenUpdate {
        static instance: ::protobuf::rt::LazyV2<ChannelOpenUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelOpenUpdate::new)
    }
}

impl ::protobuf::Clear for ChannelOpenUpdate {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelOpenUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelOpenUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelCloseUpdate {
    // message fields
    pub closing_txid: ::std::vec::Vec<u8>,
    pub success: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelCloseUpdate {
    fn default() -> &'a ChannelCloseUpdate {
        <ChannelCloseUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCloseUpdate {
    pub fn new() -> ChannelCloseUpdate {
        ::std::default::Default::default()
    }

    // bytes closing_txid = 1;


    pub fn get_closing_txid(&self) -> &[u8] {
        &self.closing_txid
    }
    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.closing_txid, ::std::vec::Vec::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }
}

impl ::protobuf::Message for ChannelCloseUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.closing_txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.closing_txid);
        }
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.closing_txid.is_empty() {
            os.write_bytes(1, &self.closing_txid)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseUpdate {
        ChannelCloseUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "closing_txid",
                |m: &ChannelCloseUpdate| { &m.closing_txid },
                |m: &mut ChannelCloseUpdate| { &mut m.closing_txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &ChannelCloseUpdate| { &m.success },
                |m: &mut ChannelCloseUpdate| { &mut m.success },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelCloseUpdate>(
                "ChannelCloseUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelCloseUpdate {
        static instance: ::protobuf::rt::LazyV2<ChannelCloseUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelCloseUpdate::new)
    }
}

impl ::protobuf::Clear for ChannelCloseUpdate {
    fn clear(&mut self) {
        self.closing_txid.clear();
        self.success = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CloseChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub force: bool,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    pub delivery_address: ::std::string::String,
    pub sat_per_vbyte: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseChannelRequest {
    fn default() -> &'a CloseChannelRequest {
        <CloseChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseChannelRequest {
    pub fn new() -> CloseChannelRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;


    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // bool force = 2;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    // int32 target_conf = 3;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int64 sat_per_byte = 4;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    // string delivery_address = 5;


    pub fn get_delivery_address(&self) -> &str {
        &self.delivery_address
    }
    pub fn clear_delivery_address(&mut self) {
        self.delivery_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_delivery_address(&mut self, v: ::std::string::String) {
        self.delivery_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delivery_address(&mut self) -> &mut ::std::string::String {
        &mut self.delivery_address
    }

    // Take field
    pub fn take_delivery_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delivery_address, ::std::string::String::new())
    }

    // uint64 sat_per_vbyte = 6;


    pub fn get_sat_per_vbyte(&self) -> u64 {
        self.sat_per_vbyte
    }
    pub fn clear_sat_per_vbyte(&mut self) {
        self.sat_per_vbyte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_vbyte(&mut self, v: u64) {
        self.sat_per_vbyte = v;
    }
}

impl ::protobuf::Message for CloseChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delivery_address)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sat_per_vbyte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.force != false {
            my_size += 2;
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(4, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.delivery_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.delivery_address);
        }
        if self.sat_per_vbyte != 0 {
            my_size += ::protobuf::rt::value_size(6, self.sat_per_vbyte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.force != false {
            os.write_bool(2, self.force)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(4, self.sat_per_byte)?;
        }
        if !self.delivery_address.is_empty() {
            os.write_string(5, &self.delivery_address)?;
        }
        if self.sat_per_vbyte != 0 {
            os.write_uint64(6, self.sat_per_vbyte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseChannelRequest {
        CloseChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "channel_point",
                |m: &CloseChannelRequest| { &m.channel_point },
                |m: &mut CloseChannelRequest| { &mut m.channel_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force",
                |m: &CloseChannelRequest| { &m.force },
                |m: &mut CloseChannelRequest| { &mut m.force },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target_conf",
                |m: &CloseChannelRequest| { &m.target_conf },
                |m: &mut CloseChannelRequest| { &mut m.target_conf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sat_per_byte",
                |m: &CloseChannelRequest| { &m.sat_per_byte },
                |m: &mut CloseChannelRequest| { &mut m.sat_per_byte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delivery_address",
                |m: &CloseChannelRequest| { &m.delivery_address },
                |m: &mut CloseChannelRequest| { &mut m.delivery_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sat_per_vbyte",
                |m: &CloseChannelRequest| { &m.sat_per_vbyte },
                |m: &mut CloseChannelRequest| { &mut m.sat_per_vbyte },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseChannelRequest>(
                "CloseChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloseChannelRequest {
        static instance: ::protobuf::rt::LazyV2<CloseChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloseChannelRequest::new)
    }
}

impl ::protobuf::Clear for CloseChannelRequest {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.force = false;
        self.target_conf = 0;
        self.sat_per_byte = 0;
        self.delivery_address.clear();
        self.sat_per_vbyte = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CloseStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<CloseStatusUpdate_oneof_update>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseStatusUpdate {
    fn default() -> &'a CloseStatusUpdate {
        <CloseStatusUpdate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CloseStatusUpdate_oneof_update {
    close_pending(PendingUpdate),
    chan_close(ChannelCloseUpdate),
}

impl CloseStatusUpdate {
    pub fn new() -> CloseStatusUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingUpdate close_pending = 1;


    pub fn get_close_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) => v,
            _ => <PendingUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_close_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_close_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_pending(&mut self) -> PendingUpdate {
        if self.has_close_pending() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    // .lnrpc.ChannelCloseUpdate chan_close = 3;


    pub fn get_chan_close(&self) -> &ChannelCloseUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) => v,
            _ => <ChannelCloseUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chan_close(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_close(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_close(&mut self, v: ChannelCloseUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_close(&mut self) -> &mut ChannelCloseUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ChannelCloseUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_close(&mut self) -> ChannelCloseUpdate {
        if self.has_chan_close() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelCloseUpdate::new()
        }
    }
}

impl ::protobuf::Message for CloseStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseStatusUpdate {
        CloseStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                "close_pending",
                CloseStatusUpdate::has_close_pending,
                CloseStatusUpdate::get_close_pending,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelCloseUpdate>(
                "chan_close",
                CloseStatusUpdate::has_chan_close,
                CloseStatusUpdate::get_chan_close,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseStatusUpdate>(
                "CloseStatusUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloseStatusUpdate {
        static instance: ::protobuf::rt::LazyV2<CloseStatusUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloseStatusUpdate::new)
    }
}

impl ::protobuf::Clear for CloseStatusUpdate {
    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingUpdate {
    // message fields
    pub txid: ::std::vec::Vec<u8>,
    pub output_index: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingUpdate {
    fn default() -> &'a PendingUpdate {
        <PendingUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PendingUpdate {
    pub fn new() -> PendingUpdate {
        ::std::default::Default::default()
    }

    // bytes txid = 1;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // uint32 output_index = 2;


    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }
}

impl ::protobuf::Message for PendingUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.output_index != 0 {
            os.write_uint32(2, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingUpdate {
        PendingUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid",
                |m: &PendingUpdate| { &m.txid },
                |m: &mut PendingUpdate| { &mut m.txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "output_index",
                |m: &PendingUpdate| { &m.output_index },
                |m: &mut PendingUpdate| { &mut m.output_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingUpdate>(
                "PendingUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingUpdate {
        static instance: ::protobuf::rt::LazyV2<PendingUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingUpdate::new)
    }
}

impl ::protobuf::Clear for PendingUpdate {
    fn clear(&mut self) {
        self.txid.clear();
        self.output_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReadyForPsbtFunding {
    // message fields
    pub funding_address: ::std::string::String,
    pub funding_amount: i64,
    pub psbt: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadyForPsbtFunding {
    fn default() -> &'a ReadyForPsbtFunding {
        <ReadyForPsbtFunding as ::protobuf::Message>::default_instance()
    }
}

impl ReadyForPsbtFunding {
    pub fn new() -> ReadyForPsbtFunding {
        ::std::default::Default::default()
    }

    // string funding_address = 1;


    pub fn get_funding_address(&self) -> &str {
        &self.funding_address
    }
    pub fn clear_funding_address(&mut self) {
        self.funding_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_funding_address(&mut self, v: ::std::string::String) {
        self.funding_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding_address(&mut self) -> &mut ::std::string::String {
        &mut self.funding_address
    }

    // Take field
    pub fn take_funding_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.funding_address, ::std::string::String::new())
    }

    // int64 funding_amount = 2;


    pub fn get_funding_amount(&self) -> i64 {
        self.funding_amount
    }
    pub fn clear_funding_amount(&mut self) {
        self.funding_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_funding_amount(&mut self, v: i64) {
        self.funding_amount = v;
    }

    // bytes psbt = 3;


    pub fn get_psbt(&self) -> &[u8] {
        &self.psbt
    }
    pub fn clear_psbt(&mut self) {
        self.psbt.clear();
    }

    // Param is passed by value, moved
    pub fn set_psbt(&mut self, v: ::std::vec::Vec<u8>) {
        self.psbt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_psbt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.psbt
    }

    // Take field
    pub fn take_psbt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.psbt, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReadyForPsbtFunding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.funding_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.funding_amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.psbt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.funding_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.funding_address);
        }
        if self.funding_amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.funding_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.psbt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.psbt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.funding_address.is_empty() {
            os.write_string(1, &self.funding_address)?;
        }
        if self.funding_amount != 0 {
            os.write_int64(2, self.funding_amount)?;
        }
        if !self.psbt.is_empty() {
            os.write_bytes(3, &self.psbt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadyForPsbtFunding {
        ReadyForPsbtFunding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "funding_address",
                |m: &ReadyForPsbtFunding| { &m.funding_address },
                |m: &mut ReadyForPsbtFunding| { &mut m.funding_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "funding_amount",
                |m: &ReadyForPsbtFunding| { &m.funding_amount },
                |m: &mut ReadyForPsbtFunding| { &mut m.funding_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "psbt",
                |m: &ReadyForPsbtFunding| { &m.psbt },
                |m: &mut ReadyForPsbtFunding| { &mut m.psbt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadyForPsbtFunding>(
                "ReadyForPsbtFunding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadyForPsbtFunding {
        static instance: ::protobuf::rt::LazyV2<ReadyForPsbtFunding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadyForPsbtFunding::new)
    }
}

impl ::protobuf::Clear for ReadyForPsbtFunding {
    fn clear(&mut self) {
        self.funding_address.clear();
        self.funding_amount = 0;
        self.psbt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadyForPsbtFunding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadyForPsbtFunding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OpenChannelRequest {
    // message fields
    pub sat_per_vbyte: u64,
    pub node_pubkey: ::std::vec::Vec<u8>,
    pub node_pubkey_string: ::std::string::String,
    pub local_funding_amount: i64,
    pub push_sat: i64,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    pub private: bool,
    pub min_htlc_msat: i64,
    pub remote_csv_delay: u32,
    pub min_confs: i32,
    pub spend_unconfirmed: bool,
    pub close_address: ::std::string::String,
    pub funding_shim: ::protobuf::SingularPtrField<FundingShim>,
    pub remote_max_value_in_flight_msat: u64,
    pub remote_max_htlcs: u32,
    pub max_local_csv: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenChannelRequest {
    fn default() -> &'a OpenChannelRequest {
        <OpenChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl OpenChannelRequest {
    pub fn new() -> OpenChannelRequest {
        ::std::default::Default::default()
    }

    // uint64 sat_per_vbyte = 1;


    pub fn get_sat_per_vbyte(&self) -> u64 {
        self.sat_per_vbyte
    }
    pub fn clear_sat_per_vbyte(&mut self) {
        self.sat_per_vbyte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_vbyte(&mut self, v: u64) {
        self.sat_per_vbyte = v;
    }

    // bytes node_pubkey = 2;


    pub fn get_node_pubkey(&self) -> &[u8] {
        &self.node_pubkey
    }
    pub fn clear_node_pubkey(&mut self) {
        self.node_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_pubkey
    }

    // Take field
    pub fn take_node_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_pubkey, ::std::vec::Vec::new())
    }

    // string node_pubkey_string = 3;


    pub fn get_node_pubkey_string(&self) -> &str {
        &self.node_pubkey_string
    }
    pub fn clear_node_pubkey_string(&mut self) {
        self.node_pubkey_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey_string(&mut self, v: ::std::string::String) {
        self.node_pubkey_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey_string(&mut self) -> &mut ::std::string::String {
        &mut self.node_pubkey_string
    }

    // Take field
    pub fn take_node_pubkey_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pubkey_string, ::std::string::String::new())
    }

    // int64 local_funding_amount = 4;


    pub fn get_local_funding_amount(&self) -> i64 {
        self.local_funding_amount
    }
    pub fn clear_local_funding_amount(&mut self) {
        self.local_funding_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_funding_amount(&mut self, v: i64) {
        self.local_funding_amount = v;
    }

    // int64 push_sat = 5;


    pub fn get_push_sat(&self) -> i64 {
        self.push_sat
    }
    pub fn clear_push_sat(&mut self) {
        self.push_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_push_sat(&mut self, v: i64) {
        self.push_sat = v;
    }

    // int32 target_conf = 6;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int64 sat_per_byte = 7;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    // bool private = 8;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    // int64 min_htlc_msat = 9;


    pub fn get_min_htlc_msat(&self) -> i64 {
        self.min_htlc_msat
    }
    pub fn clear_min_htlc_msat(&mut self) {
        self.min_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_msat(&mut self, v: i64) {
        self.min_htlc_msat = v;
    }

    // uint32 remote_csv_delay = 10;


    pub fn get_remote_csv_delay(&self) -> u32 {
        self.remote_csv_delay
    }
    pub fn clear_remote_csv_delay(&mut self) {
        self.remote_csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_csv_delay(&mut self, v: u32) {
        self.remote_csv_delay = v;
    }

    // int32 min_confs = 11;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // bool spend_unconfirmed = 12;


    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }

    // string close_address = 13;


    pub fn get_close_address(&self) -> &str {
        &self.close_address
    }
    pub fn clear_close_address(&mut self) {
        self.close_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_close_address(&mut self, v: ::std::string::String) {
        self.close_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_address(&mut self) -> &mut ::std::string::String {
        &mut self.close_address
    }

    // Take field
    pub fn take_close_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.close_address, ::std::string::String::new())
    }

    // .lnrpc.FundingShim funding_shim = 14;


    pub fn get_funding_shim(&self) -> &FundingShim {
        self.funding_shim.as_ref().unwrap_or_else(|| <FundingShim as ::protobuf::Message>::default_instance())
    }
    pub fn clear_funding_shim(&mut self) {
        self.funding_shim.clear();
    }

    pub fn has_funding_shim(&self) -> bool {
        self.funding_shim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_funding_shim(&mut self, v: FundingShim) {
        self.funding_shim = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding_shim(&mut self) -> &mut FundingShim {
        if self.funding_shim.is_none() {
            self.funding_shim.set_default();
        }
        self.funding_shim.as_mut().unwrap()
    }

    // Take field
    pub fn take_funding_shim(&mut self) -> FundingShim {
        self.funding_shim.take().unwrap_or_else(|| FundingShim::new())
    }

    // uint64 remote_max_value_in_flight_msat = 15;


    pub fn get_remote_max_value_in_flight_msat(&self) -> u64 {
        self.remote_max_value_in_flight_msat
    }
    pub fn clear_remote_max_value_in_flight_msat(&mut self) {
        self.remote_max_value_in_flight_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_max_value_in_flight_msat(&mut self, v: u64) {
        self.remote_max_value_in_flight_msat = v;
    }

    // uint32 remote_max_htlcs = 16;


    pub fn get_remote_max_htlcs(&self) -> u32 {
        self.remote_max_htlcs
    }
    pub fn clear_remote_max_htlcs(&mut self) {
        self.remote_max_htlcs = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_max_htlcs(&mut self, v: u32) {
        self.remote_max_htlcs = v;
    }

    // uint32 max_local_csv = 17;


    pub fn get_max_local_csv(&self) -> u32 {
        self.max_local_csv
    }
    pub fn clear_max_local_csv(&mut self) {
        self.max_local_csv = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_local_csv(&mut self, v: u32) {
        self.max_local_csv = v;
    }
}

impl ::protobuf::Message for OpenChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.funding_shim {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sat_per_vbyte = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pubkey_string)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_funding_amount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.push_sat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc_msat = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_csv_delay = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.close_address)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.funding_shim)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remote_max_value_in_flight_msat = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_max_htlcs = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_local_csv = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sat_per_vbyte != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sat_per_vbyte, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.node_pubkey);
        }
        if !self.node_pubkey_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node_pubkey_string);
        }
        if self.local_funding_amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_funding_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.push_sat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.push_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(6, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 2;
        }
        if self.min_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(9, self.min_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(10, self.remote_csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(11, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        if !self.close_address.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.close_address);
        }
        if let Some(ref v) = self.funding_shim.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.remote_max_value_in_flight_msat != 0 {
            my_size += ::protobuf::rt::value_size(15, self.remote_max_value_in_flight_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_max_htlcs != 0 {
            my_size += ::protobuf::rt::value_size(16, self.remote_max_htlcs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_local_csv != 0 {
            my_size += ::protobuf::rt::value_size(17, self.max_local_csv, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sat_per_vbyte != 0 {
            os.write_uint64(1, self.sat_per_vbyte)?;
        }
        if !self.node_pubkey.is_empty() {
            os.write_bytes(2, &self.node_pubkey)?;
        }
        if !self.node_pubkey_string.is_empty() {
            os.write_string(3, &self.node_pubkey_string)?;
        }
        if self.local_funding_amount != 0 {
            os.write_int64(4, self.local_funding_amount)?;
        }
        if self.push_sat != 0 {
            os.write_int64(5, self.push_sat)?;
        }
        if self.target_conf != 0 {
            os.write_int32(6, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(7, self.sat_per_byte)?;
        }
        if self.private != false {
            os.write_bool(8, self.private)?;
        }
        if self.min_htlc_msat != 0 {
            os.write_int64(9, self.min_htlc_msat)?;
        }
        if self.remote_csv_delay != 0 {
            os.write_uint32(10, self.remote_csv_delay)?;
        }
        if self.min_confs != 0 {
            os.write_int32(11, self.min_confs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(12, self.spend_unconfirmed)?;
        }
        if !self.close_address.is_empty() {
            os.write_string(13, &self.close_address)?;
        }
        if let Some(ref v) = self.funding_shim.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.remote_max_value_in_flight_msat != 0 {
            os.write_uint64(15, self.remote_max_value_in_flight_msat)?;
        }
        if self.remote_max_htlcs != 0 {
            os.write_uint32(16, self.remote_max_htlcs)?;
        }
        if self.max_local_csv != 0 {
            os.write_uint32(17, self.max_local_csv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenChannelRequest {
        OpenChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sat_per_vbyte",
                |m: &OpenChannelRequest| { &m.sat_per_vbyte },
                |m: &mut OpenChannelRequest| { &mut m.sat_per_vbyte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "node_pubkey",
                |m: &OpenChannelRequest| { &m.node_pubkey },
                |m: &mut OpenChannelRequest| { &mut m.node_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pubkey_string",
                |m: &OpenChannelRequest| { &m.node_pubkey_string },
                |m: &mut OpenChannelRequest| { &mut m.node_pubkey_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "local_funding_amount",
                |m: &OpenChannelRequest| { &m.local_funding_amount },
                |m: &mut OpenChannelRequest| { &mut m.local_funding_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "push_sat",
                |m: &OpenChannelRequest| { &m.push_sat },
                |m: &mut OpenChannelRequest| { &mut m.push_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target_conf",
                |m: &OpenChannelRequest| { &m.target_conf },
                |m: &mut OpenChannelRequest| { &mut m.target_conf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sat_per_byte",
                |m: &OpenChannelRequest| { &m.sat_per_byte },
                |m: &mut OpenChannelRequest| { &mut m.sat_per_byte },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "private",
                |m: &OpenChannelRequest| { &m.private },
                |m: &mut OpenChannelRequest| { &mut m.private },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_htlc_msat",
                |m: &OpenChannelRequest| { &m.min_htlc_msat },
                |m: &mut OpenChannelRequest| { &mut m.min_htlc_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "remote_csv_delay",
                |m: &OpenChannelRequest| { &m.remote_csv_delay },
                |m: &mut OpenChannelRequest| { &mut m.remote_csv_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_confs",
                |m: &OpenChannelRequest| { &m.min_confs },
                |m: &mut OpenChannelRequest| { &mut m.min_confs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spend_unconfirmed",
                |m: &OpenChannelRequest| { &m.spend_unconfirmed },
                |m: &mut OpenChannelRequest| { &mut m.spend_unconfirmed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "close_address",
                |m: &OpenChannelRequest| { &m.close_address },
                |m: &mut OpenChannelRequest| { &mut m.close_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FundingShim>>(
                "funding_shim",
                |m: &OpenChannelRequest| { &m.funding_shim },
                |m: &mut OpenChannelRequest| { &mut m.funding_shim },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remote_max_value_in_flight_msat",
                |m: &OpenChannelRequest| { &m.remote_max_value_in_flight_msat },
                |m: &mut OpenChannelRequest| { &mut m.remote_max_value_in_flight_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "remote_max_htlcs",
                |m: &OpenChannelRequest| { &m.remote_max_htlcs },
                |m: &mut OpenChannelRequest| { &mut m.remote_max_htlcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_local_csv",
                |m: &OpenChannelRequest| { &m.max_local_csv },
                |m: &mut OpenChannelRequest| { &mut m.max_local_csv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpenChannelRequest>(
                "OpenChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpenChannelRequest {
        static instance: ::protobuf::rt::LazyV2<OpenChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpenChannelRequest::new)
    }
}

impl ::protobuf::Clear for OpenChannelRequest {
    fn clear(&mut self) {
        self.sat_per_vbyte = 0;
        self.node_pubkey.clear();
        self.node_pubkey_string.clear();
        self.local_funding_amount = 0;
        self.push_sat = 0;
        self.target_conf = 0;
        self.sat_per_byte = 0;
        self.private = false;
        self.min_htlc_msat = 0;
        self.remote_csv_delay = 0;
        self.min_confs = 0;
        self.spend_unconfirmed = false;
        self.close_address.clear();
        self.funding_shim.clear();
        self.remote_max_value_in_flight_msat = 0;
        self.remote_max_htlcs = 0;
        self.max_local_csv = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OpenStatusUpdate {
    // message fields
    pub pending_chan_id: ::std::vec::Vec<u8>,
    // message oneof groups
    pub update: ::std::option::Option<OpenStatusUpdate_oneof_update>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenStatusUpdate {
    fn default() -> &'a OpenStatusUpdate {
        <OpenStatusUpdate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OpenStatusUpdate_oneof_update {
    chan_pending(PendingUpdate),
    chan_open(ChannelOpenUpdate),
    psbt_fund(ReadyForPsbtFunding),
}

impl OpenStatusUpdate {
    pub fn new() -> OpenStatusUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingUpdate chan_pending = 1;


    pub fn get_chan_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) => v,
            _ => <PendingUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chan_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_pending(&mut self) -> PendingUpdate {
        if self.has_chan_pending() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    // .lnrpc.ChannelOpenUpdate chan_open = 3;


    pub fn get_chan_open(&self) -> &ChannelOpenUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) => v,
            _ => <ChannelOpenUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chan_open(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_open(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_open(&mut self, v: ChannelOpenUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_open(&mut self) -> &mut ChannelOpenUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ChannelOpenUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_open(&mut self) -> ChannelOpenUpdate {
        if self.has_chan_open() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelOpenUpdate::new()
        }
    }

    // .lnrpc.ReadyForPsbtFunding psbt_fund = 5;


    pub fn get_psbt_fund(&self) -> &ReadyForPsbtFunding {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(ref v)) => v,
            _ => <ReadyForPsbtFunding as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_psbt_fund(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_psbt_fund(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_psbt_fund(&mut self, v: ReadyForPsbtFunding) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(v))
    }

    // Mutable pointer to the field.
    pub fn mut_psbt_fund(&mut self) -> &mut ReadyForPsbtFunding {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(ReadyForPsbtFunding::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_psbt_fund(&mut self) -> ReadyForPsbtFunding {
        if self.has_psbt_fund() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadyForPsbtFunding::new()
        }
    }

    // bytes pending_chan_id = 4;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OpenStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::psbt_fund(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::psbt_fund(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.pending_chan_id);
        }
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::psbt_fund(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(4, &self.pending_chan_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::psbt_fund(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenStatusUpdate {
        OpenStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                "chan_pending",
                OpenStatusUpdate::has_chan_pending,
                OpenStatusUpdate::get_chan_pending,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelOpenUpdate>(
                "chan_open",
                OpenStatusUpdate::has_chan_open,
                OpenStatusUpdate::get_chan_open,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReadyForPsbtFunding>(
                "psbt_fund",
                OpenStatusUpdate::has_psbt_fund,
                OpenStatusUpdate::get_psbt_fund,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &OpenStatusUpdate| { &m.pending_chan_id },
                |m: &mut OpenStatusUpdate| { &mut m.pending_chan_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpenStatusUpdate>(
                "OpenStatusUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpenStatusUpdate {
        static instance: ::protobuf::rt::LazyV2<OpenStatusUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpenStatusUpdate::new)
    }
}

impl ::protobuf::Clear for OpenStatusUpdate {
    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.pending_chan_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct KeyLocator {
    // message fields
    pub key_family: i32,
    pub key_index: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyLocator {
    fn default() -> &'a KeyLocator {
        <KeyLocator as ::protobuf::Message>::default_instance()
    }
}

impl KeyLocator {
    pub fn new() -> KeyLocator {
        ::std::default::Default::default()
    }

    // int32 key_family = 1;


    pub fn get_key_family(&self) -> i32 {
        self.key_family
    }
    pub fn clear_key_family(&mut self) {
        self.key_family = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_family(&mut self, v: i32) {
        self.key_family = v;
    }

    // int32 key_index = 2;


    pub fn get_key_index(&self) -> i32 {
        self.key_index
    }
    pub fn clear_key_index(&mut self) {
        self.key_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_index(&mut self, v: i32) {
        self.key_index = v;
    }
}

impl ::protobuf::Message for KeyLocator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_family = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_family != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_family, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.key_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_family != 0 {
            os.write_int32(1, self.key_family)?;
        }
        if self.key_index != 0 {
            os.write_int32(2, self.key_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyLocator {
        KeyLocator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "key_family",
                |m: &KeyLocator| { &m.key_family },
                |m: &mut KeyLocator| { &mut m.key_family },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "key_index",
                |m: &KeyLocator| { &m.key_index },
                |m: &mut KeyLocator| { &mut m.key_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyLocator>(
                "KeyLocator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyLocator {
        static instance: ::protobuf::rt::LazyV2<KeyLocator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyLocator::new)
    }
}

impl ::protobuf::Clear for KeyLocator {
    fn clear(&mut self) {
        self.key_family = 0;
        self.key_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyLocator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyLocator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct KeyDescriptor {
    // message fields
    pub raw_key_bytes: ::std::vec::Vec<u8>,
    pub key_loc: ::protobuf::SingularPtrField<KeyLocator>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyDescriptor {
    fn default() -> &'a KeyDescriptor {
        <KeyDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl KeyDescriptor {
    pub fn new() -> KeyDescriptor {
        ::std::default::Default::default()
    }

    // bytes raw_key_bytes = 1;


    pub fn get_raw_key_bytes(&self) -> &[u8] {
        &self.raw_key_bytes
    }
    pub fn clear_raw_key_bytes(&mut self) {
        self.raw_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raw_key_bytes
    }

    // Take field
    pub fn take_raw_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raw_key_bytes, ::std::vec::Vec::new())
    }

    // .lnrpc.KeyLocator key_loc = 2;


    pub fn get_key_loc(&self) -> &KeyLocator {
        self.key_loc.as_ref().unwrap_or_else(|| <KeyLocator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key_loc(&mut self) {
        self.key_loc.clear();
    }

    pub fn has_key_loc(&self) -> bool {
        self.key_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_loc(&mut self, v: KeyLocator) {
        self.key_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_loc(&mut self) -> &mut KeyLocator {
        if self.key_loc.is_none() {
            self.key_loc.set_default();
        }
        self.key_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_loc(&mut self) -> KeyLocator {
        self.key_loc.take().unwrap_or_else(|| KeyLocator::new())
    }
}

impl ::protobuf::Message for KeyDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.key_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raw_key_bytes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.raw_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.raw_key_bytes);
        }
        if let Some(ref v) = self.key_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.raw_key_bytes.is_empty() {
            os.write_bytes(1, &self.raw_key_bytes)?;
        }
        if let Some(ref v) = self.key_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyDescriptor {
        KeyDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "raw_key_bytes",
                |m: &KeyDescriptor| { &m.raw_key_bytes },
                |m: &mut KeyDescriptor| { &mut m.raw_key_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyLocator>>(
                "key_loc",
                |m: &KeyDescriptor| { &m.key_loc },
                |m: &mut KeyDescriptor| { &mut m.key_loc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyDescriptor>(
                "KeyDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyDescriptor {
        static instance: ::protobuf::rt::LazyV2<KeyDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyDescriptor::new)
    }
}

impl ::protobuf::Clear for KeyDescriptor {
    fn clear(&mut self) {
        self.raw_key_bytes.clear();
        self.key_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChanPointShim {
    // message fields
    pub amt: i64,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub local_key: ::protobuf::SingularPtrField<KeyDescriptor>,
    pub remote_key: ::std::vec::Vec<u8>,
    pub pending_chan_id: ::std::vec::Vec<u8>,
    pub thaw_height: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanPointShim {
    fn default() -> &'a ChanPointShim {
        <ChanPointShim as ::protobuf::Message>::default_instance()
    }
}

impl ChanPointShim {
    pub fn new() -> ChanPointShim {
        ::std::default::Default::default()
    }

    // int64 amt = 1;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // .lnrpc.ChannelPoint chan_point = 2;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // .lnrpc.KeyDescriptor local_key = 3;


    pub fn get_local_key(&self) -> &KeyDescriptor {
        self.local_key.as_ref().unwrap_or_else(|| <KeyDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local_key(&mut self) {
        self.local_key.clear();
    }

    pub fn has_local_key(&self) -> bool {
        self.local_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_key(&mut self, v: KeyDescriptor) {
        self.local_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_key(&mut self) -> &mut KeyDescriptor {
        if self.local_key.is_none() {
            self.local_key.set_default();
        }
        self.local_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_key(&mut self) -> KeyDescriptor {
        self.local_key.take().unwrap_or_else(|| KeyDescriptor::new())
    }

    // bytes remote_key = 4;


    pub fn get_remote_key(&self) -> &[u8] {
        &self.remote_key
    }
    pub fn clear_remote_key(&mut self) {
        self.remote_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.remote_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.remote_key
    }

    // Take field
    pub fn take_remote_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.remote_key, ::std::vec::Vec::new())
    }

    // bytes pending_chan_id = 5;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }

    // uint32 thaw_height = 6;


    pub fn get_thaw_height(&self) -> u32 {
        self.thaw_height
    }
    pub fn clear_thaw_height(&mut self) {
        self.thaw_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_thaw_height(&mut self, v: u32) {
        self.thaw_height = v;
    }
}

impl ::protobuf::Message for ChanPointShim {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.remote_key)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.thaw_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.remote_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.remote_key);
        }
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.pending_chan_id);
        }
        if self.thaw_height != 0 {
            my_size += ::protobuf::rt::value_size(6, self.thaw_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amt != 0 {
            os.write_int64(1, self.amt)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.remote_key.is_empty() {
            os.write_bytes(4, &self.remote_key)?;
        }
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(5, &self.pending_chan_id)?;
        }
        if self.thaw_height != 0 {
            os.write_uint32(6, self.thaw_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanPointShim {
        ChanPointShim::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &ChanPointShim| { &m.amt },
                |m: &mut ChanPointShim| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "chan_point",
                |m: &ChanPointShim| { &m.chan_point },
                |m: &mut ChanPointShim| { &mut m.chan_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyDescriptor>>(
                "local_key",
                |m: &ChanPointShim| { &m.local_key },
                |m: &mut ChanPointShim| { &mut m.local_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "remote_key",
                |m: &ChanPointShim| { &m.remote_key },
                |m: &mut ChanPointShim| { &mut m.remote_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &ChanPointShim| { &m.pending_chan_id },
                |m: &mut ChanPointShim| { &mut m.pending_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "thaw_height",
                |m: &ChanPointShim| { &m.thaw_height },
                |m: &mut ChanPointShim| { &mut m.thaw_height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChanPointShim>(
                "ChanPointShim",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChanPointShim {
        static instance: ::protobuf::rt::LazyV2<ChanPointShim> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChanPointShim::new)
    }
}

impl ::protobuf::Clear for ChanPointShim {
    fn clear(&mut self) {
        self.amt = 0;
        self.chan_point.clear();
        self.local_key.clear();
        self.remote_key.clear();
        self.pending_chan_id.clear();
        self.thaw_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanPointShim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanPointShim {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PsbtShim {
    // message fields
    pub pending_chan_id: ::std::vec::Vec<u8>,
    pub base_psbt: ::std::vec::Vec<u8>,
    pub no_publish: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PsbtShim {
    fn default() -> &'a PsbtShim {
        <PsbtShim as ::protobuf::Message>::default_instance()
    }
}

impl PsbtShim {
    pub fn new() -> PsbtShim {
        ::std::default::Default::default()
    }

    // bytes pending_chan_id = 1;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }

    // bytes base_psbt = 2;


    pub fn get_base_psbt(&self) -> &[u8] {
        &self.base_psbt
    }
    pub fn clear_base_psbt(&mut self) {
        self.base_psbt.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_psbt(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_psbt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_psbt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.base_psbt
    }

    // Take field
    pub fn take_base_psbt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.base_psbt, ::std::vec::Vec::new())
    }

    // bool no_publish = 3;


    pub fn get_no_publish(&self) -> bool {
        self.no_publish
    }
    pub fn clear_no_publish(&mut self) {
        self.no_publish = false;
    }

    // Param is passed by value, moved
    pub fn set_no_publish(&mut self, v: bool) {
        self.no_publish = v;
    }
}

impl ::protobuf::Message for PsbtShim {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.base_psbt)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_publish = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.pending_chan_id);
        }
        if !self.base_psbt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base_psbt);
        }
        if self.no_publish != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(1, &self.pending_chan_id)?;
        }
        if !self.base_psbt.is_empty() {
            os.write_bytes(2, &self.base_psbt)?;
        }
        if self.no_publish != false {
            os.write_bool(3, self.no_publish)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PsbtShim {
        PsbtShim::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &PsbtShim| { &m.pending_chan_id },
                |m: &mut PsbtShim| { &mut m.pending_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "base_psbt",
                |m: &PsbtShim| { &m.base_psbt },
                |m: &mut PsbtShim| { &mut m.base_psbt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_publish",
                |m: &PsbtShim| { &m.no_publish },
                |m: &mut PsbtShim| { &mut m.no_publish },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PsbtShim>(
                "PsbtShim",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PsbtShim {
        static instance: ::protobuf::rt::LazyV2<PsbtShim> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PsbtShim::new)
    }
}

impl ::protobuf::Clear for PsbtShim {
    fn clear(&mut self) {
        self.pending_chan_id.clear();
        self.base_psbt.clear();
        self.no_publish = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PsbtShim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PsbtShim {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FundingShim {
    // message oneof groups
    pub shim: ::std::option::Option<FundingShim_oneof_shim>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingShim {
    fn default() -> &'a FundingShim {
        <FundingShim as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FundingShim_oneof_shim {
    chan_point_shim(ChanPointShim),
    psbt_shim(PsbtShim),
}

impl FundingShim {
    pub fn new() -> FundingShim {
        ::std::default::Default::default()
    }

    // .lnrpc.ChanPointShim chan_point_shim = 1;


    pub fn get_chan_point_shim(&self) -> &ChanPointShim {
        match self.shim {
            ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(ref v)) => v,
            _ => <ChanPointShim as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chan_point_shim(&mut self) {
        self.shim = ::std::option::Option::None;
    }

    pub fn has_chan_point_shim(&self) -> bool {
        match self.shim {
            ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_point_shim(&mut self, v: ChanPointShim) {
        self.shim = ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_point_shim(&mut self) -> &mut ChanPointShim {
        if let ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(_)) = self.shim {
        } else {
            self.shim = ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(ChanPointShim::new()));
        }
        match self.shim {
            ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_point_shim(&mut self) -> ChanPointShim {
        if self.has_chan_point_shim() {
            match self.shim.take() {
                ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(v)) => v,
                _ => panic!(),
            }
        } else {
            ChanPointShim::new()
        }
    }

    // .lnrpc.PsbtShim psbt_shim = 2;


    pub fn get_psbt_shim(&self) -> &PsbtShim {
        match self.shim {
            ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(ref v)) => v,
            _ => <PsbtShim as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_psbt_shim(&mut self) {
        self.shim = ::std::option::Option::None;
    }

    pub fn has_psbt_shim(&self) -> bool {
        match self.shim {
            ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_psbt_shim(&mut self, v: PsbtShim) {
        self.shim = ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_psbt_shim(&mut self) -> &mut PsbtShim {
        if let ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(_)) = self.shim {
        } else {
            self.shim = ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(PsbtShim::new()));
        }
        match self.shim {
            ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_psbt_shim(&mut self) -> PsbtShim {
        if self.has_psbt_shim() {
            match self.shim.take() {
                ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(v)) => v,
                _ => panic!(),
            }
        } else {
            PsbtShim::new()
        }
    }
}

impl ::protobuf::Message for FundingShim {
    fn is_initialized(&self) -> bool {
        if let Some(FundingShim_oneof_shim::chan_point_shim(ref v)) = self.shim {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FundingShim_oneof_shim::psbt_shim(ref v)) = self.shim {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.shim = ::std::option::Option::Some(FundingShim_oneof_shim::chan_point_shim(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.shim = ::std::option::Option::Some(FundingShim_oneof_shim::psbt_shim(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.shim {
            match v {
                &FundingShim_oneof_shim::chan_point_shim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FundingShim_oneof_shim::psbt_shim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.shim {
            match v {
                &FundingShim_oneof_shim::chan_point_shim(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FundingShim_oneof_shim::psbt_shim(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingShim {
        FundingShim::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChanPointShim>(
                "chan_point_shim",
                FundingShim::has_chan_point_shim,
                FundingShim::get_chan_point_shim,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PsbtShim>(
                "psbt_shim",
                FundingShim::has_psbt_shim,
                FundingShim::get_psbt_shim,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FundingShim>(
                "FundingShim",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FundingShim {
        static instance: ::protobuf::rt::LazyV2<FundingShim> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingShim::new)
    }
}

impl ::protobuf::Clear for FundingShim {
    fn clear(&mut self) {
        self.shim = ::std::option::Option::None;
        self.shim = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FundingShim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingShim {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FundingShimCancel {
    // message fields
    pub pending_chan_id: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingShimCancel {
    fn default() -> &'a FundingShimCancel {
        <FundingShimCancel as ::protobuf::Message>::default_instance()
    }
}

impl FundingShimCancel {
    pub fn new() -> FundingShimCancel {
        ::std::default::Default::default()
    }

    // bytes pending_chan_id = 1;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FundingShimCancel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.pending_chan_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(1, &self.pending_chan_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingShimCancel {
        FundingShimCancel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &FundingShimCancel| { &m.pending_chan_id },
                |m: &mut FundingShimCancel| { &mut m.pending_chan_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FundingShimCancel>(
                "FundingShimCancel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FundingShimCancel {
        static instance: ::protobuf::rt::LazyV2<FundingShimCancel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingShimCancel::new)
    }
}

impl ::protobuf::Clear for FundingShimCancel {
    fn clear(&mut self) {
        self.pending_chan_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FundingShimCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingShimCancel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FundingPsbtVerify {
    // message fields
    pub funded_psbt: ::std::vec::Vec<u8>,
    pub pending_chan_id: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingPsbtVerify {
    fn default() -> &'a FundingPsbtVerify {
        <FundingPsbtVerify as ::protobuf::Message>::default_instance()
    }
}

impl FundingPsbtVerify {
    pub fn new() -> FundingPsbtVerify {
        ::std::default::Default::default()
    }

    // bytes funded_psbt = 1;


    pub fn get_funded_psbt(&self) -> &[u8] {
        &self.funded_psbt
    }
    pub fn clear_funded_psbt(&mut self) {
        self.funded_psbt.clear();
    }

    // Param is passed by value, moved
    pub fn set_funded_psbt(&mut self, v: ::std::vec::Vec<u8>) {
        self.funded_psbt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funded_psbt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.funded_psbt
    }

    // Take field
    pub fn take_funded_psbt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.funded_psbt, ::std::vec::Vec::new())
    }

    // bytes pending_chan_id = 2;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FundingPsbtVerify {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.funded_psbt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.funded_psbt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.funded_psbt);
        }
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pending_chan_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.funded_psbt.is_empty() {
            os.write_bytes(1, &self.funded_psbt)?;
        }
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(2, &self.pending_chan_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingPsbtVerify {
        FundingPsbtVerify::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "funded_psbt",
                |m: &FundingPsbtVerify| { &m.funded_psbt },
                |m: &mut FundingPsbtVerify| { &mut m.funded_psbt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &FundingPsbtVerify| { &m.pending_chan_id },
                |m: &mut FundingPsbtVerify| { &mut m.pending_chan_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FundingPsbtVerify>(
                "FundingPsbtVerify",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FundingPsbtVerify {
        static instance: ::protobuf::rt::LazyV2<FundingPsbtVerify> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingPsbtVerify::new)
    }
}

impl ::protobuf::Clear for FundingPsbtVerify {
    fn clear(&mut self) {
        self.funded_psbt.clear();
        self.pending_chan_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FundingPsbtVerify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingPsbtVerify {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FundingPsbtFinalize {
    // message fields
    pub signed_psbt: ::std::vec::Vec<u8>,
    pub pending_chan_id: ::std::vec::Vec<u8>,
    pub final_raw_tx: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingPsbtFinalize {
    fn default() -> &'a FundingPsbtFinalize {
        <FundingPsbtFinalize as ::protobuf::Message>::default_instance()
    }
}

impl FundingPsbtFinalize {
    pub fn new() -> FundingPsbtFinalize {
        ::std::default::Default::default()
    }

    // bytes signed_psbt = 1;


    pub fn get_signed_psbt(&self) -> &[u8] {
        &self.signed_psbt
    }
    pub fn clear_signed_psbt(&mut self) {
        self.signed_psbt.clear();
    }

    // Param is passed by value, moved
    pub fn set_signed_psbt(&mut self, v: ::std::vec::Vec<u8>) {
        self.signed_psbt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signed_psbt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signed_psbt
    }

    // Take field
    pub fn take_signed_psbt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signed_psbt, ::std::vec::Vec::new())
    }

    // bytes pending_chan_id = 2;


    pub fn get_pending_chan_id(&self) -> &[u8] {
        &self.pending_chan_id
    }
    pub fn clear_pending_chan_id(&mut self) {
        self.pending_chan_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_chan_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pending_chan_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_chan_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pending_chan_id
    }

    // Take field
    pub fn take_pending_chan_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pending_chan_id, ::std::vec::Vec::new())
    }

    // bytes final_raw_tx = 3;


    pub fn get_final_raw_tx(&self) -> &[u8] {
        &self.final_raw_tx
    }
    pub fn clear_final_raw_tx(&mut self) {
        self.final_raw_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_final_raw_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.final_raw_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_final_raw_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.final_raw_tx
    }

    // Take field
    pub fn take_final_raw_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.final_raw_tx, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FundingPsbtFinalize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signed_psbt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pending_chan_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.final_raw_tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signed_psbt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signed_psbt);
        }
        if !self.pending_chan_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pending_chan_id);
        }
        if !self.final_raw_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.final_raw_tx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signed_psbt.is_empty() {
            os.write_bytes(1, &self.signed_psbt)?;
        }
        if !self.pending_chan_id.is_empty() {
            os.write_bytes(2, &self.pending_chan_id)?;
        }
        if !self.final_raw_tx.is_empty() {
            os.write_bytes(3, &self.final_raw_tx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingPsbtFinalize {
        FundingPsbtFinalize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signed_psbt",
                |m: &FundingPsbtFinalize| { &m.signed_psbt },
                |m: &mut FundingPsbtFinalize| { &mut m.signed_psbt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pending_chan_id",
                |m: &FundingPsbtFinalize| { &m.pending_chan_id },
                |m: &mut FundingPsbtFinalize| { &mut m.pending_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "final_raw_tx",
                |m: &FundingPsbtFinalize| { &m.final_raw_tx },
                |m: &mut FundingPsbtFinalize| { &mut m.final_raw_tx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FundingPsbtFinalize>(
                "FundingPsbtFinalize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FundingPsbtFinalize {
        static instance: ::protobuf::rt::LazyV2<FundingPsbtFinalize> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingPsbtFinalize::new)
    }
}

impl ::protobuf::Clear for FundingPsbtFinalize {
    fn clear(&mut self) {
        self.signed_psbt.clear();
        self.pending_chan_id.clear();
        self.final_raw_tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FundingPsbtFinalize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingPsbtFinalize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FundingTransitionMsg {
    // message oneof groups
    pub trigger: ::std::option::Option<FundingTransitionMsg_oneof_trigger>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingTransitionMsg {
    fn default() -> &'a FundingTransitionMsg {
        <FundingTransitionMsg as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FundingTransitionMsg_oneof_trigger {
    shim_register(FundingShim),
    shim_cancel(FundingShimCancel),
    psbt_verify(FundingPsbtVerify),
    psbt_finalize(FundingPsbtFinalize),
}

impl FundingTransitionMsg {
    pub fn new() -> FundingTransitionMsg {
        ::std::default::Default::default()
    }

    // .lnrpc.FundingShim shim_register = 1;


    pub fn get_shim_register(&self) -> &FundingShim {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(ref v)) => v,
            _ => <FundingShim as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_shim_register(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_shim_register(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shim_register(&mut self, v: FundingShim) {
        self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shim_register(&mut self) -> &mut FundingShim {
        if let ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(FundingShim::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shim_register(&mut self) -> FundingShim {
        if self.has_shim_register() {
            match self.trigger.take() {
                ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(v)) => v,
                _ => panic!(),
            }
        } else {
            FundingShim::new()
        }
    }

    // .lnrpc.FundingShimCancel shim_cancel = 2;


    pub fn get_shim_cancel(&self) -> &FundingShimCancel {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(ref v)) => v,
            _ => <FundingShimCancel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_shim_cancel(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_shim_cancel(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shim_cancel(&mut self, v: FundingShimCancel) {
        self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shim_cancel(&mut self) -> &mut FundingShimCancel {
        if let ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(FundingShimCancel::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shim_cancel(&mut self) -> FundingShimCancel {
        if self.has_shim_cancel() {
            match self.trigger.take() {
                ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(v)) => v,
                _ => panic!(),
            }
        } else {
            FundingShimCancel::new()
        }
    }

    // .lnrpc.FundingPsbtVerify psbt_verify = 3;


    pub fn get_psbt_verify(&self) -> &FundingPsbtVerify {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(ref v)) => v,
            _ => <FundingPsbtVerify as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_psbt_verify(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_psbt_verify(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_psbt_verify(&mut self, v: FundingPsbtVerify) {
        self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(v))
    }

    // Mutable pointer to the field.
    pub fn mut_psbt_verify(&mut self) -> &mut FundingPsbtVerify {
        if let ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(FundingPsbtVerify::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_psbt_verify(&mut self) -> FundingPsbtVerify {
        if self.has_psbt_verify() {
            match self.trigger.take() {
                ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(v)) => v,
                _ => panic!(),
            }
        } else {
            FundingPsbtVerify::new()
        }
    }

    // .lnrpc.FundingPsbtFinalize psbt_finalize = 4;


    pub fn get_psbt_finalize(&self) -> &FundingPsbtFinalize {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(ref v)) => v,
            _ => <FundingPsbtFinalize as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_psbt_finalize(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_psbt_finalize(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_psbt_finalize(&mut self, v: FundingPsbtFinalize) {
        self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(v))
    }

    // Mutable pointer to the field.
    pub fn mut_psbt_finalize(&mut self) -> &mut FundingPsbtFinalize {
        if let ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(FundingPsbtFinalize::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_psbt_finalize(&mut self) -> FundingPsbtFinalize {
        if self.has_psbt_finalize() {
            match self.trigger.take() {
                ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(v)) => v,
                _ => panic!(),
            }
        } else {
            FundingPsbtFinalize::new()
        }
    }
}

impl ::protobuf::Message for FundingTransitionMsg {
    fn is_initialized(&self) -> bool {
        if let Some(FundingTransitionMsg_oneof_trigger::shim_register(ref v)) = self.trigger {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FundingTransitionMsg_oneof_trigger::shim_cancel(ref v)) = self.trigger {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FundingTransitionMsg_oneof_trigger::psbt_verify(ref v)) = self.trigger {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(ref v)) = self.trigger {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_register(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::shim_cancel(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_verify(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.trigger = ::std::option::Option::Some(FundingTransitionMsg_oneof_trigger::psbt_finalize(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.trigger {
            match v {
                &FundingTransitionMsg_oneof_trigger::shim_register(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FundingTransitionMsg_oneof_trigger::shim_cancel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FundingTransitionMsg_oneof_trigger::psbt_verify(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FundingTransitionMsg_oneof_trigger::psbt_finalize(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.trigger {
            match v {
                &FundingTransitionMsg_oneof_trigger::shim_register(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FundingTransitionMsg_oneof_trigger::shim_cancel(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FundingTransitionMsg_oneof_trigger::psbt_verify(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FundingTransitionMsg_oneof_trigger::psbt_finalize(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingTransitionMsg {
        FundingTransitionMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FundingShim>(
                "shim_register",
                FundingTransitionMsg::has_shim_register,
                FundingTransitionMsg::get_shim_register,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FundingShimCancel>(
                "shim_cancel",
                FundingTransitionMsg::has_shim_cancel,
                FundingTransitionMsg::get_shim_cancel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FundingPsbtVerify>(
                "psbt_verify",
                FundingTransitionMsg::has_psbt_verify,
                FundingTransitionMsg::get_psbt_verify,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FundingPsbtFinalize>(
                "psbt_finalize",
                FundingTransitionMsg::has_psbt_finalize,
                FundingTransitionMsg::get_psbt_finalize,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FundingTransitionMsg>(
                "FundingTransitionMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FundingTransitionMsg {
        static instance: ::protobuf::rt::LazyV2<FundingTransitionMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingTransitionMsg::new)
    }
}

impl ::protobuf::Clear for FundingTransitionMsg {
    fn clear(&mut self) {
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FundingTransitionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingTransitionMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FundingStateStepResp {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingStateStepResp {
    fn default() -> &'a FundingStateStepResp {
        <FundingStateStepResp as ::protobuf::Message>::default_instance()
    }
}

impl FundingStateStepResp {
    pub fn new() -> FundingStateStepResp {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FundingStateStepResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingStateStepResp {
        FundingStateStepResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FundingStateStepResp>(
                "FundingStateStepResp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FundingStateStepResp {
        static instance: ::protobuf::rt::LazyV2<FundingStateStepResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingStateStepResp::new)
    }
}

impl ::protobuf::Clear for FundingStateStepResp {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FundingStateStepResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingStateStepResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingHTLC {
    // message fields
    pub incoming: bool,
    pub amount: i64,
    pub outpoint: ::std::string::String,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub stage: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingHTLC {
    fn default() -> &'a PendingHTLC {
        <PendingHTLC as ::protobuf::Message>::default_instance()
    }
}

impl PendingHTLC {
    pub fn new() -> PendingHTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;


    pub fn get_incoming(&self) -> bool {
        self.incoming
    }
    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // string outpoint = 3;


    pub fn get_outpoint(&self) -> &str {
        &self.outpoint
    }
    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: ::std::string::String) {
        self.outpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut ::std::string::String {
        &mut self.outpoint
    }

    // Take field
    pub fn take_outpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outpoint, ::std::string::String::new())
    }

    // uint32 maturity_height = 4;


    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }
    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    // int32 blocks_til_maturity = 5;


    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }
    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    // uint32 stage = 6;


    pub fn get_stage(&self) -> u32 {
        self.stage
    }
    pub fn clear_stage(&mut self) {
        self.stage = 0;
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = v;
    }
}

impl ::protobuf::Message for PendingHTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.outpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.outpoint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stage != 0 {
            my_size += ::protobuf::rt::value_size(6, self.stage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if !self.outpoint.is_empty() {
            os.write_string(3, &self.outpoint)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.stage != 0 {
            os.write_uint32(6, self.stage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingHTLC {
        PendingHTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "incoming",
                |m: &PendingHTLC| { &m.incoming },
                |m: &mut PendingHTLC| { &mut m.incoming },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &PendingHTLC| { &m.amount },
                |m: &mut PendingHTLC| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "outpoint",
                |m: &PendingHTLC| { &m.outpoint },
                |m: &mut PendingHTLC| { &mut m.outpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maturity_height",
                |m: &PendingHTLC| { &m.maturity_height },
                |m: &mut PendingHTLC| { &mut m.maturity_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blocks_til_maturity",
                |m: &PendingHTLC| { &m.blocks_til_maturity },
                |m: &mut PendingHTLC| { &mut m.blocks_til_maturity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stage",
                |m: &PendingHTLC| { &m.stage },
                |m: &mut PendingHTLC| { &mut m.stage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingHTLC>(
                "PendingHTLC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingHTLC {
        static instance: ::protobuf::rt::LazyV2<PendingHTLC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingHTLC::new)
    }
}

impl ::protobuf::Clear for PendingHTLC {
    fn clear(&mut self) {
        self.incoming = false;
        self.amount = 0;
        self.outpoint.clear();
        self.maturity_height = 0;
        self.blocks_til_maturity = 0;
        self.stage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingHTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingHTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsRequest {
    fn default() -> &'a PendingChannelsRequest {
        <PendingChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsRequest {
    pub fn new() -> PendingChannelsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PendingChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsRequest {
        PendingChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsRequest>(
                "PendingChannelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsRequest {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsRequest::new)
    }
}

impl ::protobuf::Clear for PendingChannelsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse {
    // message fields
    pub total_limbo_balance: i64,
    pub pending_open_channels: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>,
    pub pending_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>,
    pub pending_force_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>,
    pub waiting_close_channels: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse {
    fn default() -> &'a PendingChannelsResponse {
        <PendingChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse {
    pub fn new() -> PendingChannelsResponse {
        ::std::default::Default::default()
    }

    // int64 total_limbo_balance = 1;


    pub fn get_total_limbo_balance(&self) -> i64 {
        self.total_limbo_balance
    }
    pub fn clear_total_limbo_balance(&mut self) {
        self.total_limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_limbo_balance(&mut self, v: i64) {
        self.total_limbo_balance = v;
    }

    // repeated .lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;


    pub fn get_pending_open_channels(&self) -> &[PendingChannelsResponse_PendingOpenChannel] {
        &self.pending_open_channels
    }
    pub fn clear_pending_open_channels(&mut self) {
        self.pending_open_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_open_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>) {
        self.pending_open_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_open_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        &mut self.pending_open_channels
    }

    // Take field
    pub fn take_pending_open_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        ::std::mem::replace(&mut self.pending_open_channels, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3;


    pub fn get_pending_closing_channels(&self) -> &[PendingChannelsResponse_ClosedChannel] {
        &self.pending_closing_channels
    }
    pub fn clear_pending_closing_channels(&mut self) {
        self.pending_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>) {
        self.pending_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        &mut self.pending_closing_channels
    }

    // Take field
    pub fn take_pending_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        ::std::mem::replace(&mut self.pending_closing_channels, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;


    pub fn get_pending_force_closing_channels(&self) -> &[PendingChannelsResponse_ForceClosedChannel] {
        &self.pending_force_closing_channels
    }
    pub fn clear_pending_force_closing_channels(&mut self) {
        self.pending_force_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_force_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>) {
        self.pending_force_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_force_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        &mut self.pending_force_closing_channels
    }

    // Take field
    pub fn take_pending_force_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        ::std::mem::replace(&mut self.pending_force_closing_channels, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;


    pub fn get_waiting_close_channels(&self) -> &[PendingChannelsResponse_WaitingCloseChannel] {
        &self.waiting_close_channels
    }
    pub fn clear_waiting_close_channels(&mut self) {
        self.waiting_close_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_waiting_close_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>) {
        self.waiting_close_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waiting_close_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        &mut self.waiting_close_channels
    }

    // Take field
    pub fn take_waiting_close_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        ::std::mem::replace(&mut self.waiting_close_channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PendingChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_open_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_force_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.waiting_close_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_limbo_balance = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_open_channels)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_closing_channels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_force_closing_channels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.waiting_close_channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_open_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_force_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.waiting_close_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_limbo_balance != 0 {
            os.write_int64(1, self.total_limbo_balance)?;
        }
        for v in &self.pending_open_channels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_closing_channels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_force_closing_channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.waiting_close_channels {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse {
        PendingChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_limbo_balance",
                |m: &PendingChannelsResponse| { &m.total_limbo_balance },
                |m: &mut PendingChannelsResponse| { &mut m.total_limbo_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingOpenChannel>>(
                "pending_open_channels",
                |m: &PendingChannelsResponse| { &m.pending_open_channels },
                |m: &mut PendingChannelsResponse| { &mut m.pending_open_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ClosedChannel>>(
                "pending_closing_channels",
                |m: &PendingChannelsResponse| { &m.pending_closing_channels },
                |m: &mut PendingChannelsResponse| { &mut m.pending_closing_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ForceClosedChannel>>(
                "pending_force_closing_channels",
                |m: &PendingChannelsResponse| { &m.pending_force_closing_channels },
                |m: &mut PendingChannelsResponse| { &mut m.pending_force_closing_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_WaitingCloseChannel>>(
                "waiting_close_channels",
                |m: &PendingChannelsResponse| { &m.waiting_close_channels },
                |m: &mut PendingChannelsResponse| { &mut m.waiting_close_channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse>(
                "PendingChannelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse {
    fn clear(&mut self) {
        self.total_limbo_balance = 0;
        self.pending_open_channels.clear();
        self.pending_closing_channels.clear();
        self.pending_force_closing_channels.clear();
        self.waiting_close_channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse_PendingChannel {
    // message fields
    pub remote_node_pub: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    pub local_chan_reserve_sat: i64,
    pub remote_chan_reserve_sat: i64,
    pub initiator: Initiator,
    pub commitment_type: CommitmentType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_PendingChannel {
    fn default() -> &'a PendingChannelsResponse_PendingChannel {
        <PendingChannelsResponse_PendingChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_PendingChannel {
    pub fn new() -> PendingChannelsResponse_PendingChannel {
        ::std::default::Default::default()
    }

    // string remote_node_pub = 1;


    pub fn get_remote_node_pub(&self) -> &str {
        &self.remote_node_pub
    }
    pub fn clear_remote_node_pub(&mut self) {
        self.remote_node_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_node_pub(&mut self, v: ::std::string::String) {
        self.remote_node_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_node_pub(&mut self) -> &mut ::std::string::String {
        &mut self.remote_node_pub
    }

    // Take field
    pub fn take_remote_node_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_node_pub, ::std::string::String::new())
    }

    // string channel_point = 2;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // int64 capacity = 3;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // int64 local_balance = 4;


    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }
    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    // int64 remote_balance = 5;


    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }
    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    // int64 local_chan_reserve_sat = 6;


    pub fn get_local_chan_reserve_sat(&self) -> i64 {
        self.local_chan_reserve_sat
    }
    pub fn clear_local_chan_reserve_sat(&mut self) {
        self.local_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_chan_reserve_sat(&mut self, v: i64) {
        self.local_chan_reserve_sat = v;
    }

    // int64 remote_chan_reserve_sat = 7;


    pub fn get_remote_chan_reserve_sat(&self) -> i64 {
        self.remote_chan_reserve_sat
    }
    pub fn clear_remote_chan_reserve_sat(&mut self) {
        self.remote_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_chan_reserve_sat(&mut self, v: i64) {
        self.remote_chan_reserve_sat = v;
    }

    // .lnrpc.Initiator initiator = 8;


    pub fn get_initiator(&self) -> Initiator {
        self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator = Initiator::INITIATOR_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: Initiator) {
        self.initiator = v;
    }

    // .lnrpc.CommitmentType commitment_type = 9;


    pub fn get_commitment_type(&self) -> CommitmentType {
        self.commitment_type
    }
    pub fn clear_commitment_type(&mut self) {
        self.commitment_type = CommitmentType::LEGACY;
    }

    // Param is passed by value, moved
    pub fn set_commitment_type(&mut self, v: CommitmentType) {
        self.commitment_type = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingChannel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_node_pub)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_chan_reserve_sat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_chan_reserve_sat = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.initiator, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.commitment_type, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.remote_node_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.remote_node_pub);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_point);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.local_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.remote_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.initiator != Initiator::INITIATOR_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(8, self.initiator);
        }
        if self.commitment_type != CommitmentType::LEGACY {
            my_size += ::protobuf::rt::enum_size(9, self.commitment_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.remote_node_pub.is_empty() {
            os.write_string(1, &self.remote_node_pub)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(2, &self.channel_point)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(4, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(5, self.remote_balance)?;
        }
        if self.local_chan_reserve_sat != 0 {
            os.write_int64(6, self.local_chan_reserve_sat)?;
        }
        if self.remote_chan_reserve_sat != 0 {
            os.write_int64(7, self.remote_chan_reserve_sat)?;
        }
        if self.initiator != Initiator::INITIATOR_UNKNOWN {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.initiator))?;
        }
        if self.commitment_type != CommitmentType::LEGACY {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.commitment_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingChannel {
        PendingChannelsResponse_PendingChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_node_pub",
                |m: &PendingChannelsResponse_PendingChannel| { &m.remote_node_pub },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_node_pub },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_point",
                |m: &PendingChannelsResponse_PendingChannel| { &m.channel_point },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.channel_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "capacity",
                |m: &PendingChannelsResponse_PendingChannel| { &m.capacity },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "local_balance",
                |m: &PendingChannelsResponse_PendingChannel| { &m.local_balance },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.local_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remote_balance",
                |m: &PendingChannelsResponse_PendingChannel| { &m.remote_balance },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "local_chan_reserve_sat",
                |m: &PendingChannelsResponse_PendingChannel| { &m.local_chan_reserve_sat },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.local_chan_reserve_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remote_chan_reserve_sat",
                |m: &PendingChannelsResponse_PendingChannel| { &m.remote_chan_reserve_sat },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_chan_reserve_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Initiator>>(
                "initiator",
                |m: &PendingChannelsResponse_PendingChannel| { &m.initiator },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.initiator },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommitmentType>>(
                "commitment_type",
                |m: &PendingChannelsResponse_PendingChannel| { &m.commitment_type },
                |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.commitment_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse_PendingChannel>(
                "PendingChannelsResponse.PendingChannel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingChannel {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse_PendingChannel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse_PendingChannel::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingChannel {
    fn clear(&mut self) {
        self.remote_node_pub.clear();
        self.channel_point.clear();
        self.capacity = 0;
        self.local_balance = 0;
        self.remote_balance = 0;
        self.local_chan_reserve_sat = 0;
        self.remote_chan_reserve_sat = 0;
        self.initiator = Initiator::INITIATOR_UNKNOWN;
        self.commitment_type = CommitmentType::LEGACY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse_PendingOpenChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub confirmation_height: u32,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_PendingOpenChannel {
    fn default() -> &'a PendingChannelsResponse_PendingOpenChannel {
        <PendingChannelsResponse_PendingOpenChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_PendingOpenChannel {
    pub fn new() -> PendingChannelsResponse_PendingOpenChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| <PendingChannelsResponse_PendingChannel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // uint32 confirmation_height = 2;


    pub fn get_confirmation_height(&self) -> u32 {
        self.confirmation_height
    }
    pub fn clear_confirmation_height(&mut self) {
        self.confirmation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmation_height(&mut self, v: u32) {
        self.confirmation_height = v;
    }

    // int64 commit_fee = 4;


    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }
    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    // int64 commit_weight = 5;


    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }
    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    // int64 fee_per_kw = 6;


    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }
    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingOpenChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.confirmation_height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confirmation_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmation_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(5, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(6, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confirmation_height != 0 {
            os.write_uint32(2, self.confirmation_height)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(4, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(5, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(6, self.fee_per_kw)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingOpenChannel {
        PendingChannelsResponse_PendingOpenChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                "channel",
                |m: &PendingChannelsResponse_PendingOpenChannel| { &m.channel },
                |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "confirmation_height",
                |m: &PendingChannelsResponse_PendingOpenChannel| { &m.confirmation_height },
                |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.confirmation_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commit_fee",
                |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_fee },
                |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commit_weight",
                |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_weight },
                |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_per_kw",
                |m: &PendingChannelsResponse_PendingOpenChannel| { &m.fee_per_kw },
                |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.fee_per_kw },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse_PendingOpenChannel>(
                "PendingChannelsResponse.PendingOpenChannel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingOpenChannel {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse_PendingOpenChannel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse_PendingOpenChannel::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingOpenChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.confirmation_height = 0;
        self.commit_fee = 0;
        self.commit_weight = 0;
        self.fee_per_kw = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingOpenChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingOpenChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse_WaitingCloseChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub limbo_balance: i64,
    pub commitments: ::protobuf::SingularPtrField<PendingChannelsResponse_Commitments>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_WaitingCloseChannel {
    fn default() -> &'a PendingChannelsResponse_WaitingCloseChannel {
        <PendingChannelsResponse_WaitingCloseChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_WaitingCloseChannel {
    pub fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| <PendingChannelsResponse_PendingChannel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // int64 limbo_balance = 2;


    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }
    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    // .lnrpc.PendingChannelsResponse.Commitments commitments = 3;


    pub fn get_commitments(&self) -> &PendingChannelsResponse_Commitments {
        self.commitments.as_ref().unwrap_or_else(|| <PendingChannelsResponse_Commitments as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commitments(&mut self) {
        self.commitments.clear();
    }

    pub fn has_commitments(&self) -> bool {
        self.commitments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commitments(&mut self, v: PendingChannelsResponse_Commitments) {
        self.commitments = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commitments(&mut self) -> &mut PendingChannelsResponse_Commitments {
        if self.commitments.is_none() {
            self.commitments.set_default();
        }
        self.commitments.as_mut().unwrap()
    }

    // Take field
    pub fn take_commitments(&mut self) -> PendingChannelsResponse_Commitments {
        self.commitments.take().unwrap_or_else(|| PendingChannelsResponse_Commitments::new())
    }
}

impl ::protobuf::Message for PendingChannelsResponse_WaitingCloseChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commitments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commitments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.commitments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(2, self.limbo_balance)?;
        }
        if let Some(ref v) = self.commitments.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        PendingChannelsResponse_WaitingCloseChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                "channel",
                |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.channel },
                |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limbo_balance",
                |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.limbo_balance },
                |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.limbo_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_Commitments>>(
                "commitments",
                |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.commitments },
                |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.commitments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse_WaitingCloseChannel>(
                "PendingChannelsResponse.WaitingCloseChannel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse_WaitingCloseChannel {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse_WaitingCloseChannel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse_WaitingCloseChannel::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_WaitingCloseChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.limbo_balance = 0;
        self.commitments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_WaitingCloseChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_WaitingCloseChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse_Commitments {
    // message fields
    pub local_txid: ::std::string::String,
    pub remote_txid: ::std::string::String,
    pub remote_pending_txid: ::std::string::String,
    pub local_commit_fee_sat: u64,
    pub remote_commit_fee_sat: u64,
    pub remote_pending_commit_fee_sat: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_Commitments {
    fn default() -> &'a PendingChannelsResponse_Commitments {
        <PendingChannelsResponse_Commitments as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_Commitments {
    pub fn new() -> PendingChannelsResponse_Commitments {
        ::std::default::Default::default()
    }

    // string local_txid = 1;


    pub fn get_local_txid(&self) -> &str {
        &self.local_txid
    }
    pub fn clear_local_txid(&mut self) {
        self.local_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_txid(&mut self, v: ::std::string::String) {
        self.local_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_txid(&mut self) -> &mut ::std::string::String {
        &mut self.local_txid
    }

    // Take field
    pub fn take_local_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_txid, ::std::string::String::new())
    }

    // string remote_txid = 2;


    pub fn get_remote_txid(&self) -> &str {
        &self.remote_txid
    }
    pub fn clear_remote_txid(&mut self) {
        self.remote_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_txid(&mut self, v: ::std::string::String) {
        self.remote_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_txid(&mut self) -> &mut ::std::string::String {
        &mut self.remote_txid
    }

    // Take field
    pub fn take_remote_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_txid, ::std::string::String::new())
    }

    // string remote_pending_txid = 3;


    pub fn get_remote_pending_txid(&self) -> &str {
        &self.remote_pending_txid
    }
    pub fn clear_remote_pending_txid(&mut self) {
        self.remote_pending_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pending_txid(&mut self, v: ::std::string::String) {
        self.remote_pending_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pending_txid(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pending_txid
    }

    // Take field
    pub fn take_remote_pending_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pending_txid, ::std::string::String::new())
    }

    // uint64 local_commit_fee_sat = 4;


    pub fn get_local_commit_fee_sat(&self) -> u64 {
        self.local_commit_fee_sat
    }
    pub fn clear_local_commit_fee_sat(&mut self) {
        self.local_commit_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_commit_fee_sat(&mut self, v: u64) {
        self.local_commit_fee_sat = v;
    }

    // uint64 remote_commit_fee_sat = 5;


    pub fn get_remote_commit_fee_sat(&self) -> u64 {
        self.remote_commit_fee_sat
    }
    pub fn clear_remote_commit_fee_sat(&mut self) {
        self.remote_commit_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_commit_fee_sat(&mut self, v: u64) {
        self.remote_commit_fee_sat = v;
    }

    // uint64 remote_pending_commit_fee_sat = 6;


    pub fn get_remote_pending_commit_fee_sat(&self) -> u64 {
        self.remote_pending_commit_fee_sat
    }
    pub fn clear_remote_pending_commit_fee_sat(&mut self) {
        self.remote_pending_commit_fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_pending_commit_fee_sat(&mut self, v: u64) {
        self.remote_pending_commit_fee_sat = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_Commitments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_txid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_txid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pending_txid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.local_commit_fee_sat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remote_commit_fee_sat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remote_pending_commit_fee_sat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.local_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.local_txid);
        }
        if !self.remote_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.remote_txid);
        }
        if !self.remote_pending_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.remote_pending_txid);
        }
        if self.local_commit_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_commit_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_commit_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.remote_commit_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_pending_commit_fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.remote_pending_commit_fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.local_txid.is_empty() {
            os.write_string(1, &self.local_txid)?;
        }
        if !self.remote_txid.is_empty() {
            os.write_string(2, &self.remote_txid)?;
        }
        if !self.remote_pending_txid.is_empty() {
            os.write_string(3, &self.remote_pending_txid)?;
        }
        if self.local_commit_fee_sat != 0 {
            os.write_uint64(4, self.local_commit_fee_sat)?;
        }
        if self.remote_commit_fee_sat != 0 {
            os.write_uint64(5, self.remote_commit_fee_sat)?;
        }
        if self.remote_pending_commit_fee_sat != 0 {
            os.write_uint64(6, self.remote_pending_commit_fee_sat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_Commitments {
        PendingChannelsResponse_Commitments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_txid",
                |m: &PendingChannelsResponse_Commitments| { &m.local_txid },
                |m: &mut PendingChannelsResponse_Commitments| { &mut m.local_txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_txid",
                |m: &PendingChannelsResponse_Commitments| { &m.remote_txid },
                |m: &mut PendingChannelsResponse_Commitments| { &mut m.remote_txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_pending_txid",
                |m: &PendingChannelsResponse_Commitments| { &m.remote_pending_txid },
                |m: &mut PendingChannelsResponse_Commitments| { &mut m.remote_pending_txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "local_commit_fee_sat",
                |m: &PendingChannelsResponse_Commitments| { &m.local_commit_fee_sat },
                |m: &mut PendingChannelsResponse_Commitments| { &mut m.local_commit_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remote_commit_fee_sat",
                |m: &PendingChannelsResponse_Commitments| { &m.remote_commit_fee_sat },
                |m: &mut PendingChannelsResponse_Commitments| { &mut m.remote_commit_fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remote_pending_commit_fee_sat",
                |m: &PendingChannelsResponse_Commitments| { &m.remote_pending_commit_fee_sat },
                |m: &mut PendingChannelsResponse_Commitments| { &mut m.remote_pending_commit_fee_sat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse_Commitments>(
                "PendingChannelsResponse.Commitments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse_Commitments {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse_Commitments> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse_Commitments::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_Commitments {
    fn clear(&mut self) {
        self.local_txid.clear();
        self.remote_txid.clear();
        self.remote_pending_txid.clear();
        self.local_commit_fee_sat = 0;
        self.remote_commit_fee_sat = 0;
        self.remote_pending_commit_fee_sat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_Commitments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_Commitments {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse_ClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_ClosedChannel {
    fn default() -> &'a PendingChannelsResponse_ClosedChannel {
        <PendingChannelsResponse_ClosedChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_ClosedChannel {
    pub fn new() -> PendingChannelsResponse_ClosedChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| <PendingChannelsResponse_PendingChannel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // string closing_txid = 2;


    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }
    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ClosedChannel {
        PendingChannelsResponse_ClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                "channel",
                |m: &PendingChannelsResponse_ClosedChannel| { &m.channel },
                |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "closing_txid",
                |m: &PendingChannelsResponse_ClosedChannel| { &m.closing_txid },
                |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.closing_txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse_ClosedChannel>(
                "PendingChannelsResponse.ClosedChannel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse_ClosedChannel {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse_ClosedChannel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse_ClosedChannel::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ClosedChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.closing_txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingChannelsResponse_ForceClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    pub limbo_balance: i64,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub recovered_balance: i64,
    pub pending_htlcs: ::protobuf::RepeatedField<PendingHTLC>,
    pub anchor: PendingChannelsResponse_ForceClosedChannel_AnchorState,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_ForceClosedChannel {
    fn default() -> &'a PendingChannelsResponse_ForceClosedChannel {
        <PendingChannelsResponse_ForceClosedChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_ForceClosedChannel {
    pub fn new() -> PendingChannelsResponse_ForceClosedChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| <PendingChannelsResponse_PendingChannel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // string closing_txid = 2;


    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }
    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }

    // int64 limbo_balance = 3;


    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }
    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    // uint32 maturity_height = 4;


    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }
    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    // int32 blocks_til_maturity = 5;


    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }
    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    // int64 recovered_balance = 6;


    pub fn get_recovered_balance(&self) -> i64 {
        self.recovered_balance
    }
    pub fn clear_recovered_balance(&mut self) {
        self.recovered_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovered_balance(&mut self, v: i64) {
        self.recovered_balance = v;
    }

    // repeated .lnrpc.PendingHTLC pending_htlcs = 8;


    pub fn get_pending_htlcs(&self) -> &[PendingHTLC] {
        &self.pending_htlcs
    }
    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<PendingHTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<PendingHTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<PendingHTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    // .lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;


    pub fn get_anchor(&self) -> PendingChannelsResponse_ForceClosedChannel_AnchorState {
        self.anchor
    }
    pub fn clear_anchor(&mut self) {
        self.anchor = PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO;
    }

    // Param is passed by value, moved
    pub fn set_anchor(&mut self, v: PendingChannelsResponse_ForceClosedChannel_AnchorState) {
        self.anchor = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ForceClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.recovered_balance = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.anchor, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.recovered_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.recovered_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.anchor != PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO {
            my_size += ::protobuf::rt::enum_size(9, self.anchor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(3, self.limbo_balance)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.recovered_balance != 0 {
            os.write_int64(6, self.recovered_balance)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.anchor != PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.anchor))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ForceClosedChannel {
        PendingChannelsResponse_ForceClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                "channel",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.channel },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "closing_txid",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.closing_txid },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.closing_txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limbo_balance",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.limbo_balance },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.limbo_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maturity_height",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.maturity_height },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.maturity_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blocks_til_maturity",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.blocks_til_maturity },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.blocks_til_maturity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "recovered_balance",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.recovered_balance },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.recovered_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingHTLC>>(
                "pending_htlcs",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.pending_htlcs },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.pending_htlcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PendingChannelsResponse_ForceClosedChannel_AnchorState>>(
                "anchor",
                |m: &PendingChannelsResponse_ForceClosedChannel| { &m.anchor },
                |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.anchor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingChannelsResponse_ForceClosedChannel>(
                "PendingChannelsResponse.ForceClosedChannel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingChannelsResponse_ForceClosedChannel {
        static instance: ::protobuf::rt::LazyV2<PendingChannelsResponse_ForceClosedChannel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingChannelsResponse_ForceClosedChannel::new)
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ForceClosedChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.closing_txid.clear();
        self.limbo_balance = 0;
        self.maturity_height = 0;
        self.blocks_til_maturity = 0;
        self.recovered_balance = 0;
        self.pending_htlcs.clear();
        self.anchor = PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ForceClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ForceClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PendingChannelsResponse_ForceClosedChannel_AnchorState {
    LIMBO = 0,
    RECOVERED = 1,
    LOST = 2,
}

impl ::protobuf::ProtobufEnum for PendingChannelsResponse_ForceClosedChannel_AnchorState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PendingChannelsResponse_ForceClosedChannel_AnchorState> {
        match value {
            0 => ::std::option::Option::Some(PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO),
            1 => ::std::option::Option::Some(PendingChannelsResponse_ForceClosedChannel_AnchorState::RECOVERED),
            2 => ::std::option::Option::Some(PendingChannelsResponse_ForceClosedChannel_AnchorState::LOST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PendingChannelsResponse_ForceClosedChannel_AnchorState] = &[
            PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO,
            PendingChannelsResponse_ForceClosedChannel_AnchorState::RECOVERED,
            PendingChannelsResponse_ForceClosedChannel_AnchorState::LOST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PendingChannelsResponse_ForceClosedChannel_AnchorState>("PendingChannelsResponse.ForceClosedChannel.AnchorState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PendingChannelsResponse_ForceClosedChannel_AnchorState {
}

impl ::std::default::Default for PendingChannelsResponse_ForceClosedChannel_AnchorState {
    fn default() -> Self {
        PendingChannelsResponse_ForceClosedChannel_AnchorState::LIMBO
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ForceClosedChannel_AnchorState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelEventSubscription {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEventSubscription {
    fn default() -> &'a ChannelEventSubscription {
        <ChannelEventSubscription as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEventSubscription {
    pub fn new() -> ChannelEventSubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelEventSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEventSubscription {
        ChannelEventSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelEventSubscription>(
                "ChannelEventSubscription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelEventSubscription {
        static instance: ::protobuf::rt::LazyV2<ChannelEventSubscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelEventSubscription::new)
    }
}

impl ::protobuf::Clear for ChannelEventSubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEventSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEventSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelEventUpdate {
    // message fields
    pub field_type: ChannelEventUpdate_UpdateType,
    // message oneof groups
    pub channel: ::std::option::Option<ChannelEventUpdate_oneof_channel>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEventUpdate {
    fn default() -> &'a ChannelEventUpdate {
        <ChannelEventUpdate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ChannelEventUpdate_oneof_channel {
    open_channel(Channel),
    closed_channel(ChannelCloseSummary),
    active_channel(ChannelPoint),
    inactive_channel(ChannelPoint),
    pending_open_channel(PendingUpdate),
}

impl ChannelEventUpdate {
    pub fn new() -> ChannelEventUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.Channel open_channel = 1;


    pub fn get_open_channel(&self) -> &Channel {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(ref v)) => v,
            _ => <Channel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_open_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_open_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_channel(&mut self, v: Channel) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_channel(&mut self) -> &mut Channel {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(Channel::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_channel(&mut self) -> Channel {
        if self.has_open_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            Channel::new()
        }
    }

    // .lnrpc.ChannelCloseSummary closed_channel = 2;


    pub fn get_closed_channel(&self) -> &ChannelCloseSummary {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(ref v)) => v,
            _ => <ChannelCloseSummary as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_closed_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_closed_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_closed_channel(&mut self, v: ChannelCloseSummary) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_closed_channel(&mut self) -> &mut ChannelCloseSummary {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(ChannelCloseSummary::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_closed_channel(&mut self) -> ChannelCloseSummary {
        if self.has_closed_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelCloseSummary::new()
        }
    }

    // .lnrpc.ChannelPoint active_channel = 3;


    pub fn get_active_channel(&self) -> &ChannelPoint {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(ref v)) => v,
            _ => <ChannelPoint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_active_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_active_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_active_channel(&mut self, v: ChannelPoint) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_active_channel(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(ChannelPoint::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_active_channel(&mut self) -> ChannelPoint {
        if self.has_active_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    // .lnrpc.ChannelPoint inactive_channel = 4;


    pub fn get_inactive_channel(&self) -> &ChannelPoint {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(ref v)) => v,
            _ => <ChannelPoint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_inactive_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_inactive_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inactive_channel(&mut self, v: ChannelPoint) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inactive_channel(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(ChannelPoint::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inactive_channel(&mut self) -> ChannelPoint {
        if self.has_inactive_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    // .lnrpc.PendingUpdate pending_open_channel = 6;


    pub fn get_pending_open_channel(&self) -> &PendingUpdate {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(ref v)) => v,
            _ => <PendingUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pending_open_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_pending_open_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pending_open_channel(&mut self, v: PendingUpdate) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pending_open_channel(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(PendingUpdate::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pending_open_channel(&mut self) -> PendingUpdate {
        if self.has_pending_open_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    // .lnrpc.ChannelEventUpdate.UpdateType type = 5;


    pub fn get_field_type(&self) -> ChannelEventUpdate_UpdateType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ChannelEventUpdate_UpdateType::OPEN_CHANNEL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ChannelEventUpdate_UpdateType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ChannelEventUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(ChannelEventUpdate_oneof_channel::open_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::closed_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::active_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::inactive_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::pending_open_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::pending_open_channel(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ChannelEventUpdate_UpdateType::OPEN_CHANNEL {
            my_size += ::protobuf::rt::enum_size(5, self.field_type);
        }
        if let ::std::option::Option::Some(ref v) = self.channel {
            match v {
                &ChannelEventUpdate_oneof_channel::open_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::closed_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::active_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::inactive_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::pending_open_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ChannelEventUpdate_UpdateType::OPEN_CHANNEL {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.channel {
            match v {
                &ChannelEventUpdate_oneof_channel::open_channel(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::closed_channel(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::active_channel(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::inactive_channel(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::pending_open_channel(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEventUpdate {
        ChannelEventUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Channel>(
                "open_channel",
                ChannelEventUpdate::has_open_channel,
                ChannelEventUpdate::get_open_channel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelCloseSummary>(
                "closed_channel",
                ChannelEventUpdate::has_closed_channel,
                ChannelEventUpdate::get_closed_channel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                "active_channel",
                ChannelEventUpdate::has_active_channel,
                ChannelEventUpdate::get_active_channel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                "inactive_channel",
                ChannelEventUpdate::has_inactive_channel,
                ChannelEventUpdate::get_inactive_channel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                "pending_open_channel",
                ChannelEventUpdate::has_pending_open_channel,
                ChannelEventUpdate::get_pending_open_channel,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelEventUpdate_UpdateType>>(
                "type",
                |m: &ChannelEventUpdate| { &m.field_type },
                |m: &mut ChannelEventUpdate| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelEventUpdate>(
                "ChannelEventUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelEventUpdate {
        static instance: ::protobuf::rt::LazyV2<ChannelEventUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelEventUpdate::new)
    }
}

impl ::protobuf::Clear for ChannelEventUpdate {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.field_type = ChannelEventUpdate_UpdateType::OPEN_CHANNEL;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEventUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEventUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ChannelEventUpdate_UpdateType {
    OPEN_CHANNEL = 0,
    CLOSED_CHANNEL = 1,
    ACTIVE_CHANNEL = 2,
    INACTIVE_CHANNEL = 3,
    PENDING_OPEN_CHANNEL = 4,
}

impl ::protobuf::ProtobufEnum for ChannelEventUpdate_UpdateType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelEventUpdate_UpdateType> {
        match value {
            0 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::OPEN_CHANNEL),
            1 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::CLOSED_CHANNEL),
            2 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::ACTIVE_CHANNEL),
            3 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::INACTIVE_CHANNEL),
            4 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::PENDING_OPEN_CHANNEL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelEventUpdate_UpdateType] = &[
            ChannelEventUpdate_UpdateType::OPEN_CHANNEL,
            ChannelEventUpdate_UpdateType::CLOSED_CHANNEL,
            ChannelEventUpdate_UpdateType::ACTIVE_CHANNEL,
            ChannelEventUpdate_UpdateType::INACTIVE_CHANNEL,
            ChannelEventUpdate_UpdateType::PENDING_OPEN_CHANNEL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChannelEventUpdate_UpdateType>("ChannelEventUpdate.UpdateType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChannelEventUpdate_UpdateType {
}

impl ::std::default::Default for ChannelEventUpdate_UpdateType {
    fn default() -> Self {
        ChannelEventUpdate_UpdateType::OPEN_CHANNEL
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEventUpdate_UpdateType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WalletAccountBalance {
    // message fields
    pub confirmed_balance: i64,
    pub unconfirmed_balance: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletAccountBalance {
    fn default() -> &'a WalletAccountBalance {
        <WalletAccountBalance as ::protobuf::Message>::default_instance()
    }
}

impl WalletAccountBalance {
    pub fn new() -> WalletAccountBalance {
        ::std::default::Default::default()
    }

    // int64 confirmed_balance = 1;


    pub fn get_confirmed_balance(&self) -> i64 {
        self.confirmed_balance
    }
    pub fn clear_confirmed_balance(&mut self) {
        self.confirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmed_balance(&mut self, v: i64) {
        self.confirmed_balance = v;
    }

    // int64 unconfirmed_balance = 2;


    pub fn get_unconfirmed_balance(&self) -> i64 {
        self.unconfirmed_balance
    }
    pub fn clear_unconfirmed_balance(&mut self) {
        self.unconfirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed_balance(&mut self, v: i64) {
        self.unconfirmed_balance = v;
    }
}

impl ::protobuf::Message for WalletAccountBalance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.confirmed_balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unconfirmed_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.confirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.confirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unconfirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.unconfirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.confirmed_balance != 0 {
            os.write_int64(1, self.confirmed_balance)?;
        }
        if self.unconfirmed_balance != 0 {
            os.write_int64(2, self.unconfirmed_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletAccountBalance {
        WalletAccountBalance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "confirmed_balance",
                |m: &WalletAccountBalance| { &m.confirmed_balance },
                |m: &mut WalletAccountBalance| { &mut m.confirmed_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unconfirmed_balance",
                |m: &WalletAccountBalance| { &m.unconfirmed_balance },
                |m: &mut WalletAccountBalance| { &mut m.unconfirmed_balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WalletAccountBalance>(
                "WalletAccountBalance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WalletAccountBalance {
        static instance: ::protobuf::rt::LazyV2<WalletAccountBalance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WalletAccountBalance::new)
    }
}

impl ::protobuf::Clear for WalletAccountBalance {
    fn clear(&mut self) {
        self.confirmed_balance = 0;
        self.unconfirmed_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletAccountBalance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletAccountBalance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WalletBalanceRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletBalanceRequest {
    fn default() -> &'a WalletBalanceRequest {
        <WalletBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl WalletBalanceRequest {
    pub fn new() -> WalletBalanceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WalletBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletBalanceRequest {
        WalletBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WalletBalanceRequest>(
                "WalletBalanceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WalletBalanceRequest {
        static instance: ::protobuf::rt::LazyV2<WalletBalanceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WalletBalanceRequest::new)
    }
}

impl ::protobuf::Clear for WalletBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WalletBalanceResponse {
    // message fields
    pub total_balance: i64,
    pub confirmed_balance: i64,
    pub unconfirmed_balance: i64,
    pub account_balance: ::std::collections::HashMap<::std::string::String, WalletAccountBalance>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletBalanceResponse {
    fn default() -> &'a WalletBalanceResponse {
        <WalletBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl WalletBalanceResponse {
    pub fn new() -> WalletBalanceResponse {
        ::std::default::Default::default()
    }

    // int64 total_balance = 1;


    pub fn get_total_balance(&self) -> i64 {
        self.total_balance
    }
    pub fn clear_total_balance(&mut self) {
        self.total_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_balance(&mut self, v: i64) {
        self.total_balance = v;
    }

    // int64 confirmed_balance = 2;


    pub fn get_confirmed_balance(&self) -> i64 {
        self.confirmed_balance
    }
    pub fn clear_confirmed_balance(&mut self) {
        self.confirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmed_balance(&mut self, v: i64) {
        self.confirmed_balance = v;
    }

    // int64 unconfirmed_balance = 3;


    pub fn get_unconfirmed_balance(&self) -> i64 {
        self.unconfirmed_balance
    }
    pub fn clear_unconfirmed_balance(&mut self) {
        self.unconfirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed_balance(&mut self, v: i64) {
        self.unconfirmed_balance = v;
    }

    // repeated .lnrpc.WalletBalanceResponse.AccountBalanceEntry account_balance = 4;


    pub fn get_account_balance(&self) -> &::std::collections::HashMap<::std::string::String, WalletAccountBalance> {
        &self.account_balance
    }
    pub fn clear_account_balance(&mut self) {
        self.account_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_balance(&mut self, v: ::std::collections::HashMap<::std::string::String, WalletAccountBalance>) {
        self.account_balance = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_balance(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, WalletAccountBalance> {
        &mut self.account_balance
    }

    // Take field
    pub fn take_account_balance(&mut self) -> ::std::collections::HashMap<::std::string::String, WalletAccountBalance> {
        ::std::mem::replace(&mut self.account_balance, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for WalletBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.confirmed_balance = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unconfirmed_balance = tmp;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<WalletAccountBalance>>(wire_type, is, &mut self.account_balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.confirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unconfirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.unconfirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<WalletAccountBalance>>(4, &self.account_balance);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_balance != 0 {
            os.write_int64(1, self.total_balance)?;
        }
        if self.confirmed_balance != 0 {
            os.write_int64(2, self.confirmed_balance)?;
        }
        if self.unconfirmed_balance != 0 {
            os.write_int64(3, self.unconfirmed_balance)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<WalletAccountBalance>>(4, &self.account_balance, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletBalanceResponse {
        WalletBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_balance",
                |m: &WalletBalanceResponse| { &m.total_balance },
                |m: &mut WalletBalanceResponse| { &mut m.total_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "confirmed_balance",
                |m: &WalletBalanceResponse| { &m.confirmed_balance },
                |m: &mut WalletBalanceResponse| { &mut m.confirmed_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unconfirmed_balance",
                |m: &WalletBalanceResponse| { &m.unconfirmed_balance },
                |m: &mut WalletBalanceResponse| { &mut m.unconfirmed_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<WalletAccountBalance>>(
                "account_balance",
                |m: &WalletBalanceResponse| { &m.account_balance },
                |m: &mut WalletBalanceResponse| { &mut m.account_balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WalletBalanceResponse>(
                "WalletBalanceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WalletBalanceResponse {
        static instance: ::protobuf::rt::LazyV2<WalletBalanceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WalletBalanceResponse::new)
    }
}

impl ::protobuf::Clear for WalletBalanceResponse {
    fn clear(&mut self) {
        self.total_balance = 0;
        self.confirmed_balance = 0;
        self.unconfirmed_balance = 0;
        self.account_balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Amount {
    // message fields
    pub sat: u64,
    pub msat: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Amount {
    fn default() -> &'a Amount {
        <Amount as ::protobuf::Message>::default_instance()
    }
}

impl Amount {
    pub fn new() -> Amount {
        ::std::default::Default::default()
    }

    // uint64 sat = 1;


    pub fn get_sat(&self) -> u64 {
        self.sat
    }
    pub fn clear_sat(&mut self) {
        self.sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat(&mut self, v: u64) {
        self.sat = v;
    }

    // uint64 msat = 2;


    pub fn get_msat(&self) -> u64 {
        self.msat
    }
    pub fn clear_msat(&mut self) {
        self.msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_msat(&mut self, v: u64) {
        self.msat = v;
    }
}

impl ::protobuf::Message for Amount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.msat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sat != 0 {
            os.write_uint64(1, self.sat)?;
        }
        if self.msat != 0 {
            os.write_uint64(2, self.msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Amount {
        Amount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sat",
                |m: &Amount| { &m.sat },
                |m: &mut Amount| { &mut m.sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "msat",
                |m: &Amount| { &m.msat },
                |m: &mut Amount| { &mut m.msat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Amount>(
                "Amount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Amount {
        static instance: ::protobuf::rt::LazyV2<Amount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Amount::new)
    }
}

impl ::protobuf::Clear for Amount {
    fn clear(&mut self) {
        self.sat = 0;
        self.msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Amount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Amount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelBalanceRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBalanceRequest {
    fn default() -> &'a ChannelBalanceRequest {
        <ChannelBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBalanceRequest {
    pub fn new() -> ChannelBalanceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBalanceRequest {
        ChannelBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelBalanceRequest>(
                "ChannelBalanceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelBalanceRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelBalanceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelBalanceRequest::new)
    }
}

impl ::protobuf::Clear for ChannelBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelBalanceResponse {
    // message fields
    pub balance: i64,
    pub pending_open_balance: i64,
    pub local_balance: ::protobuf::SingularPtrField<Amount>,
    pub remote_balance: ::protobuf::SingularPtrField<Amount>,
    pub unsettled_local_balance: ::protobuf::SingularPtrField<Amount>,
    pub unsettled_remote_balance: ::protobuf::SingularPtrField<Amount>,
    pub pending_open_local_balance: ::protobuf::SingularPtrField<Amount>,
    pub pending_open_remote_balance: ::protobuf::SingularPtrField<Amount>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBalanceResponse {
    fn default() -> &'a ChannelBalanceResponse {
        <ChannelBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBalanceResponse {
    pub fn new() -> ChannelBalanceResponse {
        ::std::default::Default::default()
    }

    // int64 balance = 1;


    pub fn get_balance(&self) -> i64 {
        self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = v;
    }

    // int64 pending_open_balance = 2;


    pub fn get_pending_open_balance(&self) -> i64 {
        self.pending_open_balance
    }
    pub fn clear_pending_open_balance(&mut self) {
        self.pending_open_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending_open_balance(&mut self, v: i64) {
        self.pending_open_balance = v;
    }

    // .lnrpc.Amount local_balance = 3;


    pub fn get_local_balance(&self) -> &Amount {
        self.local_balance.as_ref().unwrap_or_else(|| <Amount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local_balance(&mut self) {
        self.local_balance.clear();
    }

    pub fn has_local_balance(&self) -> bool {
        self.local_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: Amount) {
        self.local_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_balance(&mut self) -> &mut Amount {
        if self.local_balance.is_none() {
            self.local_balance.set_default();
        }
        self.local_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_balance(&mut self) -> Amount {
        self.local_balance.take().unwrap_or_else(|| Amount::new())
    }

    // .lnrpc.Amount remote_balance = 4;


    pub fn get_remote_balance(&self) -> &Amount {
        self.remote_balance.as_ref().unwrap_or_else(|| <Amount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remote_balance(&mut self) {
        self.remote_balance.clear();
    }

    pub fn has_remote_balance(&self) -> bool {
        self.remote_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: Amount) {
        self.remote_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_balance(&mut self) -> &mut Amount {
        if self.remote_balance.is_none() {
            self.remote_balance.set_default();
        }
        self.remote_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_balance(&mut self) -> Amount {
        self.remote_balance.take().unwrap_or_else(|| Amount::new())
    }

    // .lnrpc.Amount unsettled_local_balance = 5;


    pub fn get_unsettled_local_balance(&self) -> &Amount {
        self.unsettled_local_balance.as_ref().unwrap_or_else(|| <Amount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unsettled_local_balance(&mut self) {
        self.unsettled_local_balance.clear();
    }

    pub fn has_unsettled_local_balance(&self) -> bool {
        self.unsettled_local_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsettled_local_balance(&mut self, v: Amount) {
        self.unsettled_local_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unsettled_local_balance(&mut self) -> &mut Amount {
        if self.unsettled_local_balance.is_none() {
            self.unsettled_local_balance.set_default();
        }
        self.unsettled_local_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_unsettled_local_balance(&mut self) -> Amount {
        self.unsettled_local_balance.take().unwrap_or_else(|| Amount::new())
    }

    // .lnrpc.Amount unsettled_remote_balance = 6;


    pub fn get_unsettled_remote_balance(&self) -> &Amount {
        self.unsettled_remote_balance.as_ref().unwrap_or_else(|| <Amount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unsettled_remote_balance(&mut self) {
        self.unsettled_remote_balance.clear();
    }

    pub fn has_unsettled_remote_balance(&self) -> bool {
        self.unsettled_remote_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsettled_remote_balance(&mut self, v: Amount) {
        self.unsettled_remote_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unsettled_remote_balance(&mut self) -> &mut Amount {
        if self.unsettled_remote_balance.is_none() {
            self.unsettled_remote_balance.set_default();
        }
        self.unsettled_remote_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_unsettled_remote_balance(&mut self) -> Amount {
        self.unsettled_remote_balance.take().unwrap_or_else(|| Amount::new())
    }

    // .lnrpc.Amount pending_open_local_balance = 7;


    pub fn get_pending_open_local_balance(&self) -> &Amount {
        self.pending_open_local_balance.as_ref().unwrap_or_else(|| <Amount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pending_open_local_balance(&mut self) {
        self.pending_open_local_balance.clear();
    }

    pub fn has_pending_open_local_balance(&self) -> bool {
        self.pending_open_local_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_open_local_balance(&mut self, v: Amount) {
        self.pending_open_local_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_open_local_balance(&mut self) -> &mut Amount {
        if self.pending_open_local_balance.is_none() {
            self.pending_open_local_balance.set_default();
        }
        self.pending_open_local_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_pending_open_local_balance(&mut self) -> Amount {
        self.pending_open_local_balance.take().unwrap_or_else(|| Amount::new())
    }

    // .lnrpc.Amount pending_open_remote_balance = 8;


    pub fn get_pending_open_remote_balance(&self) -> &Amount {
        self.pending_open_remote_balance.as_ref().unwrap_or_else(|| <Amount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pending_open_remote_balance(&mut self) {
        self.pending_open_remote_balance.clear();
    }

    pub fn has_pending_open_remote_balance(&self) -> bool {
        self.pending_open_remote_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_open_remote_balance(&mut self, v: Amount) {
        self.pending_open_remote_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pending_open_remote_balance(&mut self) -> &mut Amount {
        if self.pending_open_remote_balance.is_none() {
            self.pending_open_remote_balance.set_default();
        }
        self.pending_open_remote_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_pending_open_remote_balance(&mut self) -> Amount {
        self.pending_open_remote_balance.take().unwrap_or_else(|| Amount::new())
    }
}

impl ::protobuf::Message for ChannelBalanceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.local_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsettled_local_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsettled_remote_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_open_local_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_open_remote_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pending_open_balance = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_balance)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_balance)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unsettled_local_balance)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unsettled_remote_balance)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pending_open_local_balance)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pending_open_remote_balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pending_open_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pending_open_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.local_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unsettled_local_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unsettled_remote_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pending_open_local_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pending_open_remote_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.balance != 0 {
            os.write_int64(1, self.balance)?;
        }
        if self.pending_open_balance != 0 {
            os.write_int64(2, self.pending_open_balance)?;
        }
        if let Some(ref v) = self.local_balance.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_balance.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unsettled_local_balance.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unsettled_remote_balance.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pending_open_local_balance.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pending_open_remote_balance.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBalanceResponse {
        ChannelBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "balance",
                |m: &ChannelBalanceResponse| { &m.balance },
                |m: &mut ChannelBalanceResponse| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pending_open_balance",
                |m: &ChannelBalanceResponse| { &m.pending_open_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.pending_open_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Amount>>(
                "local_balance",
                |m: &ChannelBalanceResponse| { &m.local_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.local_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Amount>>(
                "remote_balance",
                |m: &ChannelBalanceResponse| { &m.remote_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.remote_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Amount>>(
                "unsettled_local_balance",
                |m: &ChannelBalanceResponse| { &m.unsettled_local_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.unsettled_local_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Amount>>(
                "unsettled_remote_balance",
                |m: &ChannelBalanceResponse| { &m.unsettled_remote_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.unsettled_remote_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Amount>>(
                "pending_open_local_balance",
                |m: &ChannelBalanceResponse| { &m.pending_open_local_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.pending_open_local_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Amount>>(
                "pending_open_remote_balance",
                |m: &ChannelBalanceResponse| { &m.pending_open_remote_balance },
                |m: &mut ChannelBalanceResponse| { &mut m.pending_open_remote_balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelBalanceResponse>(
                "ChannelBalanceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelBalanceResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelBalanceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelBalanceResponse::new)
    }
}

impl ::protobuf::Clear for ChannelBalanceResponse {
    fn clear(&mut self) {
        self.balance = 0;
        self.pending_open_balance = 0;
        self.local_balance.clear();
        self.remote_balance.clear();
        self.unsettled_local_balance.clear();
        self.unsettled_remote_balance.clear();
        self.pending_open_local_balance.clear();
        self.pending_open_remote_balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryRoutesRequest {
    // message fields
    pub pub_key: ::std::string::String,
    pub amt: i64,
    pub amt_msat: i64,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<FeeLimit>,
    pub ignored_nodes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub ignored_edges: ::protobuf::RepeatedField<EdgeLocator>,
    pub source_pub_key: ::std::string::String,
    pub use_mission_control: bool,
    pub ignored_pairs: ::protobuf::RepeatedField<NodePair>,
    pub cltv_limit: u32,
    pub dest_custom_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    pub outgoing_chan_id: u64,
    pub last_hop_pubkey: ::std::vec::Vec<u8>,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    pub dest_features: ::std::vec::Vec<FeatureBit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRoutesRequest {
    fn default() -> &'a QueryRoutesRequest {
        <QueryRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRoutesRequest {
    pub fn new() -> QueryRoutesRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // int64 amt = 2;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int64 amt_msat = 12;


    pub fn get_amt_msat(&self) -> i64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: i64) {
        self.amt_msat = v;
    }

    // int32 final_cltv_delta = 4;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // .lnrpc.FeeLimit fee_limit = 5;


    pub fn get_fee_limit(&self) -> &FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| <FeeLimit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| FeeLimit::new())
    }

    // repeated bytes ignored_nodes = 6;


    pub fn get_ignored_nodes(&self) -> &[::std::vec::Vec<u8>] {
        &self.ignored_nodes
    }
    pub fn clear_ignored_nodes(&mut self) {
        self.ignored_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignored_nodes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.ignored_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignored_nodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.ignored_nodes
    }

    // Take field
    pub fn take_ignored_nodes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.ignored_nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.EdgeLocator ignored_edges = 7;


    pub fn get_ignored_edges(&self) -> &[EdgeLocator] {
        &self.ignored_edges
    }
    pub fn clear_ignored_edges(&mut self) {
        self.ignored_edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignored_edges(&mut self, v: ::protobuf::RepeatedField<EdgeLocator>) {
        self.ignored_edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignored_edges(&mut self) -> &mut ::protobuf::RepeatedField<EdgeLocator> {
        &mut self.ignored_edges
    }

    // Take field
    pub fn take_ignored_edges(&mut self) -> ::protobuf::RepeatedField<EdgeLocator> {
        ::std::mem::replace(&mut self.ignored_edges, ::protobuf::RepeatedField::new())
    }

    // string source_pub_key = 8;


    pub fn get_source_pub_key(&self) -> &str {
        &self.source_pub_key
    }
    pub fn clear_source_pub_key(&mut self) {
        self.source_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_pub_key(&mut self, v: ::std::string::String) {
        self.source_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.source_pub_key
    }

    // Take field
    pub fn take_source_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_pub_key, ::std::string::String::new())
    }

    // bool use_mission_control = 9;


    pub fn get_use_mission_control(&self) -> bool {
        self.use_mission_control
    }
    pub fn clear_use_mission_control(&mut self) {
        self.use_mission_control = false;
    }

    // Param is passed by value, moved
    pub fn set_use_mission_control(&mut self, v: bool) {
        self.use_mission_control = v;
    }

    // repeated .lnrpc.NodePair ignored_pairs = 10;


    pub fn get_ignored_pairs(&self) -> &[NodePair] {
        &self.ignored_pairs
    }
    pub fn clear_ignored_pairs(&mut self) {
        self.ignored_pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignored_pairs(&mut self, v: ::protobuf::RepeatedField<NodePair>) {
        self.ignored_pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignored_pairs(&mut self) -> &mut ::protobuf::RepeatedField<NodePair> {
        &mut self.ignored_pairs
    }

    // Take field
    pub fn take_ignored_pairs(&mut self) -> ::protobuf::RepeatedField<NodePair> {
        ::std::mem::replace(&mut self.ignored_pairs, ::protobuf::RepeatedField::new())
    }

    // uint32 cltv_limit = 11;


    pub fn get_cltv_limit(&self) -> u32 {
        self.cltv_limit
    }
    pub fn clear_cltv_limit(&mut self) {
        self.cltv_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_limit(&mut self, v: u32) {
        self.cltv_limit = v;
    }

    // repeated .lnrpc.QueryRoutesRequest.DestCustomRecordsEntry dest_custom_records = 13;


    pub fn get_dest_custom_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.dest_custom_records
    }
    pub fn clear_dest_custom_records(&mut self) {
        self.dest_custom_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_custom_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.dest_custom_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_custom_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.dest_custom_records
    }

    // Take field
    pub fn take_dest_custom_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.dest_custom_records, ::std::collections::HashMap::new())
    }

    // uint64 outgoing_chan_id = 14;


    pub fn get_outgoing_chan_id(&self) -> u64 {
        self.outgoing_chan_id
    }
    pub fn clear_outgoing_chan_id(&mut self) {
        self.outgoing_chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_id(&mut self, v: u64) {
        self.outgoing_chan_id = v;
    }

    // bytes last_hop_pubkey = 15;


    pub fn get_last_hop_pubkey(&self) -> &[u8] {
        &self.last_hop_pubkey
    }
    pub fn clear_last_hop_pubkey(&mut self) {
        self.last_hop_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_hop_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_hop_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_hop_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.last_hop_pubkey
    }

    // Take field
    pub fn take_last_hop_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.last_hop_pubkey, ::std::vec::Vec::new())
    }

    // repeated .lnrpc.RouteHint route_hints = 16;


    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.FeatureBit dest_features = 17;


    pub fn get_dest_features(&self) -> &[FeatureBit] {
        &self.dest_features
    }
    pub fn clear_dest_features(&mut self) {
        self.dest_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_features(&mut self, v: ::std::vec::Vec<FeatureBit>) {
        self.dest_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_features(&mut self) -> &mut ::std::vec::Vec<FeatureBit> {
        &mut self.dest_features
    }

    // Take field
    pub fn take_dest_features(&mut self) -> ::std::vec::Vec<FeatureBit> {
        ::std::mem::replace(&mut self.dest_features, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryRoutesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ignored_edges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ignored_pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.ignored_nodes)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ignored_edges)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_pub_key)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_mission_control = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ignored_pairs)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_limit = tmp;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.dest_custom_records)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_chan_id = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.last_hop_pubkey)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.dest_features, 17, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(12, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(4, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ignored_nodes {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in &self.ignored_edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.source_pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.source_pub_key);
        }
        if self.use_mission_control != false {
            my_size += 2;
        }
        for value in &self.ignored_pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.cltv_limit != 0 {
            my_size += ::protobuf::rt::value_size(11, self.cltv_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(13, &self.dest_custom_records);
        if self.outgoing_chan_id != 0 {
            my_size += ::protobuf::rt::value_size(14, self.outgoing_chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.last_hop_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.last_hop_pubkey);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dest_features {
            my_size += ::protobuf::rt::enum_size(17, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.amt != 0 {
            os.write_int64(2, self.amt)?;
        }
        if self.amt_msat != 0 {
            os.write_int64(12, self.amt_msat)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(4, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ignored_nodes {
            os.write_bytes(6, &v)?;
        };
        for v in &self.ignored_edges {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.source_pub_key.is_empty() {
            os.write_string(8, &self.source_pub_key)?;
        }
        if self.use_mission_control != false {
            os.write_bool(9, self.use_mission_control)?;
        }
        for v in &self.ignored_pairs {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.cltv_limit != 0 {
            os.write_uint32(11, self.cltv_limit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(13, &self.dest_custom_records, os)?;
        if self.outgoing_chan_id != 0 {
            os.write_uint64(14, self.outgoing_chan_id)?;
        }
        if !self.last_hop_pubkey.is_empty() {
            os.write_bytes(15, &self.last_hop_pubkey)?;
        }
        for v in &self.route_hints {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dest_features {
            os.write_enum(17, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesRequest {
        QueryRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &QueryRoutesRequest| { &m.pub_key },
                |m: &mut QueryRoutesRequest| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt",
                |m: &QueryRoutesRequest| { &m.amt },
                |m: &mut QueryRoutesRequest| { &mut m.amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_msat",
                |m: &QueryRoutesRequest| { &m.amt_msat },
                |m: &mut QueryRoutesRequest| { &mut m.amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "final_cltv_delta",
                |m: &QueryRoutesRequest| { &m.final_cltv_delta },
                |m: &mut QueryRoutesRequest| { &mut m.final_cltv_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeLimit>>(
                "fee_limit",
                |m: &QueryRoutesRequest| { &m.fee_limit },
                |m: &mut QueryRoutesRequest| { &mut m.fee_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ignored_nodes",
                |m: &QueryRoutesRequest| { &m.ignored_nodes },
                |m: &mut QueryRoutesRequest| { &mut m.ignored_nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLocator>>(
                "ignored_edges",
                |m: &QueryRoutesRequest| { &m.ignored_edges },
                |m: &mut QueryRoutesRequest| { &mut m.ignored_edges },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_pub_key",
                |m: &QueryRoutesRequest| { &m.source_pub_key },
                |m: &mut QueryRoutesRequest| { &mut m.source_pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_mission_control",
                |m: &QueryRoutesRequest| { &m.use_mission_control },
                |m: &mut QueryRoutesRequest| { &mut m.use_mission_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePair>>(
                "ignored_pairs",
                |m: &QueryRoutesRequest| { &m.ignored_pairs },
                |m: &mut QueryRoutesRequest| { &mut m.ignored_pairs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cltv_limit",
                |m: &QueryRoutesRequest| { &m.cltv_limit },
                |m: &mut QueryRoutesRequest| { &mut m.cltv_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                "dest_custom_records",
                |m: &QueryRoutesRequest| { &m.dest_custom_records },
                |m: &mut QueryRoutesRequest| { &mut m.dest_custom_records },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "outgoing_chan_id",
                |m: &QueryRoutesRequest| { &m.outgoing_chan_id },
                |m: &mut QueryRoutesRequest| { &mut m.outgoing_chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "last_hop_pubkey",
                |m: &QueryRoutesRequest| { &m.last_hop_pubkey },
                |m: &mut QueryRoutesRequest| { &mut m.last_hop_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                "route_hints",
                |m: &QueryRoutesRequest| { &m.route_hints },
                |m: &mut QueryRoutesRequest| { &mut m.route_hints },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FeatureBit>>(
                "dest_features",
                |m: &QueryRoutesRequest| { &m.dest_features },
                |m: &mut QueryRoutesRequest| { &mut m.dest_features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryRoutesRequest>(
                "QueryRoutesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryRoutesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryRoutesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryRoutesRequest::new)
    }
}

impl ::protobuf::Clear for QueryRoutesRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.amt = 0;
        self.amt_msat = 0;
        self.final_cltv_delta = 0;
        self.fee_limit.clear();
        self.ignored_nodes.clear();
        self.ignored_edges.clear();
        self.source_pub_key.clear();
        self.use_mission_control = false;
        self.ignored_pairs.clear();
        self.cltv_limit = 0;
        self.dest_custom_records.clear();
        self.outgoing_chan_id = 0;
        self.last_hop_pubkey.clear();
        self.route_hints.clear();
        self.dest_features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodePair {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePair {
    fn default() -> &'a NodePair {
        <NodePair as ::protobuf::Message>::default_instance()
    }
}

impl NodePair {
    pub fn new() -> NodePair {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes to = 2;


    pub fn get_to(&self) -> &[u8] {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NodePair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePair {
        NodePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "from",
                |m: &NodePair| { &m.from },
                |m: &mut NodePair| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "to",
                |m: &NodePair| { &m.to },
                |m: &mut NodePair| { &mut m.to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodePair>(
                "NodePair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodePair {
        static instance: ::protobuf::rt::LazyV2<NodePair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodePair::new)
    }
}

impl ::protobuf::Clear for NodePair {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EdgeLocator {
    // message fields
    pub channel_id: u64,
    pub direction_reverse: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeLocator {
    fn default() -> &'a EdgeLocator {
        <EdgeLocator as ::protobuf::Message>::default_instance()
    }
}

impl EdgeLocator {
    pub fn new() -> EdgeLocator {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // bool direction_reverse = 2;


    pub fn get_direction_reverse(&self) -> bool {
        self.direction_reverse
    }
    pub fn clear_direction_reverse(&mut self) {
        self.direction_reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_direction_reverse(&mut self, v: bool) {
        self.direction_reverse = v;
    }
}

impl ::protobuf::Message for EdgeLocator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.direction_reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.direction_reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if self.direction_reverse != false {
            os.write_bool(2, self.direction_reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeLocator {
        EdgeLocator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "channel_id",
                |m: &EdgeLocator| { &m.channel_id },
                |m: &mut EdgeLocator| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "direction_reverse",
                |m: &EdgeLocator| { &m.direction_reverse },
                |m: &mut EdgeLocator| { &mut m.direction_reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeLocator>(
                "EdgeLocator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EdgeLocator {
        static instance: ::protobuf::rt::LazyV2<EdgeLocator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EdgeLocator::new)
    }
}

impl ::protobuf::Clear for EdgeLocator {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.direction_reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeLocator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeLocator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryRoutesResponse {
    // message fields
    pub routes: ::protobuf::RepeatedField<Route>,
    pub success_prob: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRoutesResponse {
    fn default() -> &'a QueryRoutesResponse {
        <QueryRoutesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryRoutesResponse {
    pub fn new() -> QueryRoutesResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Route routes = 1;


    pub fn get_routes(&self) -> &[Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    // double success_prob = 2;


    pub fn get_success_prob(&self) -> f64 {
        self.success_prob
    }
    pub fn clear_success_prob(&mut self) {
        self.success_prob = 0.;
    }

    // Param is passed by value, moved
    pub fn set_success_prob(&mut self, v: f64) {
        self.success_prob = v;
    }
}

impl ::protobuf::Message for QueryRoutesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.success_prob = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.success_prob != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.success_prob != 0. {
            os.write_double(2, self.success_prob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesResponse {
        QueryRoutesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                "routes",
                |m: &QueryRoutesResponse| { &m.routes },
                |m: &mut QueryRoutesResponse| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "success_prob",
                |m: &QueryRoutesResponse| { &m.success_prob },
                |m: &mut QueryRoutesResponse| { &mut m.success_prob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryRoutesResponse>(
                "QueryRoutesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryRoutesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryRoutesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryRoutesResponse::new)
    }
}

impl ::protobuf::Clear for QueryRoutesResponse {
    fn clear(&mut self) {
        self.routes.clear();
        self.success_prob = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Hop {
    // message fields
    pub chan_id: u64,
    pub chan_capacity: i64,
    pub amt_to_forward: i64,
    pub fee: i64,
    pub expiry: u32,
    pub amt_to_forward_msat: i64,
    pub fee_msat: i64,
    pub pub_key: ::std::string::String,
    pub tlv_payload: bool,
    pub mpp_record: ::protobuf::SingularPtrField<MPPRecord>,
    pub amp_record: ::protobuf::SingularPtrField<AMPRecord>,
    pub custom_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hop {
    fn default() -> &'a Hop {
        <Hop as ::protobuf::Message>::default_instance()
    }
}

impl Hop {
    pub fn new() -> Hop {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // int64 chan_capacity = 2;


    pub fn get_chan_capacity(&self) -> i64 {
        self.chan_capacity
    }
    pub fn clear_chan_capacity(&mut self) {
        self.chan_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_capacity(&mut self, v: i64) {
        self.chan_capacity = v;
    }

    // int64 amt_to_forward = 3;


    pub fn get_amt_to_forward(&self) -> i64 {
        self.amt_to_forward
    }
    pub fn clear_amt_to_forward(&mut self) {
        self.amt_to_forward = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_to_forward(&mut self, v: i64) {
        self.amt_to_forward = v;
    }

    // int64 fee = 4;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // uint32 expiry = 5;


    pub fn get_expiry(&self) -> u32 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: u32) {
        self.expiry = v;
    }

    // int64 amt_to_forward_msat = 6;


    pub fn get_amt_to_forward_msat(&self) -> i64 {
        self.amt_to_forward_msat
    }
    pub fn clear_amt_to_forward_msat(&mut self) {
        self.amt_to_forward_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_to_forward_msat(&mut self, v: i64) {
        self.amt_to_forward_msat = v;
    }

    // int64 fee_msat = 7;


    pub fn get_fee_msat(&self) -> i64 {
        self.fee_msat
    }
    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: i64) {
        self.fee_msat = v;
    }

    // string pub_key = 8;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // bool tlv_payload = 9;


    pub fn get_tlv_payload(&self) -> bool {
        self.tlv_payload
    }
    pub fn clear_tlv_payload(&mut self) {
        self.tlv_payload = false;
    }

    // Param is passed by value, moved
    pub fn set_tlv_payload(&mut self, v: bool) {
        self.tlv_payload = v;
    }

    // .lnrpc.MPPRecord mpp_record = 10;


    pub fn get_mpp_record(&self) -> &MPPRecord {
        self.mpp_record.as_ref().unwrap_or_else(|| <MPPRecord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mpp_record(&mut self) {
        self.mpp_record.clear();
    }

    pub fn has_mpp_record(&self) -> bool {
        self.mpp_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mpp_record(&mut self, v: MPPRecord) {
        self.mpp_record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mpp_record(&mut self) -> &mut MPPRecord {
        if self.mpp_record.is_none() {
            self.mpp_record.set_default();
        }
        self.mpp_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_mpp_record(&mut self) -> MPPRecord {
        self.mpp_record.take().unwrap_or_else(|| MPPRecord::new())
    }

    // .lnrpc.AMPRecord amp_record = 12;


    pub fn get_amp_record(&self) -> &AMPRecord {
        self.amp_record.as_ref().unwrap_or_else(|| <AMPRecord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amp_record(&mut self) {
        self.amp_record.clear();
    }

    pub fn has_amp_record(&self) -> bool {
        self.amp_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amp_record(&mut self, v: AMPRecord) {
        self.amp_record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amp_record(&mut self) -> &mut AMPRecord {
        if self.amp_record.is_none() {
            self.amp_record.set_default();
        }
        self.amp_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_amp_record(&mut self) -> AMPRecord {
        self.amp_record.take().unwrap_or_else(|| AMPRecord::new())
    }

    // repeated .lnrpc.Hop.CustomRecordsEntry custom_records = 11;


    pub fn get_custom_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.custom_records
    }
    pub fn clear_custom_records(&mut self) {
        self.custom_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.custom_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.custom_records
    }

    // Take field
    pub fn take_custom_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.custom_records, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Hop {
    fn is_initialized(&self) -> bool {
        for v in &self.mpp_record {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amp_record {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.chan_capacity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_to_forward = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiry = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_to_forward_msat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_msat = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tlv_payload = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mpp_record)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amp_record)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.custom_records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_capacity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_to_forward != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt_to_forward, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_to_forward_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.amt_to_forward_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.pub_key);
        }
        if self.tlv_payload != false {
            my_size += 2;
        }
        if let Some(ref v) = self.mpp_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.amp_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.custom_records);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.chan_capacity != 0 {
            os.write_int64(2, self.chan_capacity)?;
        }
        if self.amt_to_forward != 0 {
            os.write_int64(3, self.amt_to_forward)?;
        }
        if self.fee != 0 {
            os.write_int64(4, self.fee)?;
        }
        if self.expiry != 0 {
            os.write_uint32(5, self.expiry)?;
        }
        if self.amt_to_forward_msat != 0 {
            os.write_int64(6, self.amt_to_forward_msat)?;
        }
        if self.fee_msat != 0 {
            os.write_int64(7, self.fee_msat)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(8, &self.pub_key)?;
        }
        if self.tlv_payload != false {
            os.write_bool(9, self.tlv_payload)?;
        }
        if let Some(ref v) = self.mpp_record.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.amp_record.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.custom_records, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hop {
        Hop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &Hop| { &m.chan_id },
                |m: &mut Hop| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "chan_capacity",
                |m: &Hop| { &m.chan_capacity },
                |m: &mut Hop| { &mut m.chan_capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_to_forward",
                |m: &Hop| { &m.amt_to_forward },
                |m: &mut Hop| { &mut m.amt_to_forward },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee",
                |m: &Hop| { &m.fee },
                |m: &mut Hop| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expiry",
                |m: &Hop| { &m.expiry },
                |m: &mut Hop| { &mut m.expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_to_forward_msat",
                |m: &Hop| { &m.amt_to_forward_msat },
                |m: &mut Hop| { &mut m.amt_to_forward_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_msat",
                |m: &Hop| { &m.fee_msat },
                |m: &mut Hop| { &mut m.fee_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &Hop| { &m.pub_key },
                |m: &mut Hop| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tlv_payload",
                |m: &Hop| { &m.tlv_payload },
                |m: &mut Hop| { &mut m.tlv_payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MPPRecord>>(
                "mpp_record",
                |m: &Hop| { &m.mpp_record },
                |m: &mut Hop| { &mut m.mpp_record },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AMPRecord>>(
                "amp_record",
                |m: &Hop| { &m.amp_record },
                |m: &mut Hop| { &mut m.amp_record },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                "custom_records",
                |m: &Hop| { &m.custom_records },
                |m: &mut Hop| { &mut m.custom_records },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hop>(
                "Hop",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Hop {
        static instance: ::protobuf::rt::LazyV2<Hop> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Hop::new)
    }
}

impl ::protobuf::Clear for Hop {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.chan_capacity = 0;
        self.amt_to_forward = 0;
        self.fee = 0;
        self.expiry = 0;
        self.amt_to_forward_msat = 0;
        self.fee_msat = 0;
        self.pub_key.clear();
        self.tlv_payload = false;
        self.mpp_record.clear();
        self.amp_record.clear();
        self.custom_records.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hop {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MPPRecord {
    // message fields
    pub payment_addr: ::std::vec::Vec<u8>,
    pub total_amt_msat: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MPPRecord {
    fn default() -> &'a MPPRecord {
        <MPPRecord as ::protobuf::Message>::default_instance()
    }
}

impl MPPRecord {
    pub fn new() -> MPPRecord {
        ::std::default::Default::default()
    }

    // bytes payment_addr = 11;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }

    // int64 total_amt_msat = 10;


    pub fn get_total_amt_msat(&self) -> i64 {
        self.total_amt_msat
    }
    pub fn clear_total_amt_msat(&mut self) {
        self.total_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt_msat(&mut self, v: i64) {
        self.total_amt_msat = v;
    }
}

impl ::protobuf::Message for MPPRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.payment_addr);
        }
        if self.total_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(10, self.total_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_addr.is_empty() {
            os.write_bytes(11, &self.payment_addr)?;
        }
        if self.total_amt_msat != 0 {
            os.write_int64(10, self.total_amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MPPRecord {
        MPPRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &MPPRecord| { &m.payment_addr },
                |m: &mut MPPRecord| { &mut m.payment_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_amt_msat",
                |m: &MPPRecord| { &m.total_amt_msat },
                |m: &mut MPPRecord| { &mut m.total_amt_msat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MPPRecord>(
                "MPPRecord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MPPRecord {
        static instance: ::protobuf::rt::LazyV2<MPPRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MPPRecord::new)
    }
}

impl ::protobuf::Clear for MPPRecord {
    fn clear(&mut self) {
        self.payment_addr.clear();
        self.total_amt_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MPPRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MPPRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AMPRecord {
    // message fields
    pub root_share: ::std::vec::Vec<u8>,
    pub set_id: ::std::vec::Vec<u8>,
    pub child_index: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AMPRecord {
    fn default() -> &'a AMPRecord {
        <AMPRecord as ::protobuf::Message>::default_instance()
    }
}

impl AMPRecord {
    pub fn new() -> AMPRecord {
        ::std::default::Default::default()
    }

    // bytes root_share = 1;


    pub fn get_root_share(&self) -> &[u8] {
        &self.root_share
    }
    pub fn clear_root_share(&mut self) {
        self.root_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_root_share(&mut self, v: ::std::vec::Vec<u8>) {
        self.root_share = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_share(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.root_share
    }

    // Take field
    pub fn take_root_share(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.root_share, ::std::vec::Vec::new())
    }

    // bytes set_id = 2;


    pub fn get_set_id(&self) -> &[u8] {
        &self.set_id
    }
    pub fn clear_set_id(&mut self) {
        self.set_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.set_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.set_id
    }

    // Take field
    pub fn take_set_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.set_id, ::std::vec::Vec::new())
    }

    // uint32 child_index = 3;


    pub fn get_child_index(&self) -> u32 {
        self.child_index
    }
    pub fn clear_child_index(&mut self) {
        self.child_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_child_index(&mut self, v: u32) {
        self.child_index = v;
    }
}

impl ::protobuf::Message for AMPRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.root_share)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.set_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.child_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.root_share.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.root_share);
        }
        if !self.set_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.set_id);
        }
        if self.child_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.child_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.root_share.is_empty() {
            os.write_bytes(1, &self.root_share)?;
        }
        if !self.set_id.is_empty() {
            os.write_bytes(2, &self.set_id)?;
        }
        if self.child_index != 0 {
            os.write_uint32(3, self.child_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AMPRecord {
        AMPRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "root_share",
                |m: &AMPRecord| { &m.root_share },
                |m: &mut AMPRecord| { &mut m.root_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "set_id",
                |m: &AMPRecord| { &m.set_id },
                |m: &mut AMPRecord| { &mut m.set_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "child_index",
                |m: &AMPRecord| { &m.child_index },
                |m: &mut AMPRecord| { &mut m.child_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AMPRecord>(
                "AMPRecord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AMPRecord {
        static instance: ::protobuf::rt::LazyV2<AMPRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AMPRecord::new)
    }
}

impl ::protobuf::Clear for AMPRecord {
    fn clear(&mut self) {
        self.root_share.clear();
        self.set_id.clear();
        self.child_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AMPRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AMPRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Route {
    // message fields
    pub total_time_lock: u32,
    pub total_fees: i64,
    pub total_amt: i64,
    pub hops: ::protobuf::RepeatedField<Hop>,
    pub total_fees_msat: i64,
    pub total_amt_msat: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Route {
    fn default() -> &'a Route {
        <Route as ::protobuf::Message>::default_instance()
    }
}

impl Route {
    pub fn new() -> Route {
        ::std::default::Default::default()
    }

    // uint32 total_time_lock = 1;


    pub fn get_total_time_lock(&self) -> u32 {
        self.total_time_lock
    }
    pub fn clear_total_time_lock(&mut self) {
        self.total_time_lock = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_time_lock(&mut self, v: u32) {
        self.total_time_lock = v;
    }

    // int64 total_fees = 2;


    pub fn get_total_fees(&self) -> i64 {
        self.total_fees
    }
    pub fn clear_total_fees(&mut self) {
        self.total_fees = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees(&mut self, v: i64) {
        self.total_fees = v;
    }

    // int64 total_amt = 3;


    pub fn get_total_amt(&self) -> i64 {
        self.total_amt
    }
    pub fn clear_total_amt(&mut self) {
        self.total_amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt(&mut self, v: i64) {
        self.total_amt = v;
    }

    // repeated .lnrpc.Hop hops = 4;


    pub fn get_hops(&self) -> &[Hop] {
        &self.hops
    }
    pub fn clear_hops(&mut self) {
        self.hops.clear();
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: ::protobuf::RepeatedField<Hop>) {
        self.hops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hops(&mut self) -> &mut ::protobuf::RepeatedField<Hop> {
        &mut self.hops
    }

    // Take field
    pub fn take_hops(&mut self) -> ::protobuf::RepeatedField<Hop> {
        ::std::mem::replace(&mut self.hops, ::protobuf::RepeatedField::new())
    }

    // int64 total_fees_msat = 5;


    pub fn get_total_fees_msat(&self) -> i64 {
        self.total_fees_msat
    }
    pub fn clear_total_fees_msat(&mut self) {
        self.total_fees_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees_msat(&mut self, v: i64) {
        self.total_fees_msat = v;
    }

    // int64 total_amt_msat = 6;


    pub fn get_total_amt_msat(&self) -> i64 {
        self.total_amt_msat
    }
    pub fn clear_total_amt_msat(&mut self) {
        self.total_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt_msat(&mut self, v: i64) {
        self.total_amt_msat = v;
    }
}

impl ::protobuf::Message for Route {
    fn is_initialized(&self) -> bool {
        for v in &self.hops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_time_lock = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hops)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_time_lock != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_time_lock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_fees != 0 {
            my_size += ::protobuf::rt::value_size(2, self.total_fees, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_amt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_amt, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.total_fees_msat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.total_fees_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_time_lock != 0 {
            os.write_uint32(1, self.total_time_lock)?;
        }
        if self.total_fees != 0 {
            os.write_int64(2, self.total_fees)?;
        }
        if self.total_amt != 0 {
            os.write_int64(3, self.total_amt)?;
        }
        for v in &self.hops {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.total_fees_msat != 0 {
            os.write_int64(5, self.total_fees_msat)?;
        }
        if self.total_amt_msat != 0 {
            os.write_int64(6, self.total_amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Route {
        Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_time_lock",
                |m: &Route| { &m.total_time_lock },
                |m: &mut Route| { &mut m.total_time_lock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_fees",
                |m: &Route| { &m.total_fees },
                |m: &mut Route| { &mut m.total_fees },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_amt",
                |m: &Route| { &m.total_amt },
                |m: &mut Route| { &mut m.total_amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hop>>(
                "hops",
                |m: &Route| { &m.hops },
                |m: &mut Route| { &mut m.hops },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_fees_msat",
                |m: &Route| { &m.total_fees_msat },
                |m: &mut Route| { &mut m.total_fees_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_amt_msat",
                |m: &Route| { &m.total_amt_msat },
                |m: &mut Route| { &mut m.total_amt_msat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Route>(
                "Route",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Route {
        static instance: ::protobuf::rt::LazyV2<Route> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Route::new)
    }
}

impl ::protobuf::Clear for Route {
    fn clear(&mut self) {
        self.total_time_lock = 0;
        self.total_fees = 0;
        self.total_amt = 0;
        self.hops.clear();
        self.total_fees_msat = 0;
        self.total_amt_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Route {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeInfoRequest {
    // message fields
    pub pub_key: ::std::string::String,
    pub include_channels: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfoRequest {
    fn default() -> &'a NodeInfoRequest {
        <NodeInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfoRequest {
    pub fn new() -> NodeInfoRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // bool include_channels = 2;


    pub fn get_include_channels(&self) -> bool {
        self.include_channels
    }
    pub fn clear_include_channels(&mut self) {
        self.include_channels = false;
    }

    // Param is passed by value, moved
    pub fn set_include_channels(&mut self, v: bool) {
        self.include_channels = v;
    }
}

impl ::protobuf::Message for NodeInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_channels = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.include_channels != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.include_channels != false {
            os.write_bool(2, self.include_channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfoRequest {
        NodeInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &NodeInfoRequest| { &m.pub_key },
                |m: &mut NodeInfoRequest| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_channels",
                |m: &NodeInfoRequest| { &m.include_channels },
                |m: &mut NodeInfoRequest| { &mut m.include_channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfoRequest>(
                "NodeInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfoRequest {
        static instance: ::protobuf::rt::LazyV2<NodeInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfoRequest::new)
    }
}

impl ::protobuf::Clear for NodeInfoRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.include_channels = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeInfo {
    // message fields
    pub node: ::protobuf::SingularPtrField<LightningNode>,
    pub num_channels: u32,
    pub total_capacity: i64,
    pub channels: ::protobuf::RepeatedField<ChannelEdge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo {
    fn default() -> &'a NodeInfo {
        <NodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo {
    pub fn new() -> NodeInfo {
        ::std::default::Default::default()
    }

    // .lnrpc.LightningNode node = 1;


    pub fn get_node(&self) -> &LightningNode {
        self.node.as_ref().unwrap_or_else(|| <LightningNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: LightningNode) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut LightningNode {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> LightningNode {
        self.node.take().unwrap_or_else(|| LightningNode::new())
    }

    // uint32 num_channels = 2;


    pub fn get_num_channels(&self) -> u32 {
        self.num_channels
    }
    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: u32) {
        self.num_channels = v;
    }

    // int64 total_capacity = 3;


    pub fn get_total_capacity(&self) -> i64 {
        self.total_capacity
    }
    pub fn clear_total_capacity(&mut self) {
        self.total_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_capacity(&mut self, v: i64) {
        self.total_capacity = v;
    }

    // repeated .lnrpc.ChannelEdge channels = 4;


    pub fn get_channels(&self) -> &[ChannelEdge] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<ChannelEdge>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdge> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<ChannelEdge> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_channels = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_capacity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(2, self.num_channels)?;
        }
        if self.total_capacity != 0 {
            os.write_int64(3, self.total_capacity)?;
        }
        for v in &self.channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo {
        NodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                "node",
                |m: &NodeInfo| { &m.node },
                |m: &mut NodeInfo| { &mut m.node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_channels",
                |m: &NodeInfo| { &m.num_channels },
                |m: &mut NodeInfo| { &mut m.num_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_capacity",
                |m: &NodeInfo| { &m.total_capacity },
                |m: &mut NodeInfo| { &mut m.total_capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdge>>(
                "channels",
                |m: &NodeInfo| { &m.channels },
                |m: &mut NodeInfo| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo>(
                "NodeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo {
    fn clear(&mut self) {
        self.node.clear();
        self.num_channels = 0;
        self.total_capacity = 0;
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LightningNode {
    // message fields
    pub last_update: u32,
    pub pub_key: ::std::string::String,
    pub alias: ::std::string::String,
    pub addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub color: ::std::string::String,
    pub features: ::std::collections::HashMap<u32, Feature>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightningNode {
    fn default() -> &'a LightningNode {
        <LightningNode as ::protobuf::Message>::default_instance()
    }
}

impl LightningNode {
    pub fn new() -> LightningNode {
        ::std::default::Default::default()
    }

    // uint32 last_update = 1;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    // string pub_key = 2;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string alias = 3;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // repeated .lnrpc.NodeAddress addresses = 4;


    pub fn get_addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // string color = 5;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }

    // repeated .lnrpc.LightningNode.FeaturesEntry features = 6;


    pub fn get_features(&self) -> &::std::collections::HashMap<u32, Feature> {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::collections::HashMap<u32, Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::std::collections::HashMap<u32, Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::collections::HashMap<u32, Feature> {
        ::std::mem::replace(&mut self.features, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for LightningNode {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(wire_type, is, &mut self.features)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(1, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pub_key);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.alias);
        }
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(6, &self.features);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.last_update != 0 {
            os.write_uint32(1, self.last_update)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(2, &self.pub_key)?;
        }
        if !self.alias.is_empty() {
            os.write_string(3, &self.alias)?;
        }
        for v in &self.addresses {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(6, &self.features, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningNode {
        LightningNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_update",
                |m: &LightningNode| { &m.last_update },
                |m: &mut LightningNode| { &mut m.last_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pub_key",
                |m: &LightningNode| { &m.pub_key },
                |m: &mut LightningNode| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alias",
                |m: &LightningNode| { &m.alias },
                |m: &mut LightningNode| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                "addresses",
                |m: &LightningNode| { &m.addresses },
                |m: &mut LightningNode| { &mut m.addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &LightningNode| { &m.color },
                |m: &mut LightningNode| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &LightningNode| { &m.features },
                |m: &mut LightningNode| { &mut m.features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LightningNode>(
                "LightningNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LightningNode {
        static instance: ::protobuf::rt::LazyV2<LightningNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LightningNode::new)
    }
}

impl ::protobuf::Clear for LightningNode {
    fn clear(&mut self) {
        self.last_update = 0;
        self.pub_key.clear();
        self.alias.clear();
        self.addresses.clear();
        self.color.clear();
        self.features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeAddress {
    // message fields
    pub network: ::std::string::String,
    pub addr: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // string network = 1;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    // string addr = 2;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "network",
                |m: &NodeAddress| { &m.network },
                |m: &mut NodeAddress| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addr",
                |m: &NodeAddress| { &m.addr },
                |m: &mut NodeAddress| { &mut m.addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeAddress>(
                "NodeAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeAddress {
        static instance: ::protobuf::rt::LazyV2<NodeAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeAddress::new)
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.network.clear();
        self.addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RoutingPolicy {
    // message fields
    pub time_lock_delta: u32,
    pub min_htlc: i64,
    pub fee_base_msat: i64,
    pub fee_rate_milli_msat: i64,
    pub disabled: bool,
    pub max_htlc_msat: u64,
    pub last_update: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingPolicy {
    fn default() -> &'a RoutingPolicy {
        <RoutingPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RoutingPolicy {
    pub fn new() -> RoutingPolicy {
        ::std::default::Default::default()
    }

    // uint32 time_lock_delta = 1;


    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    // int64 min_htlc = 2;


    pub fn get_min_htlc(&self) -> i64 {
        self.min_htlc
    }
    pub fn clear_min_htlc(&mut self) {
        self.min_htlc = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc(&mut self, v: i64) {
        self.min_htlc = v;
    }

    // int64 fee_base_msat = 3;


    pub fn get_fee_base_msat(&self) -> i64 {
        self.fee_base_msat
    }
    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: i64) {
        self.fee_base_msat = v;
    }

    // int64 fee_rate_milli_msat = 4;


    pub fn get_fee_rate_milli_msat(&self) -> i64 {
        self.fee_rate_milli_msat
    }
    pub fn clear_fee_rate_milli_msat(&mut self) {
        self.fee_rate_milli_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate_milli_msat(&mut self, v: i64) {
        self.fee_rate_milli_msat = v;
    }

    // bool disabled = 5;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }

    // uint64 max_htlc_msat = 6;


    pub fn get_max_htlc_msat(&self) -> u64 {
        self.max_htlc_msat
    }
    pub fn clear_max_htlc_msat(&mut self) {
        self.max_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_htlc_msat(&mut self, v: u64) {
        self.max_htlc_msat = v;
    }

    // uint32 last_update = 7;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }
}

impl ::protobuf::Message for RoutingPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_rate_milli_msat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_htlc_msat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_htlc, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate_milli_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_rate_milli_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disabled != false {
            my_size += 2;
        }
        if self.max_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(7, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time_lock_delta != 0 {
            os.write_uint32(1, self.time_lock_delta)?;
        }
        if self.min_htlc != 0 {
            os.write_int64(2, self.min_htlc)?;
        }
        if self.fee_base_msat != 0 {
            os.write_int64(3, self.fee_base_msat)?;
        }
        if self.fee_rate_milli_msat != 0 {
            os.write_int64(4, self.fee_rate_milli_msat)?;
        }
        if self.disabled != false {
            os.write_bool(5, self.disabled)?;
        }
        if self.max_htlc_msat != 0 {
            os.write_uint64(6, self.max_htlc_msat)?;
        }
        if self.last_update != 0 {
            os.write_uint32(7, self.last_update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingPolicy {
        RoutingPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_lock_delta",
                |m: &RoutingPolicy| { &m.time_lock_delta },
                |m: &mut RoutingPolicy| { &mut m.time_lock_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_htlc",
                |m: &RoutingPolicy| { &m.min_htlc },
                |m: &mut RoutingPolicy| { &mut m.min_htlc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_base_msat",
                |m: &RoutingPolicy| { &m.fee_base_msat },
                |m: &mut RoutingPolicy| { &mut m.fee_base_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_rate_milli_msat",
                |m: &RoutingPolicy| { &m.fee_rate_milli_msat },
                |m: &mut RoutingPolicy| { &mut m.fee_rate_milli_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &RoutingPolicy| { &m.disabled },
                |m: &mut RoutingPolicy| { &mut m.disabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_htlc_msat",
                |m: &RoutingPolicy| { &m.max_htlc_msat },
                |m: &mut RoutingPolicy| { &mut m.max_htlc_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_update",
                |m: &RoutingPolicy| { &m.last_update },
                |m: &mut RoutingPolicy| { &mut m.last_update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingPolicy>(
                "RoutingPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingPolicy {
        static instance: ::protobuf::rt::LazyV2<RoutingPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingPolicy::new)
    }
}

impl ::protobuf::Clear for RoutingPolicy {
    fn clear(&mut self) {
        self.time_lock_delta = 0;
        self.min_htlc = 0;
        self.fee_base_msat = 0;
        self.fee_rate_milli_msat = 0;
        self.disabled = false;
        self.max_htlc_msat = 0;
        self.last_update = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelEdge {
    // message fields
    pub channel_id: u64,
    pub chan_point: ::std::string::String,
    pub last_update: u32,
    pub node1_pub: ::std::string::String,
    pub node2_pub: ::std::string::String,
    pub capacity: i64,
    pub node1_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub node2_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEdge {
    fn default() -> &'a ChannelEdge {
        <ChannelEdge as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEdge {
    pub fn new() -> ChannelEdge {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // string chan_point = 2;


    pub fn get_chan_point(&self) -> &str {
        &self.chan_point
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ::std::string::String) {
        self.chan_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ::std::string::String {
        &mut self.chan_point
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_point, ::std::string::String::new())
    }

    // uint32 last_update = 3;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    // string node1_pub = 4;


    pub fn get_node1_pub(&self) -> &str {
        &self.node1_pub
    }
    pub fn clear_node1_pub(&mut self) {
        self.node1_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node1_pub(&mut self, v: ::std::string::String) {
        self.node1_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node1_pub
    }

    // Take field
    pub fn take_node1_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node1_pub, ::std::string::String::new())
    }

    // string node2_pub = 5;


    pub fn get_node2_pub(&self) -> &str {
        &self.node2_pub
    }
    pub fn clear_node2_pub(&mut self) {
        self.node2_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node2_pub(&mut self, v: ::std::string::String) {
        self.node2_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node2_pub
    }

    // Take field
    pub fn take_node2_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node2_pub, ::std::string::String::new())
    }

    // int64 capacity = 6;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // .lnrpc.RoutingPolicy node1_policy = 7;


    pub fn get_node1_policy(&self) -> &RoutingPolicy {
        self.node1_policy.as_ref().unwrap_or_else(|| <RoutingPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node1_policy(&mut self) {
        self.node1_policy.clear();
    }

    pub fn has_node1_policy(&self) -> bool {
        self.node1_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node1_policy(&mut self, v: RoutingPolicy) {
        self.node1_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_policy(&mut self) -> &mut RoutingPolicy {
        if self.node1_policy.is_none() {
            self.node1_policy.set_default();
        }
        self.node1_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node1_policy(&mut self) -> RoutingPolicy {
        self.node1_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    // .lnrpc.RoutingPolicy node2_policy = 8;


    pub fn get_node2_policy(&self) -> &RoutingPolicy {
        self.node2_policy.as_ref().unwrap_or_else(|| <RoutingPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node2_policy(&mut self) {
        self.node2_policy.clear();
    }

    pub fn has_node2_policy(&self) -> bool {
        self.node2_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node2_policy(&mut self, v: RoutingPolicy) {
        self.node2_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_policy(&mut self) -> &mut RoutingPolicy {
        if self.node2_policy.is_none() {
            self.node2_policy.set_default();
        }
        self.node2_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node2_policy(&mut self) -> RoutingPolicy {
        self.node2_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }
}

impl ::protobuf::Message for ChannelEdge {
    fn is_initialized(&self) -> bool {
        for v in &self.node1_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node2_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node1_pub)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node2_pub)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node1_policy)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node2_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chan_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chan_point);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node1_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node1_pub);
        }
        if !self.node2_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node2_pub);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if !self.chan_point.is_empty() {
            os.write_string(2, &self.chan_point)?;
        }
        if self.last_update != 0 {
            os.write_uint32(3, self.last_update)?;
        }
        if !self.node1_pub.is_empty() {
            os.write_string(4, &self.node1_pub)?;
        }
        if !self.node2_pub.is_empty() {
            os.write_string(5, &self.node2_pub)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdge {
        ChannelEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "channel_id",
                |m: &ChannelEdge| { &m.channel_id },
                |m: &mut ChannelEdge| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chan_point",
                |m: &ChannelEdge| { &m.chan_point },
                |m: &mut ChannelEdge| { &mut m.chan_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_update",
                |m: &ChannelEdge| { &m.last_update },
                |m: &mut ChannelEdge| { &mut m.last_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node1_pub",
                |m: &ChannelEdge| { &m.node1_pub },
                |m: &mut ChannelEdge| { &mut m.node1_pub },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node2_pub",
                |m: &ChannelEdge| { &m.node2_pub },
                |m: &mut ChannelEdge| { &mut m.node2_pub },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "capacity",
                |m: &ChannelEdge| { &m.capacity },
                |m: &mut ChannelEdge| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                "node1_policy",
                |m: &ChannelEdge| { &m.node1_policy },
                |m: &mut ChannelEdge| { &mut m.node1_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                "node2_policy",
                |m: &ChannelEdge| { &m.node2_policy },
                |m: &mut ChannelEdge| { &mut m.node2_policy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelEdge>(
                "ChannelEdge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelEdge {
        static instance: ::protobuf::rt::LazyV2<ChannelEdge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelEdge::new)
    }
}

impl ::protobuf::Clear for ChannelEdge {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.chan_point.clear();
        self.last_update = 0;
        self.node1_pub.clear();
        self.node2_pub.clear();
        self.capacity = 0;
        self.node1_policy.clear();
        self.node2_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelGraphRequest {
    // message fields
    pub include_unannounced: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelGraphRequest {
    fn default() -> &'a ChannelGraphRequest {
        <ChannelGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelGraphRequest {
    pub fn new() -> ChannelGraphRequest {
        ::std::default::Default::default()
    }

    // bool include_unannounced = 1;


    pub fn get_include_unannounced(&self) -> bool {
        self.include_unannounced
    }
    pub fn clear_include_unannounced(&mut self) {
        self.include_unannounced = false;
    }

    // Param is passed by value, moved
    pub fn set_include_unannounced(&mut self, v: bool) {
        self.include_unannounced = v;
    }
}

impl ::protobuf::Message for ChannelGraphRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_unannounced = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_unannounced != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.include_unannounced != false {
            os.write_bool(1, self.include_unannounced)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraphRequest {
        ChannelGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_unannounced",
                |m: &ChannelGraphRequest| { &m.include_unannounced },
                |m: &mut ChannelGraphRequest| { &mut m.include_unannounced },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelGraphRequest>(
                "ChannelGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelGraphRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelGraphRequest::new)
    }
}

impl ::protobuf::Clear for ChannelGraphRequest {
    fn clear(&mut self) {
        self.include_unannounced = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelGraph {
    // message fields
    pub nodes: ::protobuf::RepeatedField<LightningNode>,
    pub edges: ::protobuf::RepeatedField<ChannelEdge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelGraph {
    fn default() -> &'a ChannelGraph {
        <ChannelGraph as ::protobuf::Message>::default_instance()
    }
}

impl ChannelGraph {
    pub fn new() -> ChannelGraph {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.LightningNode nodes = 1;


    pub fn get_nodes(&self) -> &[LightningNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<LightningNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<LightningNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<LightningNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.ChannelEdge edges = 2;


    pub fn get_edges(&self) -> &[ChannelEdge] {
        &self.edges
    }
    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::protobuf::RepeatedField<ChannelEdge>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdge> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::protobuf::RepeatedField<ChannelEdge> {
        ::std::mem::replace(&mut self.edges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelGraph {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraph {
        ChannelGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                "nodes",
                |m: &ChannelGraph| { &m.nodes },
                |m: &mut ChannelGraph| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdge>>(
                "edges",
                |m: &ChannelGraph| { &m.edges },
                |m: &mut ChannelGraph| { &mut m.edges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelGraph>(
                "ChannelGraph",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelGraph {
        static instance: ::protobuf::rt::LazyV2<ChannelGraph> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelGraph::new)
    }
}

impl ::protobuf::Clear for ChannelGraph {
    fn clear(&mut self) {
        self.nodes.clear();
        self.edges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeMetricsRequest {
    // message fields
    pub types: ::std::vec::Vec<NodeMetricType>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeMetricsRequest {
    fn default() -> &'a NodeMetricsRequest {
        <NodeMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodeMetricsRequest {
    pub fn new() -> NodeMetricsRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.NodeMetricType types = 1;


    pub fn get_types(&self) -> &[NodeMetricType] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<NodeMetricType>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<NodeMetricType> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<NodeMetricType> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NodeMetricsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.types {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeMetricsRequest {
        NodeMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeMetricType>>(
                "types",
                |m: &NodeMetricsRequest| { &m.types },
                |m: &mut NodeMetricsRequest| { &mut m.types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeMetricsRequest>(
                "NodeMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<NodeMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeMetricsRequest::new)
    }
}

impl ::protobuf::Clear for NodeMetricsRequest {
    fn clear(&mut self) {
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeMetricsResponse {
    // message fields
    pub betweenness_centrality: ::std::collections::HashMap<::std::string::String, FloatMetric>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeMetricsResponse {
    fn default() -> &'a NodeMetricsResponse {
        <NodeMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl NodeMetricsResponse {
    pub fn new() -> NodeMetricsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.NodeMetricsResponse.BetweennessCentralityEntry betweenness_centrality = 1;


    pub fn get_betweenness_centrality(&self) -> &::std::collections::HashMap<::std::string::String, FloatMetric> {
        &self.betweenness_centrality
    }
    pub fn clear_betweenness_centrality(&mut self) {
        self.betweenness_centrality.clear();
    }

    // Param is passed by value, moved
    pub fn set_betweenness_centrality(&mut self, v: ::std::collections::HashMap<::std::string::String, FloatMetric>) {
        self.betweenness_centrality = v;
    }

    // Mutable pointer to the field.
    pub fn mut_betweenness_centrality(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, FloatMetric> {
        &mut self.betweenness_centrality
    }

    // Take field
    pub fn take_betweenness_centrality(&mut self) -> ::std::collections::HashMap<::std::string::String, FloatMetric> {
        ::std::mem::replace(&mut self.betweenness_centrality, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for NodeMetricsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FloatMetric>>(wire_type, is, &mut self.betweenness_centrality)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FloatMetric>>(1, &self.betweenness_centrality);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FloatMetric>>(1, &self.betweenness_centrality, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeMetricsResponse {
        NodeMetricsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FloatMetric>>(
                "betweenness_centrality",
                |m: &NodeMetricsResponse| { &m.betweenness_centrality },
                |m: &mut NodeMetricsResponse| { &mut m.betweenness_centrality },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeMetricsResponse>(
                "NodeMetricsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeMetricsResponse {
        static instance: ::protobuf::rt::LazyV2<NodeMetricsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeMetricsResponse::new)
    }
}

impl ::protobuf::Clear for NodeMetricsResponse {
    fn clear(&mut self) {
        self.betweenness_centrality.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeMetricsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FloatMetric {
    // message fields
    pub value: f64,
    pub normalized_value: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatMetric {
    fn default() -> &'a FloatMetric {
        <FloatMetric as ::protobuf::Message>::default_instance()
    }
}

impl FloatMetric {
    pub fn new() -> FloatMetric {
        ::std::default::Default::default()
    }

    // double value = 1;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // double normalized_value = 2;


    pub fn get_normalized_value(&self) -> f64 {
        self.normalized_value
    }
    pub fn clear_normalized_value(&mut self) {
        self.normalized_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_normalized_value(&mut self, v: f64) {
        self.normalized_value = v;
    }
}

impl ::protobuf::Message for FloatMetric {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.normalized_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 9;
        }
        if self.normalized_value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        if self.normalized_value != 0. {
            os.write_double(2, self.normalized_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatMetric {
        FloatMetric::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &FloatMetric| { &m.value },
                |m: &mut FloatMetric| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "normalized_value",
                |m: &FloatMetric| { &m.normalized_value },
                |m: &mut FloatMetric| { &mut m.normalized_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatMetric>(
                "FloatMetric",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatMetric {
        static instance: ::protobuf::rt::LazyV2<FloatMetric> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatMetric::new)
    }
}

impl ::protobuf::Clear for FloatMetric {
    fn clear(&mut self) {
        self.value = 0.;
        self.normalized_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatMetric {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChanInfoRequest {
    // message fields
    pub chan_id: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanInfoRequest {
    fn default() -> &'a ChanInfoRequest {
        <ChanInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChanInfoRequest {
    pub fn new() -> ChanInfoRequest {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }
}

impl ::protobuf::Message for ChanInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanInfoRequest {
        ChanInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &ChanInfoRequest| { &m.chan_id },
                |m: &mut ChanInfoRequest| { &mut m.chan_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChanInfoRequest>(
                "ChanInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChanInfoRequest {
        static instance: ::protobuf::rt::LazyV2<ChanInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChanInfoRequest::new)
    }
}

impl ::protobuf::Clear for ChanInfoRequest {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NetworkInfoRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkInfoRequest {
    fn default() -> &'a NetworkInfoRequest {
        <NetworkInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl NetworkInfoRequest {
    pub fn new() -> NetworkInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NetworkInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkInfoRequest {
        NetworkInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkInfoRequest>(
                "NetworkInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkInfoRequest {
        static instance: ::protobuf::rt::LazyV2<NetworkInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkInfoRequest::new)
    }
}

impl ::protobuf::Clear for NetworkInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NetworkInfo {
    // message fields
    pub graph_diameter: u32,
    pub avg_out_degree: f64,
    pub max_out_degree: u32,
    pub num_nodes: u32,
    pub num_channels: u32,
    pub total_network_capacity: i64,
    pub avg_channel_size: f64,
    pub min_channel_size: i64,
    pub max_channel_size: i64,
    pub median_channel_size_sat: i64,
    pub num_zombie_chans: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkInfo {
    fn default() -> &'a NetworkInfo {
        <NetworkInfo as ::protobuf::Message>::default_instance()
    }
}

impl NetworkInfo {
    pub fn new() -> NetworkInfo {
        ::std::default::Default::default()
    }

    // uint32 graph_diameter = 1;


    pub fn get_graph_diameter(&self) -> u32 {
        self.graph_diameter
    }
    pub fn clear_graph_diameter(&mut self) {
        self.graph_diameter = 0;
    }

    // Param is passed by value, moved
    pub fn set_graph_diameter(&mut self, v: u32) {
        self.graph_diameter = v;
    }

    // double avg_out_degree = 2;


    pub fn get_avg_out_degree(&self) -> f64 {
        self.avg_out_degree
    }
    pub fn clear_avg_out_degree(&mut self) {
        self.avg_out_degree = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_out_degree(&mut self, v: f64) {
        self.avg_out_degree = v;
    }

    // uint32 max_out_degree = 3;


    pub fn get_max_out_degree(&self) -> u32 {
        self.max_out_degree
    }
    pub fn clear_max_out_degree(&mut self) {
        self.max_out_degree = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_out_degree(&mut self, v: u32) {
        self.max_out_degree = v;
    }

    // uint32 num_nodes = 4;


    pub fn get_num_nodes(&self) -> u32 {
        self.num_nodes
    }
    pub fn clear_num_nodes(&mut self) {
        self.num_nodes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_nodes(&mut self, v: u32) {
        self.num_nodes = v;
    }

    // uint32 num_channels = 5;


    pub fn get_num_channels(&self) -> u32 {
        self.num_channels
    }
    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: u32) {
        self.num_channels = v;
    }

    // int64 total_network_capacity = 6;


    pub fn get_total_network_capacity(&self) -> i64 {
        self.total_network_capacity
    }
    pub fn clear_total_network_capacity(&mut self) {
        self.total_network_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_network_capacity(&mut self, v: i64) {
        self.total_network_capacity = v;
    }

    // double avg_channel_size = 7;


    pub fn get_avg_channel_size(&self) -> f64 {
        self.avg_channel_size
    }
    pub fn clear_avg_channel_size(&mut self) {
        self.avg_channel_size = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_channel_size(&mut self, v: f64) {
        self.avg_channel_size = v;
    }

    // int64 min_channel_size = 8;


    pub fn get_min_channel_size(&self) -> i64 {
        self.min_channel_size
    }
    pub fn clear_min_channel_size(&mut self) {
        self.min_channel_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_channel_size(&mut self, v: i64) {
        self.min_channel_size = v;
    }

    // int64 max_channel_size = 9;


    pub fn get_max_channel_size(&self) -> i64 {
        self.max_channel_size
    }
    pub fn clear_max_channel_size(&mut self) {
        self.max_channel_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_channel_size(&mut self, v: i64) {
        self.max_channel_size = v;
    }

    // int64 median_channel_size_sat = 10;


    pub fn get_median_channel_size_sat(&self) -> i64 {
        self.median_channel_size_sat
    }
    pub fn clear_median_channel_size_sat(&mut self) {
        self.median_channel_size_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_median_channel_size_sat(&mut self, v: i64) {
        self.median_channel_size_sat = v;
    }

    // uint64 num_zombie_chans = 11;


    pub fn get_num_zombie_chans(&self) -> u64 {
        self.num_zombie_chans
    }
    pub fn clear_num_zombie_chans(&mut self) {
        self.num_zombie_chans = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_zombie_chans(&mut self, v: u64) {
        self.num_zombie_chans = v;
    }
}

impl ::protobuf::Message for NetworkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.graph_diameter = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_out_degree = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_out_degree = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_nodes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_channels = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_network_capacity = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_channel_size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_channel_size = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_channel_size = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.median_channel_size_sat = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_zombie_chans = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.graph_diameter != 0 {
            my_size += ::protobuf::rt::value_size(1, self.graph_diameter, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_out_degree != 0. {
            my_size += 9;
        }
        if self.max_out_degree != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_out_degree, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_nodes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_nodes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_network_capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_network_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_channel_size != 0. {
            my_size += 9;
        }
        if self.min_channel_size != 0 {
            my_size += ::protobuf::rt::value_size(8, self.min_channel_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_channel_size != 0 {
            my_size += ::protobuf::rt::value_size(9, self.max_channel_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.median_channel_size_sat != 0 {
            my_size += ::protobuf::rt::value_size(10, self.median_channel_size_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_zombie_chans != 0 {
            my_size += ::protobuf::rt::value_size(11, self.num_zombie_chans, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.graph_diameter != 0 {
            os.write_uint32(1, self.graph_diameter)?;
        }
        if self.avg_out_degree != 0. {
            os.write_double(2, self.avg_out_degree)?;
        }
        if self.max_out_degree != 0 {
            os.write_uint32(3, self.max_out_degree)?;
        }
        if self.num_nodes != 0 {
            os.write_uint32(4, self.num_nodes)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(5, self.num_channels)?;
        }
        if self.total_network_capacity != 0 {
            os.write_int64(6, self.total_network_capacity)?;
        }
        if self.avg_channel_size != 0. {
            os.write_double(7, self.avg_channel_size)?;
        }
        if self.min_channel_size != 0 {
            os.write_int64(8, self.min_channel_size)?;
        }
        if self.max_channel_size != 0 {
            os.write_int64(9, self.max_channel_size)?;
        }
        if self.median_channel_size_sat != 0 {
            os.write_int64(10, self.median_channel_size_sat)?;
        }
        if self.num_zombie_chans != 0 {
            os.write_uint64(11, self.num_zombie_chans)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkInfo {
        NetworkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "graph_diameter",
                |m: &NetworkInfo| { &m.graph_diameter },
                |m: &mut NetworkInfo| { &mut m.graph_diameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "avg_out_degree",
                |m: &NetworkInfo| { &m.avg_out_degree },
                |m: &mut NetworkInfo| { &mut m.avg_out_degree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_out_degree",
                |m: &NetworkInfo| { &m.max_out_degree },
                |m: &mut NetworkInfo| { &mut m.max_out_degree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_nodes",
                |m: &NetworkInfo| { &m.num_nodes },
                |m: &mut NetworkInfo| { &mut m.num_nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_channels",
                |m: &NetworkInfo| { &m.num_channels },
                |m: &mut NetworkInfo| { &mut m.num_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_network_capacity",
                |m: &NetworkInfo| { &m.total_network_capacity },
                |m: &mut NetworkInfo| { &mut m.total_network_capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "avg_channel_size",
                |m: &NetworkInfo| { &m.avg_channel_size },
                |m: &mut NetworkInfo| { &mut m.avg_channel_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_channel_size",
                |m: &NetworkInfo| { &m.min_channel_size },
                |m: &mut NetworkInfo| { &mut m.min_channel_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_channel_size",
                |m: &NetworkInfo| { &m.max_channel_size },
                |m: &mut NetworkInfo| { &mut m.max_channel_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "median_channel_size_sat",
                |m: &NetworkInfo| { &m.median_channel_size_sat },
                |m: &mut NetworkInfo| { &mut m.median_channel_size_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_zombie_chans",
                |m: &NetworkInfo| { &m.num_zombie_chans },
                |m: &mut NetworkInfo| { &mut m.num_zombie_chans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkInfo>(
                "NetworkInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkInfo {
        static instance: ::protobuf::rt::LazyV2<NetworkInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkInfo::new)
    }
}

impl ::protobuf::Clear for NetworkInfo {
    fn clear(&mut self) {
        self.graph_diameter = 0;
        self.avg_out_degree = 0.;
        self.max_out_degree = 0;
        self.num_nodes = 0;
        self.num_channels = 0;
        self.total_network_capacity = 0;
        self.avg_channel_size = 0.;
        self.min_channel_size = 0;
        self.max_channel_size = 0;
        self.median_channel_size_sat = 0;
        self.num_zombie_chans = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StopRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopRequest {
    fn default() -> &'a StopRequest {
        <StopRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopRequest {
    pub fn new() -> StopRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopRequest {
        StopRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopRequest>(
                "StopRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopRequest {
        static instance: ::protobuf::rt::LazyV2<StopRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopRequest::new)
    }
}

impl ::protobuf::Clear for StopRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StopResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopResponse {
    fn default() -> &'a StopResponse {
        <StopResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopResponse {
    pub fn new() -> StopResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopResponse {
        StopResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopResponse>(
                "StopResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopResponse {
        static instance: ::protobuf::rt::LazyV2<StopResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopResponse::new)
    }
}

impl ::protobuf::Clear for StopResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GraphTopologySubscription {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphTopologySubscription {
    fn default() -> &'a GraphTopologySubscription {
        <GraphTopologySubscription as ::protobuf::Message>::default_instance()
    }
}

impl GraphTopologySubscription {
    pub fn new() -> GraphTopologySubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GraphTopologySubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphTopologySubscription {
        GraphTopologySubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GraphTopologySubscription>(
                "GraphTopologySubscription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GraphTopologySubscription {
        static instance: ::protobuf::rt::LazyV2<GraphTopologySubscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GraphTopologySubscription::new)
    }
}

impl ::protobuf::Clear for GraphTopologySubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphTopologySubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphTopologySubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GraphTopologyUpdate {
    // message fields
    pub node_updates: ::protobuf::RepeatedField<NodeUpdate>,
    pub channel_updates: ::protobuf::RepeatedField<ChannelEdgeUpdate>,
    pub closed_chans: ::protobuf::RepeatedField<ClosedChannelUpdate>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphTopologyUpdate {
    fn default() -> &'a GraphTopologyUpdate {
        <GraphTopologyUpdate as ::protobuf::Message>::default_instance()
    }
}

impl GraphTopologyUpdate {
    pub fn new() -> GraphTopologyUpdate {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.NodeUpdate node_updates = 1;


    pub fn get_node_updates(&self) -> &[NodeUpdate] {
        &self.node_updates
    }
    pub fn clear_node_updates(&mut self) {
        self.node_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_updates(&mut self, v: ::protobuf::RepeatedField<NodeUpdate>) {
        self.node_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_updates(&mut self) -> &mut ::protobuf::RepeatedField<NodeUpdate> {
        &mut self.node_updates
    }

    // Take field
    pub fn take_node_updates(&mut self) -> ::protobuf::RepeatedField<NodeUpdate> {
        ::std::mem::replace(&mut self.node_updates, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.ChannelEdgeUpdate channel_updates = 2;


    pub fn get_channel_updates(&self) -> &[ChannelEdgeUpdate] {
        &self.channel_updates
    }
    pub fn clear_channel_updates(&mut self) {
        self.channel_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_updates(&mut self, v: ::protobuf::RepeatedField<ChannelEdgeUpdate>) {
        self.channel_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_updates(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdgeUpdate> {
        &mut self.channel_updates
    }

    // Take field
    pub fn take_channel_updates(&mut self) -> ::protobuf::RepeatedField<ChannelEdgeUpdate> {
        ::std::mem::replace(&mut self.channel_updates, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.ClosedChannelUpdate closed_chans = 3;


    pub fn get_closed_chans(&self) -> &[ClosedChannelUpdate] {
        &self.closed_chans
    }
    pub fn clear_closed_chans(&mut self) {
        self.closed_chans.clear();
    }

    // Param is passed by value, moved
    pub fn set_closed_chans(&mut self, v: ::protobuf::RepeatedField<ClosedChannelUpdate>) {
        self.closed_chans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_closed_chans(&mut self) -> &mut ::protobuf::RepeatedField<ClosedChannelUpdate> {
        &mut self.closed_chans
    }

    // Take field
    pub fn take_closed_chans(&mut self) -> ::protobuf::RepeatedField<ClosedChannelUpdate> {
        ::std::mem::replace(&mut self.closed_chans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GraphTopologyUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.node_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.closed_chans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_updates)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_updates)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.closed_chans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.channel_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.closed_chans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.channel_updates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.closed_chans {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphTopologyUpdate {
        GraphTopologyUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeUpdate>>(
                "node_updates",
                |m: &GraphTopologyUpdate| { &m.node_updates },
                |m: &mut GraphTopologyUpdate| { &mut m.node_updates },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdgeUpdate>>(
                "channel_updates",
                |m: &GraphTopologyUpdate| { &m.channel_updates },
                |m: &mut GraphTopologyUpdate| { &mut m.channel_updates },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClosedChannelUpdate>>(
                "closed_chans",
                |m: &GraphTopologyUpdate| { &m.closed_chans },
                |m: &mut GraphTopologyUpdate| { &mut m.closed_chans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GraphTopologyUpdate>(
                "GraphTopologyUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GraphTopologyUpdate {
        static instance: ::protobuf::rt::LazyV2<GraphTopologyUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GraphTopologyUpdate::new)
    }
}

impl ::protobuf::Clear for GraphTopologyUpdate {
    fn clear(&mut self) {
        self.node_updates.clear();
        self.channel_updates.clear();
        self.closed_chans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphTopologyUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphTopologyUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeUpdate {
    // message fields
    pub addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub identity_key: ::std::string::String,
    pub global_features: ::std::vec::Vec<u8>,
    pub alias: ::std::string::String,
    pub color: ::std::string::String,
    pub node_addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub features: ::std::collections::HashMap<u32, Feature>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeUpdate {
    fn default() -> &'a NodeUpdate {
        <NodeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl NodeUpdate {
    pub fn new() -> NodeUpdate {
        ::std::default::Default::default()
    }

    // repeated string addresses = 1;


    pub fn get_addresses(&self) -> &[::std::string::String] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // string identity_key = 2;


    pub fn get_identity_key(&self) -> &str {
        &self.identity_key
    }
    pub fn clear_identity_key(&mut self) {
        self.identity_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_key(&mut self, v: ::std::string::String) {
        self.identity_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_key(&mut self) -> &mut ::std::string::String {
        &mut self.identity_key
    }

    // Take field
    pub fn take_identity_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_key, ::std::string::String::new())
    }

    // bytes global_features = 3;


    pub fn get_global_features(&self) -> &[u8] {
        &self.global_features
    }
    pub fn clear_global_features(&mut self) {
        self.global_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_global_features(&mut self, v: ::std::vec::Vec<u8>) {
        self.global_features = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_features(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.global_features
    }

    // Take field
    pub fn take_global_features(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.global_features, ::std::vec::Vec::new())
    }

    // string alias = 4;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // string color = 5;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }

    // repeated .lnrpc.NodeAddress node_addresses = 7;


    pub fn get_node_addresses(&self) -> &[NodeAddress] {
        &self.node_addresses
    }
    pub fn clear_node_addresses(&mut self) {
        self.node_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.node_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.node_addresses
    }

    // Take field
    pub fn take_node_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.node_addresses, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.NodeUpdate.FeaturesEntry features = 6;


    pub fn get_features(&self) -> &::std::collections::HashMap<u32, Feature> {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::collections::HashMap<u32, Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::std::collections::HashMap<u32, Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::collections::HashMap<u32, Feature> {
        ::std::mem::replace(&mut self.features, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for NodeUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.node_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.global_features)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_addresses)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(wire_type, is, &mut self.features)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.identity_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_key);
        }
        if !self.global_features.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.global_features);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.alias);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        for value in &self.node_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(6, &self.features);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        if !self.identity_key.is_empty() {
            os.write_string(2, &self.identity_key)?;
        }
        if !self.global_features.is_empty() {
            os.write_bytes(3, &self.global_features)?;
        }
        if !self.alias.is_empty() {
            os.write_string(4, &self.alias)?;
        }
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        for v in &self.node_addresses {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(6, &self.features, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeUpdate {
        NodeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addresses",
                |m: &NodeUpdate| { &m.addresses },
                |m: &mut NodeUpdate| { &mut m.addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_key",
                |m: &NodeUpdate| { &m.identity_key },
                |m: &mut NodeUpdate| { &mut m.identity_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "global_features",
                |m: &NodeUpdate| { &m.global_features },
                |m: &mut NodeUpdate| { &mut m.global_features },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alias",
                |m: &NodeUpdate| { &m.alias },
                |m: &mut NodeUpdate| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &NodeUpdate| { &m.color },
                |m: &mut NodeUpdate| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                "node_addresses",
                |m: &NodeUpdate| { &m.node_addresses },
                |m: &mut NodeUpdate| { &mut m.node_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &NodeUpdate| { &m.features },
                |m: &mut NodeUpdate| { &mut m.features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeUpdate>(
                "NodeUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeUpdate {
        static instance: ::protobuf::rt::LazyV2<NodeUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeUpdate::new)
    }
}

impl ::protobuf::Clear for NodeUpdate {
    fn clear(&mut self) {
        self.addresses.clear();
        self.identity_key.clear();
        self.global_features.clear();
        self.alias.clear();
        self.color.clear();
        self.node_addresses.clear();
        self.features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelEdgeUpdate {
    // message fields
    pub chan_id: u64,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub capacity: i64,
    pub routing_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub advertising_node: ::std::string::String,
    pub connecting_node: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEdgeUpdate {
    fn default() -> &'a ChannelEdgeUpdate {
        <ChannelEdgeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEdgeUpdate {
    pub fn new() -> ChannelEdgeUpdate {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // .lnrpc.ChannelPoint chan_point = 2;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // int64 capacity = 3;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // .lnrpc.RoutingPolicy routing_policy = 4;


    pub fn get_routing_policy(&self) -> &RoutingPolicy {
        self.routing_policy.as_ref().unwrap_or_else(|| <RoutingPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_routing_policy(&mut self) {
        self.routing_policy.clear();
    }

    pub fn has_routing_policy(&self) -> bool {
        self.routing_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_policy(&mut self, v: RoutingPolicy) {
        self.routing_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routing_policy(&mut self) -> &mut RoutingPolicy {
        if self.routing_policy.is_none() {
            self.routing_policy.set_default();
        }
        self.routing_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_routing_policy(&mut self) -> RoutingPolicy {
        self.routing_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    // string advertising_node = 5;


    pub fn get_advertising_node(&self) -> &str {
        &self.advertising_node
    }
    pub fn clear_advertising_node(&mut self) {
        self.advertising_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_advertising_node(&mut self, v: ::std::string::String) {
        self.advertising_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advertising_node(&mut self) -> &mut ::std::string::String {
        &mut self.advertising_node
    }

    // Take field
    pub fn take_advertising_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.advertising_node, ::std::string::String::new())
    }

    // string connecting_node = 6;


    pub fn get_connecting_node(&self) -> &str {
        &self.connecting_node
    }
    pub fn clear_connecting_node(&mut self) {
        self.connecting_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_connecting_node(&mut self, v: ::std::string::String) {
        self.connecting_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connecting_node(&mut self) -> &mut ::std::string::String {
        &mut self.connecting_node
    }

    // Take field
    pub fn take_connecting_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connecting_node, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChannelEdgeUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routing_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routing_policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.advertising_node)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connecting_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routing_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.advertising_node.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.advertising_node);
        }
        if !self.connecting_node.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.connecting_node);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if let Some(ref v) = self.routing_policy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.advertising_node.is_empty() {
            os.write_string(5, &self.advertising_node)?;
        }
        if !self.connecting_node.is_empty() {
            os.write_string(6, &self.connecting_node)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdgeUpdate {
        ChannelEdgeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &ChannelEdgeUpdate| { &m.chan_id },
                |m: &mut ChannelEdgeUpdate| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "chan_point",
                |m: &ChannelEdgeUpdate| { &m.chan_point },
                |m: &mut ChannelEdgeUpdate| { &mut m.chan_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "capacity",
                |m: &ChannelEdgeUpdate| { &m.capacity },
                |m: &mut ChannelEdgeUpdate| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                "routing_policy",
                |m: &ChannelEdgeUpdate| { &m.routing_policy },
                |m: &mut ChannelEdgeUpdate| { &mut m.routing_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "advertising_node",
                |m: &ChannelEdgeUpdate| { &m.advertising_node },
                |m: &mut ChannelEdgeUpdate| { &mut m.advertising_node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connecting_node",
                |m: &ChannelEdgeUpdate| { &m.connecting_node },
                |m: &mut ChannelEdgeUpdate| { &mut m.connecting_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelEdgeUpdate>(
                "ChannelEdgeUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelEdgeUpdate {
        static instance: ::protobuf::rt::LazyV2<ChannelEdgeUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelEdgeUpdate::new)
    }
}

impl ::protobuf::Clear for ChannelEdgeUpdate {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.chan_point.clear();
        self.capacity = 0;
        self.routing_policy.clear();
        self.advertising_node.clear();
        self.connecting_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdgeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdgeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClosedChannelUpdate {
    // message fields
    pub chan_id: u64,
    pub capacity: i64,
    pub closed_height: u32,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedChannelUpdate {
    fn default() -> &'a ClosedChannelUpdate {
        <ClosedChannelUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ClosedChannelUpdate {
    pub fn new() -> ClosedChannelUpdate {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // int64 capacity = 2;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // uint32 closed_height = 3;


    pub fn get_closed_height(&self) -> u32 {
        self.closed_height
    }
    pub fn clear_closed_height(&mut self) {
        self.closed_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_closed_height(&mut self, v: u32) {
        self.closed_height = v;
    }

    // .lnrpc.ChannelPoint chan_point = 4;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for ClosedChannelUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.closed_height = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.closed_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.closed_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.capacity != 0 {
            os.write_int64(2, self.capacity)?;
        }
        if self.closed_height != 0 {
            os.write_uint32(3, self.closed_height)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelUpdate {
        ClosedChannelUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &ClosedChannelUpdate| { &m.chan_id },
                |m: &mut ClosedChannelUpdate| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "capacity",
                |m: &ClosedChannelUpdate| { &m.capacity },
                |m: &mut ClosedChannelUpdate| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "closed_height",
                |m: &ClosedChannelUpdate| { &m.closed_height },
                |m: &mut ClosedChannelUpdate| { &mut m.closed_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "chan_point",
                |m: &ClosedChannelUpdate| { &m.chan_point },
                |m: &mut ClosedChannelUpdate| { &mut m.chan_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClosedChannelUpdate>(
                "ClosedChannelUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClosedChannelUpdate {
        static instance: ::protobuf::rt::LazyV2<ClosedChannelUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClosedChannelUpdate::new)
    }
}

impl ::protobuf::Clear for ClosedChannelUpdate {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.capacity = 0;
        self.closed_height = 0;
        self.chan_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HopHint {
    // message fields
    pub node_id: ::std::string::String,
    pub chan_id: u64,
    pub fee_base_msat: u32,
    pub fee_proportional_millionths: u32,
    pub cltv_expiry_delta: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HopHint {
    fn default() -> &'a HopHint {
        <HopHint as ::protobuf::Message>::default_instance()
    }
}

impl HopHint {
    pub fn new() -> HopHint {
        ::std::default::Default::default()
    }

    // string node_id = 1;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    // uint64 chan_id = 2;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // uint32 fee_base_msat = 3;


    pub fn get_fee_base_msat(&self) -> u32 {
        self.fee_base_msat
    }
    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: u32) {
        self.fee_base_msat = v;
    }

    // uint32 fee_proportional_millionths = 4;


    pub fn get_fee_proportional_millionths(&self) -> u32 {
        self.fee_proportional_millionths
    }
    pub fn clear_fee_proportional_millionths(&mut self) {
        self.fee_proportional_millionths = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_proportional_millionths(&mut self, v: u32) {
        self.fee_proportional_millionths = v;
    }

    // uint32 cltv_expiry_delta = 5;


    pub fn get_cltv_expiry_delta(&self) -> u32 {
        self.cltv_expiry_delta
    }
    pub fn clear_cltv_expiry_delta(&mut self) {
        self.cltv_expiry_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry_delta(&mut self, v: u32) {
        self.cltv_expiry_delta = v;
    }
}

impl ::protobuf::Message for HopHint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_proportional_millionths = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_expiry_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_proportional_millionths != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_proportional_millionths, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cltv_expiry_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.cltv_expiry_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if self.fee_base_msat != 0 {
            os.write_uint32(3, self.fee_base_msat)?;
        }
        if self.fee_proportional_millionths != 0 {
            os.write_uint32(4, self.fee_proportional_millionths)?;
        }
        if self.cltv_expiry_delta != 0 {
            os.write_uint32(5, self.cltv_expiry_delta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HopHint {
        HopHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_id",
                |m: &HopHint| { &m.node_id },
                |m: &mut HopHint| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &HopHint| { &m.chan_id },
                |m: &mut HopHint| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fee_base_msat",
                |m: &HopHint| { &m.fee_base_msat },
                |m: &mut HopHint| { &mut m.fee_base_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fee_proportional_millionths",
                |m: &HopHint| { &m.fee_proportional_millionths },
                |m: &mut HopHint| { &mut m.fee_proportional_millionths },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cltv_expiry_delta",
                |m: &HopHint| { &m.cltv_expiry_delta },
                |m: &mut HopHint| { &mut m.cltv_expiry_delta },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HopHint>(
                "HopHint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HopHint {
        static instance: ::protobuf::rt::LazyV2<HopHint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HopHint::new)
    }
}

impl ::protobuf::Clear for HopHint {
    fn clear(&mut self) {
        self.node_id.clear();
        self.chan_id = 0;
        self.fee_base_msat = 0;
        self.fee_proportional_millionths = 0;
        self.cltv_expiry_delta = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HopHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HopHint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteHint {
    // message fields
    pub hop_hints: ::protobuf::RepeatedField<HopHint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteHint {
    fn default() -> &'a RouteHint {
        <RouteHint as ::protobuf::Message>::default_instance()
    }
}

impl RouteHint {
    pub fn new() -> RouteHint {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.HopHint hop_hints = 1;


    pub fn get_hop_hints(&self) -> &[HopHint] {
        &self.hop_hints
    }
    pub fn clear_hop_hints(&mut self) {
        self.hop_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hop_hints(&mut self, v: ::protobuf::RepeatedField<HopHint>) {
        self.hop_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hop_hints(&mut self) -> &mut ::protobuf::RepeatedField<HopHint> {
        &mut self.hop_hints
    }

    // Take field
    pub fn take_hop_hints(&mut self) -> ::protobuf::RepeatedField<HopHint> {
        ::std::mem::replace(&mut self.hop_hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RouteHint {
    fn is_initialized(&self) -> bool {
        for v in &self.hop_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hop_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hop_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hop_hints {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteHint {
        RouteHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HopHint>>(
                "hop_hints",
                |m: &RouteHint| { &m.hop_hints },
                |m: &mut RouteHint| { &mut m.hop_hints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteHint>(
                "RouteHint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteHint {
        static instance: ::protobuf::rt::LazyV2<RouteHint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteHint::new)
    }
}

impl ::protobuf::Clear for RouteHint {
    fn clear(&mut self) {
        self.hop_hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteHint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Invoice {
    // message fields
    pub memo: ::std::string::String,
    pub r_preimage: ::std::vec::Vec<u8>,
    pub r_hash: ::std::vec::Vec<u8>,
    pub value: i64,
    pub value_msat: i64,
    pub settled: bool,
    pub creation_date: i64,
    pub settle_date: i64,
    pub payment_request: ::std::string::String,
    pub description_hash: ::std::vec::Vec<u8>,
    pub expiry: i64,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: u64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    pub private: bool,
    pub add_index: u64,
    pub settle_index: u64,
    pub amt_paid: i64,
    pub amt_paid_sat: i64,
    pub amt_paid_msat: i64,
    pub state: Invoice_InvoiceState,
    pub htlcs: ::protobuf::RepeatedField<InvoiceHTLC>,
    pub features: ::std::collections::HashMap<u32, Feature>,
    pub is_keysend: bool,
    pub payment_addr: ::std::vec::Vec<u8>,
    pub is_amp: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Invoice {
    fn default() -> &'a Invoice {
        <Invoice as ::protobuf::Message>::default_instance()
    }
}

impl Invoice {
    pub fn new() -> Invoice {
        ::std::default::Default::default()
    }

    // string memo = 1;


    pub fn get_memo(&self) -> &str {
        &self.memo
    }
    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::string::String) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::string::String {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.memo, ::std::string::String::new())
    }

    // bytes r_preimage = 3;


    pub fn get_r_preimage(&self) -> &[u8] {
        &self.r_preimage
    }
    pub fn clear_r_preimage(&mut self) {
        self.r_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_preimage
    }

    // Take field
    pub fn take_r_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_preimage, ::std::vec::Vec::new())
    }

    // bytes r_hash = 4;


    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    // int64 value = 5;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // int64 value_msat = 23;


    pub fn get_value_msat(&self) -> i64 {
        self.value_msat
    }
    pub fn clear_value_msat(&mut self) {
        self.value_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_msat(&mut self, v: i64) {
        self.value_msat = v;
    }

    // bool settled = 6;


    pub fn get_settled(&self) -> bool {
        self.settled
    }
    pub fn clear_settled(&mut self) {
        self.settled = false;
    }

    // Param is passed by value, moved
    pub fn set_settled(&mut self, v: bool) {
        self.settled = v;
    }

    // int64 creation_date = 7;


    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }
    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    // int64 settle_date = 8;


    pub fn get_settle_date(&self) -> i64 {
        self.settle_date
    }
    pub fn clear_settle_date(&mut self) {
        self.settle_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_date(&mut self, v: i64) {
        self.settle_date = v;
    }

    // string payment_request = 9;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // bytes description_hash = 10;


    pub fn get_description_hash(&self) -> &[u8] {
        &self.description_hash
    }
    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description_hash, ::std::vec::Vec::new())
    }

    // int64 expiry = 11;


    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    // string fallback_addr = 12;


    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }
    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    // uint64 cltv_expiry = 13;


    pub fn get_cltv_expiry(&self) -> u64 {
        self.cltv_expiry
    }
    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: u64) {
        self.cltv_expiry = v;
    }

    // repeated .lnrpc.RouteHint route_hints = 14;


    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    // bool private = 15;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    // uint64 add_index = 16;


    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    // uint64 settle_index = 17;


    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }
    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }

    // int64 amt_paid = 18;


    pub fn get_amt_paid(&self) -> i64 {
        self.amt_paid
    }
    pub fn clear_amt_paid(&mut self) {
        self.amt_paid = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid(&mut self, v: i64) {
        self.amt_paid = v;
    }

    // int64 amt_paid_sat = 19;


    pub fn get_amt_paid_sat(&self) -> i64 {
        self.amt_paid_sat
    }
    pub fn clear_amt_paid_sat(&mut self) {
        self.amt_paid_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_sat(&mut self, v: i64) {
        self.amt_paid_sat = v;
    }

    // int64 amt_paid_msat = 20;


    pub fn get_amt_paid_msat(&self) -> i64 {
        self.amt_paid_msat
    }
    pub fn clear_amt_paid_msat(&mut self) {
        self.amt_paid_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_msat(&mut self, v: i64) {
        self.amt_paid_msat = v;
    }

    // .lnrpc.Invoice.InvoiceState state = 21;


    pub fn get_state(&self) -> Invoice_InvoiceState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Invoice_InvoiceState::OPEN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Invoice_InvoiceState) {
        self.state = v;
    }

    // repeated .lnrpc.InvoiceHTLC htlcs = 22;


    pub fn get_htlcs(&self) -> &[InvoiceHTLC] {
        &self.htlcs
    }
    pub fn clear_htlcs(&mut self) {
        self.htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlcs(&mut self, v: ::protobuf::RepeatedField<InvoiceHTLC>) {
        self.htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<InvoiceHTLC> {
        &mut self.htlcs
    }

    // Take field
    pub fn take_htlcs(&mut self) -> ::protobuf::RepeatedField<InvoiceHTLC> {
        ::std::mem::replace(&mut self.htlcs, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.Invoice.FeaturesEntry features = 24;


    pub fn get_features(&self) -> &::std::collections::HashMap<u32, Feature> {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::collections::HashMap<u32, Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::std::collections::HashMap<u32, Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::collections::HashMap<u32, Feature> {
        ::std::mem::replace(&mut self.features, ::std::collections::HashMap::new())
    }

    // bool is_keysend = 25;


    pub fn get_is_keysend(&self) -> bool {
        self.is_keysend
    }
    pub fn clear_is_keysend(&mut self) {
        self.is_keysend = false;
    }

    // Param is passed by value, moved
    pub fn set_is_keysend(&mut self, v: bool) {
        self.is_keysend = v;
    }

    // bytes payment_addr = 26;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }

    // bool is_amp = 27;


    pub fn get_is_amp(&self) -> bool {
        self.is_amp
    }
    pub fn clear_is_amp(&mut self) {
        self.is_amp = false;
    }

    // Param is passed by value, moved
    pub fn set_is_amp(&mut self, v: bool) {
        self.is_amp = v;
    }
}

impl ::protobuf::Message for Invoice {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.memo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_preimage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.settled = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settle_date = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description_hash)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cltv_expiry = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_sat = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_msat = tmp;
                },
                21 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 21, &mut self.unknown_fields)?
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.htlcs)?;
                },
                24 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(wire_type, is, &mut self.features)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_keysend = tmp;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_amp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.memo);
        }
        if !self.r_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.r_preimage);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.r_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value_msat != 0 {
            my_size += ::protobuf::rt::value_size(23, self.value_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settled != false {
            my_size += 2;
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(7, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_date != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settle_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payment_request);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.description_hash);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(11, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(13, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.private != false {
            my_size += 2;
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(17, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid != 0 {
            my_size += ::protobuf::rt::value_size(18, self.amt_paid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_sat != 0 {
            my_size += ::protobuf::rt::value_size(19, self.amt_paid_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_msat != 0 {
            my_size += ::protobuf::rt::value_size(20, self.amt_paid_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != Invoice_InvoiceState::OPEN {
            my_size += ::protobuf::rt::enum_size(21, self.state);
        }
        for value in &self.htlcs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(24, &self.features);
        if self.is_keysend != false {
            my_size += 3;
        }
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(26, &self.payment_addr);
        }
        if self.is_amp != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.memo.is_empty() {
            os.write_string(1, &self.memo)?;
        }
        if !self.r_preimage.is_empty() {
            os.write_bytes(3, &self.r_preimage)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(4, &self.r_hash)?;
        }
        if self.value != 0 {
            os.write_int64(5, self.value)?;
        }
        if self.value_msat != 0 {
            os.write_int64(23, self.value_msat)?;
        }
        if self.settled != false {
            os.write_bool(6, self.settled)?;
        }
        if self.creation_date != 0 {
            os.write_int64(7, self.creation_date)?;
        }
        if self.settle_date != 0 {
            os.write_int64(8, self.settle_date)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(9, &self.payment_request)?;
        }
        if !self.description_hash.is_empty() {
            os.write_bytes(10, &self.description_hash)?;
        }
        if self.expiry != 0 {
            os.write_int64(11, self.expiry)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(12, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_uint64(13, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.private != false {
            os.write_bool(15, self.private)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(17, self.settle_index)?;
        }
        if self.amt_paid != 0 {
            os.write_int64(18, self.amt_paid)?;
        }
        if self.amt_paid_sat != 0 {
            os.write_int64(19, self.amt_paid_sat)?;
        }
        if self.amt_paid_msat != 0 {
            os.write_int64(20, self.amt_paid_msat)?;
        }
        if self.state != Invoice_InvoiceState::OPEN {
            os.write_enum(21, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        for v in &self.htlcs {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(24, &self.features, os)?;
        if self.is_keysend != false {
            os.write_bool(25, self.is_keysend)?;
        }
        if !self.payment_addr.is_empty() {
            os.write_bytes(26, &self.payment_addr)?;
        }
        if self.is_amp != false {
            os.write_bool(27, self.is_amp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Invoice {
        Invoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "memo",
                |m: &Invoice| { &m.memo },
                |m: &mut Invoice| { &mut m.memo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "r_preimage",
                |m: &Invoice| { &m.r_preimage },
                |m: &mut Invoice| { &mut m.r_preimage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "r_hash",
                |m: &Invoice| { &m.r_hash },
                |m: &mut Invoice| { &mut m.r_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &Invoice| { &m.value },
                |m: &mut Invoice| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value_msat",
                |m: &Invoice| { &m.value_msat },
                |m: &mut Invoice| { &mut m.value_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "settled",
                |m: &Invoice| { &m.settled },
                |m: &mut Invoice| { &mut m.settled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_date",
                |m: &Invoice| { &m.creation_date },
                |m: &mut Invoice| { &mut m.creation_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "settle_date",
                |m: &Invoice| { &m.settle_date },
                |m: &mut Invoice| { &mut m.settle_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_request",
                |m: &Invoice| { &m.payment_request },
                |m: &mut Invoice| { &mut m.payment_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description_hash",
                |m: &Invoice| { &m.description_hash },
                |m: &mut Invoice| { &mut m.description_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiry",
                |m: &Invoice| { &m.expiry },
                |m: &mut Invoice| { &mut m.expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fallback_addr",
                |m: &Invoice| { &m.fallback_addr },
                |m: &mut Invoice| { &mut m.fallback_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cltv_expiry",
                |m: &Invoice| { &m.cltv_expiry },
                |m: &mut Invoice| { &mut m.cltv_expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                "route_hints",
                |m: &Invoice| { &m.route_hints },
                |m: &mut Invoice| { &mut m.route_hints },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "private",
                |m: &Invoice| { &m.private },
                |m: &mut Invoice| { &mut m.private },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "add_index",
                |m: &Invoice| { &m.add_index },
                |m: &mut Invoice| { &mut m.add_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "settle_index",
                |m: &Invoice| { &m.settle_index },
                |m: &mut Invoice| { &mut m.settle_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_paid",
                |m: &Invoice| { &m.amt_paid },
                |m: &mut Invoice| { &mut m.amt_paid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_paid_sat",
                |m: &Invoice| { &m.amt_paid_sat },
                |m: &mut Invoice| { &mut m.amt_paid_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amt_paid_msat",
                |m: &Invoice| { &m.amt_paid_msat },
                |m: &mut Invoice| { &mut m.amt_paid_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Invoice_InvoiceState>>(
                "state",
                |m: &Invoice| { &m.state },
                |m: &mut Invoice| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvoiceHTLC>>(
                "htlcs",
                |m: &Invoice| { &m.htlcs },
                |m: &mut Invoice| { &mut m.htlcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &Invoice| { &m.features },
                |m: &mut Invoice| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_keysend",
                |m: &Invoice| { &m.is_keysend },
                |m: &mut Invoice| { &mut m.is_keysend },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &Invoice| { &m.payment_addr },
                |m: &mut Invoice| { &mut m.payment_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_amp",
                |m: &Invoice| { &m.is_amp },
                |m: &mut Invoice| { &mut m.is_amp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Invoice>(
                "Invoice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Invoice {
        static instance: ::protobuf::rt::LazyV2<Invoice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Invoice::new)
    }
}

impl ::protobuf::Clear for Invoice {
    fn clear(&mut self) {
        self.memo.clear();
        self.r_preimage.clear();
        self.r_hash.clear();
        self.value = 0;
        self.value_msat = 0;
        self.settled = false;
        self.creation_date = 0;
        self.settle_date = 0;
        self.payment_request.clear();
        self.description_hash.clear();
        self.expiry = 0;
        self.fallback_addr.clear();
        self.cltv_expiry = 0;
        self.route_hints.clear();
        self.private = false;
        self.add_index = 0;
        self.settle_index = 0;
        self.amt_paid = 0;
        self.amt_paid_sat = 0;
        self.amt_paid_msat = 0;
        self.state = Invoice_InvoiceState::OPEN;
        self.htlcs.clear();
        self.features.clear();
        self.is_keysend = false;
        self.payment_addr.clear();
        self.is_amp = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Invoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Invoice_InvoiceState {
    OPEN = 0,
    SETTLED = 1,
    CANCELED = 2,
    ACCEPTED = 3,
}

impl ::protobuf::ProtobufEnum for Invoice_InvoiceState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Invoice_InvoiceState> {
        match value {
            0 => ::std::option::Option::Some(Invoice_InvoiceState::OPEN),
            1 => ::std::option::Option::Some(Invoice_InvoiceState::SETTLED),
            2 => ::std::option::Option::Some(Invoice_InvoiceState::CANCELED),
            3 => ::std::option::Option::Some(Invoice_InvoiceState::ACCEPTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Invoice_InvoiceState] = &[
            Invoice_InvoiceState::OPEN,
            Invoice_InvoiceState::SETTLED,
            Invoice_InvoiceState::CANCELED,
            Invoice_InvoiceState::ACCEPTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Invoice_InvoiceState>("Invoice.InvoiceState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Invoice_InvoiceState {
}

impl ::std::default::Default for Invoice_InvoiceState {
    fn default() -> Self {
        Invoice_InvoiceState::OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice_InvoiceState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InvoiceHTLC {
    // message fields
    pub chan_id: u64,
    pub htlc_index: u64,
    pub amt_msat: u64,
    pub accept_height: i32,
    pub accept_time: i64,
    pub resolve_time: i64,
    pub expiry_height: i32,
    pub state: InvoiceHTLCState,
    pub custom_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    pub mpp_total_amt_msat: u64,
    pub amp: ::protobuf::SingularPtrField<AMP>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvoiceHTLC {
    fn default() -> &'a InvoiceHTLC {
        <InvoiceHTLC as ::protobuf::Message>::default_instance()
    }
}

impl InvoiceHTLC {
    pub fn new() -> InvoiceHTLC {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // uint64 htlc_index = 2;


    pub fn get_htlc_index(&self) -> u64 {
        self.htlc_index
    }
    pub fn clear_htlc_index(&mut self) {
        self.htlc_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_index(&mut self, v: u64) {
        self.htlc_index = v;
    }

    // uint64 amt_msat = 3;


    pub fn get_amt_msat(&self) -> u64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: u64) {
        self.amt_msat = v;
    }

    // int32 accept_height = 4;


    pub fn get_accept_height(&self) -> i32 {
        self.accept_height
    }
    pub fn clear_accept_height(&mut self) {
        self.accept_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_accept_height(&mut self, v: i32) {
        self.accept_height = v;
    }

    // int64 accept_time = 5;


    pub fn get_accept_time(&self) -> i64 {
        self.accept_time
    }
    pub fn clear_accept_time(&mut self) {
        self.accept_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_accept_time(&mut self, v: i64) {
        self.accept_time = v;
    }

    // int64 resolve_time = 6;


    pub fn get_resolve_time(&self) -> i64 {
        self.resolve_time
    }
    pub fn clear_resolve_time(&mut self) {
        self.resolve_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_resolve_time(&mut self, v: i64) {
        self.resolve_time = v;
    }

    // int32 expiry_height = 7;


    pub fn get_expiry_height(&self) -> i32 {
        self.expiry_height
    }
    pub fn clear_expiry_height(&mut self) {
        self.expiry_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry_height(&mut self, v: i32) {
        self.expiry_height = v;
    }

    // .lnrpc.InvoiceHTLCState state = 8;


    pub fn get_state(&self) -> InvoiceHTLCState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = InvoiceHTLCState::ACCEPTED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: InvoiceHTLCState) {
        self.state = v;
    }

    // repeated .lnrpc.InvoiceHTLC.CustomRecordsEntry custom_records = 9;


    pub fn get_custom_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.custom_records
    }
    pub fn clear_custom_records(&mut self) {
        self.custom_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.custom_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.custom_records
    }

    // Take field
    pub fn take_custom_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.custom_records, ::std::collections::HashMap::new())
    }

    // uint64 mpp_total_amt_msat = 10;


    pub fn get_mpp_total_amt_msat(&self) -> u64 {
        self.mpp_total_amt_msat
    }
    pub fn clear_mpp_total_amt_msat(&mut self) {
        self.mpp_total_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_mpp_total_amt_msat(&mut self, v: u64) {
        self.mpp_total_amt_msat = v;
    }

    // .lnrpc.AMP amp = 11;


    pub fn get_amp(&self) -> &AMP {
        self.amp.as_ref().unwrap_or_else(|| <AMP as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amp(&mut self) {
        self.amp.clear();
    }

    pub fn has_amp(&self) -> bool {
        self.amp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amp(&mut self, v: AMP) {
        self.amp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amp(&mut self) -> &mut AMP {
        if self.amp.is_none() {
            self.amp.set_default();
        }
        self.amp.as_mut().unwrap()
    }

    // Take field
    pub fn take_amp(&mut self) -> AMP {
        self.amp.take().unwrap_or_else(|| AMP::new())
    }
}

impl ::protobuf::Message for InvoiceHTLC {
    fn is_initialized(&self) -> bool {
        for v in &self.amp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.accept_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accept_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.resolve_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiry_height = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.custom_records)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mpp_total_amt_msat = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.htlc_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accept_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.accept_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accept_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.accept_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resolve_time != 0 {
            my_size += ::protobuf::rt::value_size(6, self.resolve_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry_height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.expiry_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != InvoiceHTLCState::ACCEPTED {
            my_size += ::protobuf::rt::enum_size(8, self.state);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(9, &self.custom_records);
        if self.mpp_total_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(10, self.mpp_total_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.amp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.htlc_index != 0 {
            os.write_uint64(2, self.htlc_index)?;
        }
        if self.amt_msat != 0 {
            os.write_uint64(3, self.amt_msat)?;
        }
        if self.accept_height != 0 {
            os.write_int32(4, self.accept_height)?;
        }
        if self.accept_time != 0 {
            os.write_int64(5, self.accept_time)?;
        }
        if self.resolve_time != 0 {
            os.write_int64(6, self.resolve_time)?;
        }
        if self.expiry_height != 0 {
            os.write_int32(7, self.expiry_height)?;
        }
        if self.state != InvoiceHTLCState::ACCEPTED {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(9, &self.custom_records, os)?;
        if self.mpp_total_amt_msat != 0 {
            os.write_uint64(10, self.mpp_total_amt_msat)?;
        }
        if let Some(ref v) = self.amp.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvoiceHTLC {
        InvoiceHTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &InvoiceHTLC| { &m.chan_id },
                |m: &mut InvoiceHTLC| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "htlc_index",
                |m: &InvoiceHTLC| { &m.htlc_index },
                |m: &mut InvoiceHTLC| { &mut m.htlc_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amt_msat",
                |m: &InvoiceHTLC| { &m.amt_msat },
                |m: &mut InvoiceHTLC| { &mut m.amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "accept_height",
                |m: &InvoiceHTLC| { &m.accept_height },
                |m: &mut InvoiceHTLC| { &mut m.accept_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "accept_time",
                |m: &InvoiceHTLC| { &m.accept_time },
                |m: &mut InvoiceHTLC| { &mut m.accept_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "resolve_time",
                |m: &InvoiceHTLC| { &m.resolve_time },
                |m: &mut InvoiceHTLC| { &mut m.resolve_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expiry_height",
                |m: &InvoiceHTLC| { &m.expiry_height },
                |m: &mut InvoiceHTLC| { &mut m.expiry_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InvoiceHTLCState>>(
                "state",
                |m: &InvoiceHTLC| { &m.state },
                |m: &mut InvoiceHTLC| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                "custom_records",
                |m: &InvoiceHTLC| { &m.custom_records },
                |m: &mut InvoiceHTLC| { &mut m.custom_records },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "mpp_total_amt_msat",
                |m: &InvoiceHTLC| { &m.mpp_total_amt_msat },
                |m: &mut InvoiceHTLC| { &mut m.mpp_total_amt_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AMP>>(
                "amp",
                |m: &InvoiceHTLC| { &m.amp },
                |m: &mut InvoiceHTLC| { &mut m.amp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvoiceHTLC>(
                "InvoiceHTLC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InvoiceHTLC {
        static instance: ::protobuf::rt::LazyV2<InvoiceHTLC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InvoiceHTLC::new)
    }
}

impl ::protobuf::Clear for InvoiceHTLC {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.htlc_index = 0;
        self.amt_msat = 0;
        self.accept_height = 0;
        self.accept_time = 0;
        self.resolve_time = 0;
        self.expiry_height = 0;
        self.state = InvoiceHTLCState::ACCEPTED;
        self.custom_records.clear();
        self.mpp_total_amt_msat = 0;
        self.amp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvoiceHTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceHTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AMP {
    // message fields
    pub root_share: ::std::vec::Vec<u8>,
    pub set_id: ::std::vec::Vec<u8>,
    pub child_index: u32,
    pub hash: ::std::vec::Vec<u8>,
    pub preimage: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AMP {
    fn default() -> &'a AMP {
        <AMP as ::protobuf::Message>::default_instance()
    }
}

impl AMP {
    pub fn new() -> AMP {
        ::std::default::Default::default()
    }

    // bytes root_share = 1;


    pub fn get_root_share(&self) -> &[u8] {
        &self.root_share
    }
    pub fn clear_root_share(&mut self) {
        self.root_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_root_share(&mut self, v: ::std::vec::Vec<u8>) {
        self.root_share = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_share(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.root_share
    }

    // Take field
    pub fn take_root_share(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.root_share, ::std::vec::Vec::new())
    }

    // bytes set_id = 2;


    pub fn get_set_id(&self) -> &[u8] {
        &self.set_id
    }
    pub fn clear_set_id(&mut self) {
        self.set_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.set_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.set_id
    }

    // Take field
    pub fn take_set_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.set_id, ::std::vec::Vec::new())
    }

    // uint32 child_index = 3;


    pub fn get_child_index(&self) -> u32 {
        self.child_index
    }
    pub fn clear_child_index(&mut self) {
        self.child_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_child_index(&mut self, v: u32) {
        self.child_index = v;
    }

    // bytes hash = 4;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes preimage = 5;


    pub fn get_preimage(&self) -> &[u8] {
        &self.preimage
    }
    pub fn clear_preimage(&mut self) {
        self.preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.preimage
    }

    // Take field
    pub fn take_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.preimage, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AMP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.root_share)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.set_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.child_index = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.preimage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.root_share.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.root_share);
        }
        if !self.set_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.set_id);
        }
        if self.child_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.child_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.hash);
        }
        if !self.preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.preimage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.root_share.is_empty() {
            os.write_bytes(1, &self.root_share)?;
        }
        if !self.set_id.is_empty() {
            os.write_bytes(2, &self.set_id)?;
        }
        if self.child_index != 0 {
            os.write_uint32(3, self.child_index)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(4, &self.hash)?;
        }
        if !self.preimage.is_empty() {
            os.write_bytes(5, &self.preimage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AMP {
        AMP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "root_share",
                |m: &AMP| { &m.root_share },
                |m: &mut AMP| { &mut m.root_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "set_id",
                |m: &AMP| { &m.set_id },
                |m: &mut AMP| { &mut m.set_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "child_index",
                |m: &AMP| { &m.child_index },
                |m: &mut AMP| { &mut m.child_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &AMP| { &m.hash },
                |m: &mut AMP| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "preimage",
                |m: &AMP| { &m.preimage },
                |m: &mut AMP| { &mut m.preimage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AMP>(
                "AMP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AMP {
        static instance: ::protobuf::rt::LazyV2<AMP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AMP::new)
    }
}

impl ::protobuf::Clear for AMP {
    fn clear(&mut self) {
        self.root_share.clear();
        self.set_id.clear();
        self.child_index = 0;
        self.hash.clear();
        self.preimage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AMP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AMP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddInvoiceResponse {
    // message fields
    pub r_hash: ::std::vec::Vec<u8>,
    pub payment_request: ::std::string::String,
    pub add_index: u64,
    pub payment_addr: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddInvoiceResponse {
    fn default() -> &'a AddInvoiceResponse {
        <AddInvoiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddInvoiceResponse {
    pub fn new() -> AddInvoiceResponse {
        ::std::default::Default::default()
    }

    // bytes r_hash = 1;


    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    // string payment_request = 2;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // uint64 add_index = 16;


    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    // bytes payment_addr = 17;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AddInvoiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.r_hash);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_request);
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(17, &self.payment_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash.is_empty() {
            os.write_bytes(1, &self.r_hash)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(2, &self.payment_request)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        if !self.payment_addr.is_empty() {
            os.write_bytes(17, &self.payment_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddInvoiceResponse {
        AddInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "r_hash",
                |m: &AddInvoiceResponse| { &m.r_hash },
                |m: &mut AddInvoiceResponse| { &mut m.r_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_request",
                |m: &AddInvoiceResponse| { &m.payment_request },
                |m: &mut AddInvoiceResponse| { &mut m.payment_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "add_index",
                |m: &AddInvoiceResponse| { &m.add_index },
                |m: &mut AddInvoiceResponse| { &mut m.add_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &AddInvoiceResponse| { &m.payment_addr },
                |m: &mut AddInvoiceResponse| { &mut m.payment_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddInvoiceResponse>(
                "AddInvoiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddInvoiceResponse {
        static instance: ::protobuf::rt::LazyV2<AddInvoiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddInvoiceResponse::new)
    }
}

impl ::protobuf::Clear for AddInvoiceResponse {
    fn clear(&mut self) {
        self.r_hash.clear();
        self.payment_request.clear();
        self.add_index = 0;
        self.payment_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaymentHash {
    // message fields
    pub r_hash_str: ::std::string::String,
    pub r_hash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentHash {
    fn default() -> &'a PaymentHash {
        <PaymentHash as ::protobuf::Message>::default_instance()
    }
}

impl PaymentHash {
    pub fn new() -> PaymentHash {
        ::std::default::Default::default()
    }

    // string r_hash_str = 1;


    pub fn get_r_hash_str(&self) -> &str {
        &self.r_hash_str
    }
    pub fn clear_r_hash_str(&mut self) {
        self.r_hash_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash_str(&mut self, v: ::std::string::String) {
        self.r_hash_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash_str(&mut self) -> &mut ::std::string::String {
        &mut self.r_hash_str
    }

    // Take field
    pub fn take_r_hash_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.r_hash_str, ::std::string::String::new())
    }

    // bytes r_hash = 2;


    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PaymentHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.r_hash_str)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash_str.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.r_hash_str);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.r_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash_str.is_empty() {
            os.write_string(1, &self.r_hash_str)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(2, &self.r_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentHash {
        PaymentHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "r_hash_str",
                |m: &PaymentHash| { &m.r_hash_str },
                |m: &mut PaymentHash| { &mut m.r_hash_str },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "r_hash",
                |m: &PaymentHash| { &m.r_hash },
                |m: &mut PaymentHash| { &mut m.r_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaymentHash>(
                "PaymentHash",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaymentHash {
        static instance: ::protobuf::rt::LazyV2<PaymentHash> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaymentHash::new)
    }
}

impl ::protobuf::Clear for PaymentHash {
    fn clear(&mut self) {
        self.r_hash_str.clear();
        self.r_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentHash {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListInvoiceRequest {
    // message fields
    pub pending_only: bool,
    pub index_offset: u64,
    pub num_max_invoices: u64,
    pub reversed: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInvoiceRequest {
    fn default() -> &'a ListInvoiceRequest {
        <ListInvoiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInvoiceRequest {
    pub fn new() -> ListInvoiceRequest {
        ::std::default::Default::default()
    }

    // bool pending_only = 1;


    pub fn get_pending_only(&self) -> bool {
        self.pending_only
    }
    pub fn clear_pending_only(&mut self) {
        self.pending_only = false;
    }

    // Param is passed by value, moved
    pub fn set_pending_only(&mut self, v: bool) {
        self.pending_only = v;
    }

    // uint64 index_offset = 4;


    pub fn get_index_offset(&self) -> u64 {
        self.index_offset
    }
    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u64) {
        self.index_offset = v;
    }

    // uint64 num_max_invoices = 5;


    pub fn get_num_max_invoices(&self) -> u64 {
        self.num_max_invoices
    }
    pub fn clear_num_max_invoices(&mut self) {
        self.num_max_invoices = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_invoices(&mut self, v: u64) {
        self.num_max_invoices = v;
    }

    // bool reversed = 6;


    pub fn get_reversed(&self) -> bool {
        self.reversed
    }
    pub fn clear_reversed(&mut self) {
        self.reversed = false;
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: bool) {
        self.reversed = v;
    }
}

impl ::protobuf::Message for ListInvoiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index_offset = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_max_invoices = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reversed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pending_only != false {
            my_size += 2;
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_invoices != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_max_invoices, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reversed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.pending_only != false {
            os.write_bool(1, self.pending_only)?;
        }
        if self.index_offset != 0 {
            os.write_uint64(4, self.index_offset)?;
        }
        if self.num_max_invoices != 0 {
            os.write_uint64(5, self.num_max_invoices)?;
        }
        if self.reversed != false {
            os.write_bool(6, self.reversed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceRequest {
        ListInvoiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pending_only",
                |m: &ListInvoiceRequest| { &m.pending_only },
                |m: &mut ListInvoiceRequest| { &mut m.pending_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "index_offset",
                |m: &ListInvoiceRequest| { &m.index_offset },
                |m: &mut ListInvoiceRequest| { &mut m.index_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_max_invoices",
                |m: &ListInvoiceRequest| { &m.num_max_invoices },
                |m: &mut ListInvoiceRequest| { &mut m.num_max_invoices },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reversed",
                |m: &ListInvoiceRequest| { &m.reversed },
                |m: &mut ListInvoiceRequest| { &mut m.reversed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInvoiceRequest>(
                "ListInvoiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListInvoiceRequest {
        static instance: ::protobuf::rt::LazyV2<ListInvoiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListInvoiceRequest::new)
    }
}

impl ::protobuf::Clear for ListInvoiceRequest {
    fn clear(&mut self) {
        self.pending_only = false;
        self.index_offset = 0;
        self.num_max_invoices = 0;
        self.reversed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListInvoiceResponse {
    // message fields
    pub invoices: ::protobuf::RepeatedField<Invoice>,
    pub last_index_offset: u64,
    pub first_index_offset: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInvoiceResponse {
    fn default() -> &'a ListInvoiceResponse {
        <ListInvoiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListInvoiceResponse {
    pub fn new() -> ListInvoiceResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Invoice invoices = 1;


    pub fn get_invoices(&self) -> &[Invoice] {
        &self.invoices
    }
    pub fn clear_invoices(&mut self) {
        self.invoices.clear();
    }

    // Param is passed by value, moved
    pub fn set_invoices(&mut self, v: ::protobuf::RepeatedField<Invoice>) {
        self.invoices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invoices(&mut self) -> &mut ::protobuf::RepeatedField<Invoice> {
        &mut self.invoices
    }

    // Take field
    pub fn take_invoices(&mut self) -> ::protobuf::RepeatedField<Invoice> {
        ::std::mem::replace(&mut self.invoices, ::protobuf::RepeatedField::new())
    }

    // uint64 last_index_offset = 2;


    pub fn get_last_index_offset(&self) -> u64 {
        self.last_index_offset
    }
    pub fn clear_last_index_offset(&mut self) {
        self.last_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_index_offset(&mut self, v: u64) {
        self.last_index_offset = v;
    }

    // uint64 first_index_offset = 3;


    pub fn get_first_index_offset(&self) -> u64 {
        self.first_index_offset
    }
    pub fn clear_first_index_offset(&mut self) {
        self.first_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_index_offset(&mut self, v: u64) {
        self.first_index_offset = v;
    }
}

impl ::protobuf::Message for ListInvoiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.invoices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invoices)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_index_offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.first_index_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invoices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.first_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.first_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invoices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_index_offset != 0 {
            os.write_uint64(2, self.last_index_offset)?;
        }
        if self.first_index_offset != 0 {
            os.write_uint64(3, self.first_index_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceResponse {
        ListInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Invoice>>(
                "invoices",
                |m: &ListInvoiceResponse| { &m.invoices },
                |m: &mut ListInvoiceResponse| { &mut m.invoices },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "last_index_offset",
                |m: &ListInvoiceResponse| { &m.last_index_offset },
                |m: &mut ListInvoiceResponse| { &mut m.last_index_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "first_index_offset",
                |m: &ListInvoiceResponse| { &m.first_index_offset },
                |m: &mut ListInvoiceResponse| { &mut m.first_index_offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInvoiceResponse>(
                "ListInvoiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListInvoiceResponse {
        static instance: ::protobuf::rt::LazyV2<ListInvoiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListInvoiceResponse::new)
    }
}

impl ::protobuf::Clear for ListInvoiceResponse {
    fn clear(&mut self) {
        self.invoices.clear();
        self.last_index_offset = 0;
        self.first_index_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InvoiceSubscription {
    // message fields
    pub add_index: u64,
    pub settle_index: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvoiceSubscription {
    fn default() -> &'a InvoiceSubscription {
        <InvoiceSubscription as ::protobuf::Message>::default_instance()
    }
}

impl InvoiceSubscription {
    pub fn new() -> InvoiceSubscription {
        ::std::default::Default::default()
    }

    // uint64 add_index = 1;


    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    // uint64 settle_index = 2;


    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }
    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }
}

impl ::protobuf::Message for InvoiceSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.add_index != 0 {
            os.write_uint64(1, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(2, self.settle_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvoiceSubscription {
        InvoiceSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "add_index",
                |m: &InvoiceSubscription| { &m.add_index },
                |m: &mut InvoiceSubscription| { &mut m.add_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "settle_index",
                |m: &InvoiceSubscription| { &m.settle_index },
                |m: &mut InvoiceSubscription| { &mut m.settle_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvoiceSubscription>(
                "InvoiceSubscription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InvoiceSubscription {
        static instance: ::protobuf::rt::LazyV2<InvoiceSubscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InvoiceSubscription::new)
    }
}

impl ::protobuf::Clear for InvoiceSubscription {
    fn clear(&mut self) {
        self.add_index = 0;
        self.settle_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvoiceSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Payment {
    // message fields
    pub payment_hash: ::std::string::String,
    pub value: i64,
    pub creation_date: i64,
    pub fee: i64,
    pub payment_preimage: ::std::string::String,
    pub value_sat: i64,
    pub value_msat: i64,
    pub payment_request: ::std::string::String,
    pub status: Payment_PaymentStatus,
    pub fee_sat: i64,
    pub fee_msat: i64,
    pub creation_time_ns: i64,
    pub htlcs: ::protobuf::RepeatedField<HTLCAttempt>,
    pub payment_index: u64,
    pub failure_reason: PaymentFailureReason,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payment {
    fn default() -> &'a Payment {
        <Payment as ::protobuf::Message>::default_instance()
    }
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    // string payment_hash = 1;


    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // int64 creation_date = 3;


    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }
    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    // int64 fee = 5;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // string payment_preimage = 6;


    pub fn get_payment_preimage(&self) -> &str {
        &self.payment_preimage
    }
    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::string::String) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::string::String {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_preimage, ::std::string::String::new())
    }

    // int64 value_sat = 7;


    pub fn get_value_sat(&self) -> i64 {
        self.value_sat
    }
    pub fn clear_value_sat(&mut self) {
        self.value_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_sat(&mut self, v: i64) {
        self.value_sat = v;
    }

    // int64 value_msat = 8;


    pub fn get_value_msat(&self) -> i64 {
        self.value_msat
    }
    pub fn clear_value_msat(&mut self) {
        self.value_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_msat(&mut self, v: i64) {
        self.value_msat = v;
    }

    // string payment_request = 9;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // .lnrpc.Payment.PaymentStatus status = 10;


    pub fn get_status(&self) -> Payment_PaymentStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Payment_PaymentStatus::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Payment_PaymentStatus) {
        self.status = v;
    }

    // int64 fee_sat = 11;


    pub fn get_fee_sat(&self) -> i64 {
        self.fee_sat
    }
    pub fn clear_fee_sat(&mut self) {
        self.fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_sat(&mut self, v: i64) {
        self.fee_sat = v;
    }

    // int64 fee_msat = 12;


    pub fn get_fee_msat(&self) -> i64 {
        self.fee_msat
    }
    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: i64) {
        self.fee_msat = v;
    }

    // int64 creation_time_ns = 13;


    pub fn get_creation_time_ns(&self) -> i64 {
        self.creation_time_ns
    }
    pub fn clear_creation_time_ns(&mut self) {
        self.creation_time_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_time_ns(&mut self, v: i64) {
        self.creation_time_ns = v;
    }

    // repeated .lnrpc.HTLCAttempt htlcs = 14;


    pub fn get_htlcs(&self) -> &[HTLCAttempt] {
        &self.htlcs
    }
    pub fn clear_htlcs(&mut self) {
        self.htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlcs(&mut self, v: ::protobuf::RepeatedField<HTLCAttempt>) {
        self.htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<HTLCAttempt> {
        &mut self.htlcs
    }

    // Take field
    pub fn take_htlcs(&mut self) -> ::protobuf::RepeatedField<HTLCAttempt> {
        ::std::mem::replace(&mut self.htlcs, ::protobuf::RepeatedField::new())
    }

    // uint64 payment_index = 15;


    pub fn get_payment_index(&self) -> u64 {
        self.payment_index
    }
    pub fn clear_payment_index(&mut self) {
        self.payment_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_payment_index(&mut self, v: u64) {
        self.payment_index = v;
    }

    // .lnrpc.PaymentFailureReason failure_reason = 16;


    pub fn get_failure_reason(&self) -> PaymentFailureReason {
        self.failure_reason
    }
    pub fn clear_failure_reason(&mut self) {
        self.failure_reason = PaymentFailureReason::FAILURE_REASON_NONE;
    }

    // Param is passed by value, moved
    pub fn set_failure_reason(&mut self, v: PaymentFailureReason) {
        self.failure_reason = v;
    }
}

impl ::protobuf::Message for Payment {
    fn is_initialized(&self) -> bool {
        for v in &self.htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_preimage)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_sat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_msat = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_sat = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_msat = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_time_ns = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.htlcs)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.payment_index = tmp;
                },
                16 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.failure_reason, 16, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(5, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_preimage);
        }
        if self.value_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.value_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value_msat != 0 {
            my_size += ::protobuf::rt::value_size(8, self.value_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payment_request);
        }
        if self.status != Payment_PaymentStatus::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(10, self.status);
        }
        if self.fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(11, self.fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(12, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.creation_time_ns != 0 {
            my_size += ::protobuf::rt::value_size(13, self.creation_time_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.payment_index != 0 {
            my_size += ::protobuf::rt::value_size(15, self.payment_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failure_reason != PaymentFailureReason::FAILURE_REASON_NONE {
            my_size += ::protobuf::rt::enum_size(16, self.failure_reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_string(1, &self.payment_hash)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        if self.creation_date != 0 {
            os.write_int64(3, self.creation_date)?;
        }
        if self.fee != 0 {
            os.write_int64(5, self.fee)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_string(6, &self.payment_preimage)?;
        }
        if self.value_sat != 0 {
            os.write_int64(7, self.value_sat)?;
        }
        if self.value_msat != 0 {
            os.write_int64(8, self.value_msat)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(9, &self.payment_request)?;
        }
        if self.status != Payment_PaymentStatus::UNKNOWN {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.fee_sat != 0 {
            os.write_int64(11, self.fee_sat)?;
        }
        if self.fee_msat != 0 {
            os.write_int64(12, self.fee_msat)?;
        }
        if self.creation_time_ns != 0 {
            os.write_int64(13, self.creation_time_ns)?;
        }
        for v in &self.htlcs {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.payment_index != 0 {
            os.write_uint64(15, self.payment_index)?;
        }
        if self.failure_reason != PaymentFailureReason::FAILURE_REASON_NONE {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(&self.failure_reason))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_hash",
                |m: &Payment| { &m.payment_hash },
                |m: &mut Payment| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &Payment| { &m.value },
                |m: &mut Payment| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_date",
                |m: &Payment| { &m.creation_date },
                |m: &mut Payment| { &mut m.creation_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee",
                |m: &Payment| { &m.fee },
                |m: &mut Payment| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_preimage",
                |m: &Payment| { &m.payment_preimage },
                |m: &mut Payment| { &mut m.payment_preimage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value_sat",
                |m: &Payment| { &m.value_sat },
                |m: &mut Payment| { &mut m.value_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value_msat",
                |m: &Payment| { &m.value_msat },
                |m: &mut Payment| { &mut m.value_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_request",
                |m: &Payment| { &m.payment_request },
                |m: &mut Payment| { &mut m.payment_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Payment_PaymentStatus>>(
                "status",
                |m: &Payment| { &m.status },
                |m: &mut Payment| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_sat",
                |m: &Payment| { &m.fee_sat },
                |m: &mut Payment| { &mut m.fee_sat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_msat",
                |m: &Payment| { &m.fee_msat },
                |m: &mut Payment| { &mut m.fee_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_time_ns",
                |m: &Payment| { &m.creation_time_ns },
                |m: &mut Payment| { &mut m.creation_time_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTLCAttempt>>(
                "htlcs",
                |m: &Payment| { &m.htlcs },
                |m: &mut Payment| { &mut m.htlcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "payment_index",
                |m: &Payment| { &m.payment_index },
                |m: &mut Payment| { &mut m.payment_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PaymentFailureReason>>(
                "failure_reason",
                |m: &Payment| { &m.failure_reason },
                |m: &mut Payment| { &mut m.failure_reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payment>(
                "Payment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payment {
        static instance: ::protobuf::rt::LazyV2<Payment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payment::new)
    }
}

impl ::protobuf::Clear for Payment {
    fn clear(&mut self) {
        self.payment_hash.clear();
        self.value = 0;
        self.creation_date = 0;
        self.fee = 0;
        self.payment_preimage.clear();
        self.value_sat = 0;
        self.value_msat = 0;
        self.payment_request.clear();
        self.status = Payment_PaymentStatus::UNKNOWN;
        self.fee_sat = 0;
        self.fee_msat = 0;
        self.creation_time_ns = 0;
        self.htlcs.clear();
        self.payment_index = 0;
        self.failure_reason = PaymentFailureReason::FAILURE_REASON_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Payment_PaymentStatus {
    UNKNOWN = 0,
    IN_FLIGHT = 1,
    SUCCEEDED = 2,
    FAILED = 3,
}

impl ::protobuf::ProtobufEnum for Payment_PaymentStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Payment_PaymentStatus> {
        match value {
            0 => ::std::option::Option::Some(Payment_PaymentStatus::UNKNOWN),
            1 => ::std::option::Option::Some(Payment_PaymentStatus::IN_FLIGHT),
            2 => ::std::option::Option::Some(Payment_PaymentStatus::SUCCEEDED),
            3 => ::std::option::Option::Some(Payment_PaymentStatus::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Payment_PaymentStatus] = &[
            Payment_PaymentStatus::UNKNOWN,
            Payment_PaymentStatus::IN_FLIGHT,
            Payment_PaymentStatus::SUCCEEDED,
            Payment_PaymentStatus::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Payment_PaymentStatus>("Payment.PaymentStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Payment_PaymentStatus {
}

impl ::std::default::Default for Payment_PaymentStatus {
    fn default() -> Self {
        Payment_PaymentStatus::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment_PaymentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HTLCAttempt {
    // message fields
    pub attempt_id: u64,
    pub status: HTLCAttempt_HTLCStatus,
    pub route: ::protobuf::SingularPtrField<Route>,
    pub attempt_time_ns: i64,
    pub resolve_time_ns: i64,
    pub failure: ::protobuf::SingularPtrField<Failure>,
    pub preimage: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTLCAttempt {
    fn default() -> &'a HTLCAttempt {
        <HTLCAttempt as ::protobuf::Message>::default_instance()
    }
}

impl HTLCAttempt {
    pub fn new() -> HTLCAttempt {
        ::std::default::Default::default()
    }

    // uint64 attempt_id = 7;


    pub fn get_attempt_id(&self) -> u64 {
        self.attempt_id
    }
    pub fn clear_attempt_id(&mut self) {
        self.attempt_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt_id(&mut self, v: u64) {
        self.attempt_id = v;
    }

    // .lnrpc.HTLCAttempt.HTLCStatus status = 1;


    pub fn get_status(&self) -> HTLCAttempt_HTLCStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = HTLCAttempt_HTLCStatus::IN_FLIGHT;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: HTLCAttempt_HTLCStatus) {
        self.status = v;
    }

    // .lnrpc.Route route = 2;


    pub fn get_route(&self) -> &Route {
        self.route.as_ref().unwrap_or_else(|| <Route as ::protobuf::Message>::default_instance())
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: Route) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut Route {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> Route {
        self.route.take().unwrap_or_else(|| Route::new())
    }

    // int64 attempt_time_ns = 3;


    pub fn get_attempt_time_ns(&self) -> i64 {
        self.attempt_time_ns
    }
    pub fn clear_attempt_time_ns(&mut self) {
        self.attempt_time_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt_time_ns(&mut self, v: i64) {
        self.attempt_time_ns = v;
    }

    // int64 resolve_time_ns = 4;


    pub fn get_resolve_time_ns(&self) -> i64 {
        self.resolve_time_ns
    }
    pub fn clear_resolve_time_ns(&mut self) {
        self.resolve_time_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_resolve_time_ns(&mut self, v: i64) {
        self.resolve_time_ns = v;
    }

    // .lnrpc.Failure failure = 5;


    pub fn get_failure(&self) -> &Failure {
        self.failure.as_ref().unwrap_or_else(|| <Failure as ::protobuf::Message>::default_instance())
    }
    pub fn clear_failure(&mut self) {
        self.failure.clear();
    }

    pub fn has_failure(&self) -> bool {
        self.failure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failure(&mut self, v: Failure) {
        self.failure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failure(&mut self) -> &mut Failure {
        if self.failure.is_none() {
            self.failure.set_default();
        }
        self.failure.as_mut().unwrap()
    }

    // Take field
    pub fn take_failure(&mut self) -> Failure {
        self.failure.take().unwrap_or_else(|| Failure::new())
    }

    // bytes preimage = 6;


    pub fn get_preimage(&self) -> &[u8] {
        &self.preimage
    }
    pub fn clear_preimage(&mut self) {
        self.preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.preimage
    }

    // Take field
    pub fn take_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.preimage, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HTLCAttempt {
    fn is_initialized(&self) -> bool {
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.failure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.attempt_id = tmp;
                },
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.attempt_time_ns = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.resolve_time_ns = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.failure)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.preimage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.attempt_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.attempt_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != HTLCAttempt_HTLCStatus::IN_FLIGHT {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.attempt_time_ns != 0 {
            my_size += ::protobuf::rt::value_size(3, self.attempt_time_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resolve_time_ns != 0 {
            my_size += ::protobuf::rt::value_size(4, self.resolve_time_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.failure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.preimage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.attempt_id != 0 {
            os.write_uint64(7, self.attempt_id)?;
        }
        if self.status != HTLCAttempt_HTLCStatus::IN_FLIGHT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.attempt_time_ns != 0 {
            os.write_int64(3, self.attempt_time_ns)?;
        }
        if self.resolve_time_ns != 0 {
            os.write_int64(4, self.resolve_time_ns)?;
        }
        if let Some(ref v) = self.failure.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.preimage.is_empty() {
            os.write_bytes(6, &self.preimage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTLCAttempt {
        HTLCAttempt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "attempt_id",
                |m: &HTLCAttempt| { &m.attempt_id },
                |m: &mut HTLCAttempt| { &mut m.attempt_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HTLCAttempt_HTLCStatus>>(
                "status",
                |m: &HTLCAttempt| { &m.status },
                |m: &mut HTLCAttempt| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                "route",
                |m: &HTLCAttempt| { &m.route },
                |m: &mut HTLCAttempt| { &mut m.route },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "attempt_time_ns",
                |m: &HTLCAttempt| { &m.attempt_time_ns },
                |m: &mut HTLCAttempt| { &mut m.attempt_time_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "resolve_time_ns",
                |m: &HTLCAttempt| { &m.resolve_time_ns },
                |m: &mut HTLCAttempt| { &mut m.resolve_time_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Failure>>(
                "failure",
                |m: &HTLCAttempt| { &m.failure },
                |m: &mut HTLCAttempt| { &mut m.failure },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "preimage",
                |m: &HTLCAttempt| { &m.preimage },
                |m: &mut HTLCAttempt| { &mut m.preimage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTLCAttempt>(
                "HTLCAttempt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTLCAttempt {
        static instance: ::protobuf::rt::LazyV2<HTLCAttempt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTLCAttempt::new)
    }
}

impl ::protobuf::Clear for HTLCAttempt {
    fn clear(&mut self) {
        self.attempt_id = 0;
        self.status = HTLCAttempt_HTLCStatus::IN_FLIGHT;
        self.route.clear();
        self.attempt_time_ns = 0;
        self.resolve_time_ns = 0;
        self.failure.clear();
        self.preimage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTLCAttempt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTLCAttempt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum HTLCAttempt_HTLCStatus {
    IN_FLIGHT = 0,
    SUCCEEDED = 1,
    FAILED = 2,
}

impl ::protobuf::ProtobufEnum for HTLCAttempt_HTLCStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HTLCAttempt_HTLCStatus> {
        match value {
            0 => ::std::option::Option::Some(HTLCAttempt_HTLCStatus::IN_FLIGHT),
            1 => ::std::option::Option::Some(HTLCAttempt_HTLCStatus::SUCCEEDED),
            2 => ::std::option::Option::Some(HTLCAttempt_HTLCStatus::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HTLCAttempt_HTLCStatus] = &[
            HTLCAttempt_HTLCStatus::IN_FLIGHT,
            HTLCAttempt_HTLCStatus::SUCCEEDED,
            HTLCAttempt_HTLCStatus::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HTLCAttempt_HTLCStatus>("HTLCAttempt.HTLCStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HTLCAttempt_HTLCStatus {
}

impl ::std::default::Default for HTLCAttempt_HTLCStatus {
    fn default() -> Self {
        HTLCAttempt_HTLCStatus::IN_FLIGHT
    }
}

impl ::protobuf::reflect::ProtobufValue for HTLCAttempt_HTLCStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListPaymentsRequest {
    // message fields
    pub include_incomplete: bool,
    pub index_offset: u64,
    pub max_payments: u64,
    pub reversed: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPaymentsRequest {
    fn default() -> &'a ListPaymentsRequest {
        <ListPaymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPaymentsRequest {
    pub fn new() -> ListPaymentsRequest {
        ::std::default::Default::default()
    }

    // bool include_incomplete = 1;


    pub fn get_include_incomplete(&self) -> bool {
        self.include_incomplete
    }
    pub fn clear_include_incomplete(&mut self) {
        self.include_incomplete = false;
    }

    // Param is passed by value, moved
    pub fn set_include_incomplete(&mut self, v: bool) {
        self.include_incomplete = v;
    }

    // uint64 index_offset = 2;


    pub fn get_index_offset(&self) -> u64 {
        self.index_offset
    }
    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u64) {
        self.index_offset = v;
    }

    // uint64 max_payments = 3;


    pub fn get_max_payments(&self) -> u64 {
        self.max_payments
    }
    pub fn clear_max_payments(&mut self) {
        self.max_payments = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_payments(&mut self, v: u64) {
        self.max_payments = v;
    }

    // bool reversed = 4;


    pub fn get_reversed(&self) -> bool {
        self.reversed
    }
    pub fn clear_reversed(&mut self) {
        self.reversed = false;
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: bool) {
        self.reversed = v;
    }
}

impl ::protobuf::Message for ListPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_incomplete = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index_offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_payments = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reversed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_incomplete != false {
            my_size += 2;
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_payments != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_payments, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reversed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.include_incomplete != false {
            os.write_bool(1, self.include_incomplete)?;
        }
        if self.index_offset != 0 {
            os.write_uint64(2, self.index_offset)?;
        }
        if self.max_payments != 0 {
            os.write_uint64(3, self.max_payments)?;
        }
        if self.reversed != false {
            os.write_bool(4, self.reversed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPaymentsRequest {
        ListPaymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_incomplete",
                |m: &ListPaymentsRequest| { &m.include_incomplete },
                |m: &mut ListPaymentsRequest| { &mut m.include_incomplete },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "index_offset",
                |m: &ListPaymentsRequest| { &m.index_offset },
                |m: &mut ListPaymentsRequest| { &mut m.index_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_payments",
                |m: &ListPaymentsRequest| { &m.max_payments },
                |m: &mut ListPaymentsRequest| { &mut m.max_payments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reversed",
                |m: &ListPaymentsRequest| { &m.reversed },
                |m: &mut ListPaymentsRequest| { &mut m.reversed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPaymentsRequest>(
                "ListPaymentsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPaymentsRequest {
        static instance: ::protobuf::rt::LazyV2<ListPaymentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPaymentsRequest::new)
    }
}

impl ::protobuf::Clear for ListPaymentsRequest {
    fn clear(&mut self) {
        self.include_incomplete = false;
        self.index_offset = 0;
        self.max_payments = 0;
        self.reversed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListPaymentsResponse {
    // message fields
    pub payments: ::protobuf::RepeatedField<Payment>,
    pub first_index_offset: u64,
    pub last_index_offset: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPaymentsResponse {
    fn default() -> &'a ListPaymentsResponse {
        <ListPaymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPaymentsResponse {
    pub fn new() -> ListPaymentsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Payment payments = 1;


    pub fn get_payments(&self) -> &[Payment] {
        &self.payments
    }
    pub fn clear_payments(&mut self) {
        self.payments.clear();
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: ::protobuf::RepeatedField<Payment>) {
        self.payments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payments(&mut self) -> &mut ::protobuf::RepeatedField<Payment> {
        &mut self.payments
    }

    // Take field
    pub fn take_payments(&mut self) -> ::protobuf::RepeatedField<Payment> {
        ::std::mem::replace(&mut self.payments, ::protobuf::RepeatedField::new())
    }

    // uint64 first_index_offset = 2;


    pub fn get_first_index_offset(&self) -> u64 {
        self.first_index_offset
    }
    pub fn clear_first_index_offset(&mut self) {
        self.first_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_index_offset(&mut self, v: u64) {
        self.first_index_offset = v;
    }

    // uint64 last_index_offset = 3;


    pub fn get_last_index_offset(&self) -> u64 {
        self.last_index_offset
    }
    pub fn clear_last_index_offset(&mut self) {
        self.last_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_index_offset(&mut self, v: u64) {
        self.last_index_offset = v;
    }
}

impl ::protobuf::Message for ListPaymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payments)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.first_index_offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_index_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.payments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.first_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.first_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.payments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.first_index_offset != 0 {
            os.write_uint64(2, self.first_index_offset)?;
        }
        if self.last_index_offset != 0 {
            os.write_uint64(3, self.last_index_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPaymentsResponse {
        ListPaymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payment>>(
                "payments",
                |m: &ListPaymentsResponse| { &m.payments },
                |m: &mut ListPaymentsResponse| { &mut m.payments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "first_index_offset",
                |m: &ListPaymentsResponse| { &m.first_index_offset },
                |m: &mut ListPaymentsResponse| { &mut m.first_index_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "last_index_offset",
                |m: &ListPaymentsResponse| { &m.last_index_offset },
                |m: &mut ListPaymentsResponse| { &mut m.last_index_offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPaymentsResponse>(
                "ListPaymentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPaymentsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPaymentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPaymentsResponse::new)
    }
}

impl ::protobuf::Clear for ListPaymentsResponse {
    fn clear(&mut self) {
        self.payments.clear();
        self.first_index_offset = 0;
        self.last_index_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeleteAllPaymentsRequest {
    // message fields
    pub failed_payments_only: bool,
    pub failed_htlcs_only: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAllPaymentsRequest {
    fn default() -> &'a DeleteAllPaymentsRequest {
        <DeleteAllPaymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAllPaymentsRequest {
    pub fn new() -> DeleteAllPaymentsRequest {
        ::std::default::Default::default()
    }

    // bool failed_payments_only = 1;


    pub fn get_failed_payments_only(&self) -> bool {
        self.failed_payments_only
    }
    pub fn clear_failed_payments_only(&mut self) {
        self.failed_payments_only = false;
    }

    // Param is passed by value, moved
    pub fn set_failed_payments_only(&mut self, v: bool) {
        self.failed_payments_only = v;
    }

    // bool failed_htlcs_only = 2;


    pub fn get_failed_htlcs_only(&self) -> bool {
        self.failed_htlcs_only
    }
    pub fn clear_failed_htlcs_only(&mut self) {
        self.failed_htlcs_only = false;
    }

    // Param is passed by value, moved
    pub fn set_failed_htlcs_only(&mut self, v: bool) {
        self.failed_htlcs_only = v;
    }
}

impl ::protobuf::Message for DeleteAllPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failed_payments_only = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failed_htlcs_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.failed_payments_only != false {
            my_size += 2;
        }
        if self.failed_htlcs_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.failed_payments_only != false {
            os.write_bool(1, self.failed_payments_only)?;
        }
        if self.failed_htlcs_only != false {
            os.write_bool(2, self.failed_htlcs_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAllPaymentsRequest {
        DeleteAllPaymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "failed_payments_only",
                |m: &DeleteAllPaymentsRequest| { &m.failed_payments_only },
                |m: &mut DeleteAllPaymentsRequest| { &mut m.failed_payments_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "failed_htlcs_only",
                |m: &DeleteAllPaymentsRequest| { &m.failed_htlcs_only },
                |m: &mut DeleteAllPaymentsRequest| { &mut m.failed_htlcs_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAllPaymentsRequest>(
                "DeleteAllPaymentsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAllPaymentsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAllPaymentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAllPaymentsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAllPaymentsRequest {
    fn clear(&mut self) {
        self.failed_payments_only = false;
        self.failed_htlcs_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAllPaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAllPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeleteAllPaymentsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAllPaymentsResponse {
    fn default() -> &'a DeleteAllPaymentsResponse {
        <DeleteAllPaymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAllPaymentsResponse {
    pub fn new() -> DeleteAllPaymentsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteAllPaymentsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAllPaymentsResponse {
        DeleteAllPaymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAllPaymentsResponse>(
                "DeleteAllPaymentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAllPaymentsResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteAllPaymentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAllPaymentsResponse::new)
    }
}

impl ::protobuf::Clear for DeleteAllPaymentsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAllPaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAllPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AbandonChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub pending_funding_shim_only: bool,
    pub i_know_what_i_am_doing: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonChannelRequest {
    fn default() -> &'a AbandonChannelRequest {
        <AbandonChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl AbandonChannelRequest {
    pub fn new() -> AbandonChannelRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;


    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // bool pending_funding_shim_only = 2;


    pub fn get_pending_funding_shim_only(&self) -> bool {
        self.pending_funding_shim_only
    }
    pub fn clear_pending_funding_shim_only(&mut self) {
        self.pending_funding_shim_only = false;
    }

    // Param is passed by value, moved
    pub fn set_pending_funding_shim_only(&mut self, v: bool) {
        self.pending_funding_shim_only = v;
    }

    // bool i_know_what_i_am_doing = 3;


    pub fn get_i_know_what_i_am_doing(&self) -> bool {
        self.i_know_what_i_am_doing
    }
    pub fn clear_i_know_what_i_am_doing(&mut self) {
        self.i_know_what_i_am_doing = false;
    }

    // Param is passed by value, moved
    pub fn set_i_know_what_i_am_doing(&mut self, v: bool) {
        self.i_know_what_i_am_doing = v;
    }
}

impl ::protobuf::Message for AbandonChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending_funding_shim_only = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.i_know_what_i_am_doing = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.pending_funding_shim_only != false {
            my_size += 2;
        }
        if self.i_know_what_i_am_doing != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.pending_funding_shim_only != false {
            os.write_bool(2, self.pending_funding_shim_only)?;
        }
        if self.i_know_what_i_am_doing != false {
            os.write_bool(3, self.i_know_what_i_am_doing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonChannelRequest {
        AbandonChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "channel_point",
                |m: &AbandonChannelRequest| { &m.channel_point },
                |m: &mut AbandonChannelRequest| { &mut m.channel_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pending_funding_shim_only",
                |m: &AbandonChannelRequest| { &m.pending_funding_shim_only },
                |m: &mut AbandonChannelRequest| { &mut m.pending_funding_shim_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "i_know_what_i_am_doing",
                |m: &AbandonChannelRequest| { &m.i_know_what_i_am_doing },
                |m: &mut AbandonChannelRequest| { &mut m.i_know_what_i_am_doing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AbandonChannelRequest>(
                "AbandonChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AbandonChannelRequest {
        static instance: ::protobuf::rt::LazyV2<AbandonChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AbandonChannelRequest::new)
    }
}

impl ::protobuf::Clear for AbandonChannelRequest {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.pending_funding_shim_only = false;
        self.i_know_what_i_am_doing = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AbandonChannelResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonChannelResponse {
    fn default() -> &'a AbandonChannelResponse {
        <AbandonChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl AbandonChannelResponse {
    pub fn new() -> AbandonChannelResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AbandonChannelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonChannelResponse {
        AbandonChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AbandonChannelResponse>(
                "AbandonChannelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AbandonChannelResponse {
        static instance: ::protobuf::rt::LazyV2<AbandonChannelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AbandonChannelResponse::new)
    }
}

impl ::protobuf::Clear for AbandonChannelResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugLevelRequest {
    // message fields
    pub show: bool,
    pub level_spec: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugLevelRequest {
    fn default() -> &'a DebugLevelRequest {
        <DebugLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DebugLevelRequest {
    pub fn new() -> DebugLevelRequest {
        ::std::default::Default::default()
    }

    // bool show = 1;


    pub fn get_show(&self) -> bool {
        self.show
    }
    pub fn clear_show(&mut self) {
        self.show = false;
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = v;
    }

    // string level_spec = 2;


    pub fn get_level_spec(&self) -> &str {
        &self.level_spec
    }
    pub fn clear_level_spec(&mut self) {
        self.level_spec.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_spec(&mut self, v: ::std::string::String) {
        self.level_spec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_spec(&mut self) -> &mut ::std::string::String {
        &mut self.level_spec
    }

    // Take field
    pub fn take_level_spec(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level_spec, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DebugLevelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.show != false {
            my_size += 2;
        }
        if !self.level_spec.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.level_spec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.show != false {
            os.write_bool(1, self.show)?;
        }
        if !self.level_spec.is_empty() {
            os.write_string(2, &self.level_spec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLevelRequest {
        DebugLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show",
                |m: &DebugLevelRequest| { &m.show },
                |m: &mut DebugLevelRequest| { &mut m.show },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level_spec",
                |m: &DebugLevelRequest| { &m.level_spec },
                |m: &mut DebugLevelRequest| { &mut m.level_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugLevelRequest>(
                "DebugLevelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugLevelRequest {
        static instance: ::protobuf::rt::LazyV2<DebugLevelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugLevelRequest::new)
    }
}

impl ::protobuf::Clear for DebugLevelRequest {
    fn clear(&mut self) {
        self.show = false;
        self.level_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugLevelResponse {
    // message fields
    pub sub_systems: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugLevelResponse {
    fn default() -> &'a DebugLevelResponse {
        <DebugLevelResponse as ::protobuf::Message>::default_instance()
    }
}

impl DebugLevelResponse {
    pub fn new() -> DebugLevelResponse {
        ::std::default::Default::default()
    }

    // string sub_systems = 1;


    pub fn get_sub_systems(&self) -> &str {
        &self.sub_systems
    }
    pub fn clear_sub_systems(&mut self) {
        self.sub_systems.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_systems(&mut self, v: ::std::string::String) {
        self.sub_systems = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_systems(&mut self) -> &mut ::std::string::String {
        &mut self.sub_systems
    }

    // Take field
    pub fn take_sub_systems(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_systems, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DebugLevelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sub_systems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sub_systems.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sub_systems);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sub_systems.is_empty() {
            os.write_string(1, &self.sub_systems)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLevelResponse {
        DebugLevelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sub_systems",
                |m: &DebugLevelResponse| { &m.sub_systems },
                |m: &mut DebugLevelResponse| { &mut m.sub_systems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugLevelResponse>(
                "DebugLevelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugLevelResponse {
        static instance: ::protobuf::rt::LazyV2<DebugLevelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugLevelResponse::new)
    }
}

impl ::protobuf::Clear for DebugLevelResponse {
    fn clear(&mut self) {
        self.sub_systems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLevelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLevelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PayReqString {
    // message fields
    pub pay_req: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayReqString {
    fn default() -> &'a PayReqString {
        <PayReqString as ::protobuf::Message>::default_instance()
    }
}

impl PayReqString {
    pub fn new() -> PayReqString {
        ::std::default::Default::default()
    }

    // string pay_req = 1;


    pub fn get_pay_req(&self) -> &str {
        &self.pay_req
    }
    pub fn clear_pay_req(&mut self) {
        self.pay_req.clear();
    }

    // Param is passed by value, moved
    pub fn set_pay_req(&mut self, v: ::std::string::String) {
        self.pay_req = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pay_req(&mut self) -> &mut ::std::string::String {
        &mut self.pay_req
    }

    // Take field
    pub fn take_pay_req(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pay_req, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PayReqString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pay_req)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pay_req.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pay_req);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pay_req.is_empty() {
            os.write_string(1, &self.pay_req)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReqString {
        PayReqString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pay_req",
                |m: &PayReqString| { &m.pay_req },
                |m: &mut PayReqString| { &mut m.pay_req },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PayReqString>(
                "PayReqString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PayReqString {
        static instance: ::protobuf::rt::LazyV2<PayReqString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PayReqString::new)
    }
}

impl ::protobuf::Clear for PayReqString {
    fn clear(&mut self) {
        self.pay_req.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReqString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReqString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PayReq {
    // message fields
    pub destination: ::std::string::String,
    pub payment_hash: ::std::string::String,
    pub num_satoshis: i64,
    pub timestamp: i64,
    pub expiry: i64,
    pub description: ::std::string::String,
    pub description_hash: ::std::string::String,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: i64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    pub payment_addr: ::std::vec::Vec<u8>,
    pub num_msat: i64,
    pub features: ::std::collections::HashMap<u32, Feature>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayReq {
    fn default() -> &'a PayReq {
        <PayReq as ::protobuf::Message>::default_instance()
    }
}

impl PayReq {
    pub fn new() -> PayReq {
        ::std::default::Default::default()
    }

    // string destination = 1;


    pub fn get_destination(&self) -> &str {
        &self.destination
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    // string payment_hash = 2;


    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    // int64 num_satoshis = 3;


    pub fn get_num_satoshis(&self) -> i64 {
        self.num_satoshis
    }
    pub fn clear_num_satoshis(&mut self) {
        self.num_satoshis = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_satoshis(&mut self, v: i64) {
        self.num_satoshis = v;
    }

    // int64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // int64 expiry = 5;


    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    // string description = 6;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string description_hash = 7;


    pub fn get_description_hash(&self) -> &str {
        &self.description_hash
    }
    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::string::String) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::string::String {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description_hash, ::std::string::String::new())
    }

    // string fallback_addr = 8;


    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }
    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    // int64 cltv_expiry = 9;


    pub fn get_cltv_expiry(&self) -> i64 {
        self.cltv_expiry
    }
    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: i64) {
        self.cltv_expiry = v;
    }

    // repeated .lnrpc.RouteHint route_hints = 10;


    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    // bytes payment_addr = 11;


    pub fn get_payment_addr(&self) -> &[u8] {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_addr, ::std::vec::Vec::new())
    }

    // int64 num_msat = 12;


    pub fn get_num_msat(&self) -> i64 {
        self.num_msat
    }
    pub fn clear_num_msat(&mut self) {
        self.num_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_msat(&mut self, v: i64) {
        self.num_msat = v;
    }

    // repeated .lnrpc.PayReq.FeaturesEntry features = 13;


    pub fn get_features(&self) -> &::std::collections::HashMap<u32, Feature> {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::collections::HashMap<u32, Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::std::collections::HashMap<u32, Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::collections::HashMap<u32, Feature> {
        ::std::mem::replace(&mut self.features, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PayReq {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_satoshis = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description_hash)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cltv_expiry = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_addr)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_msat = tmp;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(wire_type, is, &mut self.features)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash);
        }
        if self.num_satoshis != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_satoshis, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description_hash);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.payment_addr);
        }
        if self.num_msat != 0 {
            my_size += ::protobuf::rt::value_size(12, self.num_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(13, &self.features);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_string(2, &self.payment_hash)?;
        }
        if self.num_satoshis != 0 {
            os.write_int64(3, self.num_satoshis)?;
        }
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        if self.expiry != 0 {
            os.write_int64(5, self.expiry)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.description_hash.is_empty() {
            os.write_string(7, &self.description_hash)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(8, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_int64(9, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.payment_addr.is_empty() {
            os.write_bytes(11, &self.payment_addr)?;
        }
        if self.num_msat != 0 {
            os.write_int64(12, self.num_msat)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(13, &self.features, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReq {
        PayReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination",
                |m: &PayReq| { &m.destination },
                |m: &mut PayReq| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_hash",
                |m: &PayReq| { &m.payment_hash },
                |m: &mut PayReq| { &mut m.payment_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_satoshis",
                |m: &PayReq| { &m.num_satoshis },
                |m: &mut PayReq| { &mut m.num_satoshis },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &PayReq| { &m.timestamp },
                |m: &mut PayReq| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiry",
                |m: &PayReq| { &m.expiry },
                |m: &mut PayReq| { &mut m.expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PayReq| { &m.description },
                |m: &mut PayReq| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description_hash",
                |m: &PayReq| { &m.description_hash },
                |m: &mut PayReq| { &mut m.description_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fallback_addr",
                |m: &PayReq| { &m.fallback_addr },
                |m: &mut PayReq| { &mut m.fallback_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cltv_expiry",
                |m: &PayReq| { &m.cltv_expiry },
                |m: &mut PayReq| { &mut m.cltv_expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                "route_hints",
                |m: &PayReq| { &m.route_hints },
                |m: &mut PayReq| { &mut m.route_hints },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_addr",
                |m: &PayReq| { &m.payment_addr },
                |m: &mut PayReq| { &mut m.payment_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_msat",
                |m: &PayReq| { &m.num_msat },
                |m: &mut PayReq| { &mut m.num_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &PayReq| { &m.features },
                |m: &mut PayReq| { &mut m.features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PayReq>(
                "PayReq",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PayReq {
        static instance: ::protobuf::rt::LazyV2<PayReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PayReq::new)
    }
}

impl ::protobuf::Clear for PayReq {
    fn clear(&mut self) {
        self.destination.clear();
        self.payment_hash.clear();
        self.num_satoshis = 0;
        self.timestamp = 0;
        self.expiry = 0;
        self.description.clear();
        self.description_hash.clear();
        self.fallback_addr.clear();
        self.cltv_expiry = 0;
        self.route_hints.clear();
        self.payment_addr.clear();
        self.num_msat = 0;
        self.features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Feature {
    // message fields
    pub name: ::std::string::String,
    pub is_required: bool,
    pub is_known: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Feature {
    fn default() -> &'a Feature {
        <Feature as ::protobuf::Message>::default_instance()
    }
}

impl Feature {
    pub fn new() -> Feature {
        ::std::default::Default::default()
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool is_required = 3;


    pub fn get_is_required(&self) -> bool {
        self.is_required
    }
    pub fn clear_is_required(&mut self) {
        self.is_required = false;
    }

    // Param is passed by value, moved
    pub fn set_is_required(&mut self, v: bool) {
        self.is_required = v;
    }

    // bool is_known = 4;


    pub fn get_is_known(&self) -> bool {
        self.is_known
    }
    pub fn clear_is_known(&mut self) {
        self.is_known = false;
    }

    // Param is passed by value, moved
    pub fn set_is_known(&mut self, v: bool) {
        self.is_known = v;
    }
}

impl ::protobuf::Message for Feature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_required = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_known = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.is_required != false {
            my_size += 2;
        }
        if self.is_known != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.is_required != false {
            os.write_bool(3, self.is_required)?;
        }
        if self.is_known != false {
            os.write_bool(4, self.is_known)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Feature {
        Feature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Feature| { &m.name },
                |m: &mut Feature| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_required",
                |m: &Feature| { &m.is_required },
                |m: &mut Feature| { &mut m.is_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_known",
                |m: &Feature| { &m.is_known },
                |m: &mut Feature| { &mut m.is_known },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Feature>(
                "Feature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Feature {
        static instance: ::protobuf::rt::LazyV2<Feature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Feature::new)
    }
}

impl ::protobuf::Clear for Feature {
    fn clear(&mut self) {
        self.name.clear();
        self.is_required = false;
        self.is_known = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Feature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Feature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FeeReportRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeReportRequest {
    fn default() -> &'a FeeReportRequest {
        <FeeReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl FeeReportRequest {
    pub fn new() -> FeeReportRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FeeReportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeReportRequest {
        FeeReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeeReportRequest>(
                "FeeReportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeeReportRequest {
        static instance: ::protobuf::rt::LazyV2<FeeReportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeReportRequest::new)
    }
}

impl ::protobuf::Clear for FeeReportRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelFeeReport {
    // message fields
    pub chan_id: u64,
    pub channel_point: ::std::string::String,
    pub base_fee_msat: i64,
    pub fee_per_mil: i64,
    pub fee_rate: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelFeeReport {
    fn default() -> &'a ChannelFeeReport {
        <ChannelFeeReport as ::protobuf::Message>::default_instance()
    }
}

impl ChannelFeeReport {
    pub fn new() -> ChannelFeeReport {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 5;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // string channel_point = 1;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // int64 base_fee_msat = 2;


    pub fn get_base_fee_msat(&self) -> i64 {
        self.base_fee_msat
    }
    pub fn clear_base_fee_msat(&mut self) {
        self.base_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee_msat(&mut self, v: i64) {
        self.base_fee_msat = v;
    }

    // int64 fee_per_mil = 3;


    pub fn get_fee_per_mil(&self) -> i64 {
        self.fee_per_mil
    }
    pub fn clear_fee_per_mil(&mut self) {
        self.fee_per_mil = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_mil(&mut self, v: i64) {
        self.fee_per_mil = v;
    }

    // double fee_rate = 4;


    pub fn get_fee_rate(&self) -> f64 {
        self.fee_rate
    }
    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: f64) {
        self.fee_rate = v;
    }
}

impl ::protobuf::Message for ChannelFeeReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_fee_msat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_mil = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.fee_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_point);
        }
        if self.base_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.base_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_mil != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_per_mil, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(5, self.chan_id)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(1, &self.channel_point)?;
        }
        if self.base_fee_msat != 0 {
            os.write_int64(2, self.base_fee_msat)?;
        }
        if self.fee_per_mil != 0 {
            os.write_int64(3, self.fee_per_mil)?;
        }
        if self.fee_rate != 0. {
            os.write_double(4, self.fee_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelFeeReport {
        ChannelFeeReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &ChannelFeeReport| { &m.chan_id },
                |m: &mut ChannelFeeReport| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_point",
                |m: &ChannelFeeReport| { &m.channel_point },
                |m: &mut ChannelFeeReport| { &mut m.channel_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "base_fee_msat",
                |m: &ChannelFeeReport| { &m.base_fee_msat },
                |m: &mut ChannelFeeReport| { &mut m.base_fee_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_per_mil",
                |m: &ChannelFeeReport| { &m.fee_per_mil },
                |m: &mut ChannelFeeReport| { &mut m.fee_per_mil },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "fee_rate",
                |m: &ChannelFeeReport| { &m.fee_rate },
                |m: &mut ChannelFeeReport| { &mut m.fee_rate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelFeeReport>(
                "ChannelFeeReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelFeeReport {
        static instance: ::protobuf::rt::LazyV2<ChannelFeeReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelFeeReport::new)
    }
}

impl ::protobuf::Clear for ChannelFeeReport {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.channel_point.clear();
        self.base_fee_msat = 0;
        self.fee_per_mil = 0;
        self.fee_rate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelFeeReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelFeeReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FeeReportResponse {
    // message fields
    pub channel_fees: ::protobuf::RepeatedField<ChannelFeeReport>,
    pub day_fee_sum: u64,
    pub week_fee_sum: u64,
    pub month_fee_sum: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeReportResponse {
    fn default() -> &'a FeeReportResponse {
        <FeeReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl FeeReportResponse {
    pub fn new() -> FeeReportResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelFeeReport channel_fees = 1;


    pub fn get_channel_fees(&self) -> &[ChannelFeeReport] {
        &self.channel_fees
    }
    pub fn clear_channel_fees(&mut self) {
        self.channel_fees.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_fees(&mut self, v: ::protobuf::RepeatedField<ChannelFeeReport>) {
        self.channel_fees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_fees(&mut self) -> &mut ::protobuf::RepeatedField<ChannelFeeReport> {
        &mut self.channel_fees
    }

    // Take field
    pub fn take_channel_fees(&mut self) -> ::protobuf::RepeatedField<ChannelFeeReport> {
        ::std::mem::replace(&mut self.channel_fees, ::protobuf::RepeatedField::new())
    }

    // uint64 day_fee_sum = 2;


    pub fn get_day_fee_sum(&self) -> u64 {
        self.day_fee_sum
    }
    pub fn clear_day_fee_sum(&mut self) {
        self.day_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_day_fee_sum(&mut self, v: u64) {
        self.day_fee_sum = v;
    }

    // uint64 week_fee_sum = 3;


    pub fn get_week_fee_sum(&self) -> u64 {
        self.week_fee_sum
    }
    pub fn clear_week_fee_sum(&mut self) {
        self.week_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_week_fee_sum(&mut self, v: u64) {
        self.week_fee_sum = v;
    }

    // uint64 month_fee_sum = 4;


    pub fn get_month_fee_sum(&self) -> u64 {
        self.month_fee_sum
    }
    pub fn clear_month_fee_sum(&mut self) {
        self.month_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_month_fee_sum(&mut self, v: u64) {
        self.month_fee_sum = v;
    }
}

impl ::protobuf::Message for FeeReportResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_fees {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_fees)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.day_fee_sum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.week_fee_sum = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.month_fee_sum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channel_fees {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.day_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.day_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.week_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.week_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.month_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.month_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channel_fees {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.day_fee_sum != 0 {
            os.write_uint64(2, self.day_fee_sum)?;
        }
        if self.week_fee_sum != 0 {
            os.write_uint64(3, self.week_fee_sum)?;
        }
        if self.month_fee_sum != 0 {
            os.write_uint64(4, self.month_fee_sum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeReportResponse {
        FeeReportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelFeeReport>>(
                "channel_fees",
                |m: &FeeReportResponse| { &m.channel_fees },
                |m: &mut FeeReportResponse| { &mut m.channel_fees },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "day_fee_sum",
                |m: &FeeReportResponse| { &m.day_fee_sum },
                |m: &mut FeeReportResponse| { &mut m.day_fee_sum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "week_fee_sum",
                |m: &FeeReportResponse| { &m.week_fee_sum },
                |m: &mut FeeReportResponse| { &mut m.week_fee_sum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "month_fee_sum",
                |m: &FeeReportResponse| { &m.month_fee_sum },
                |m: &mut FeeReportResponse| { &mut m.month_fee_sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeeReportResponse>(
                "FeeReportResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeeReportResponse {
        static instance: ::protobuf::rt::LazyV2<FeeReportResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeReportResponse::new)
    }
}

impl ::protobuf::Clear for FeeReportResponse {
    fn clear(&mut self) {
        self.channel_fees.clear();
        self.day_fee_sum = 0;
        self.week_fee_sum = 0;
        self.month_fee_sum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PolicyUpdateRequest {
    // message fields
    pub base_fee_msat: i64,
    pub fee_rate: f64,
    pub time_lock_delta: u32,
    pub max_htlc_msat: u64,
    pub min_htlc_msat: u64,
    pub min_htlc_msat_specified: bool,
    // message oneof groups
    pub scope: ::std::option::Option<PolicyUpdateRequest_oneof_scope>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolicyUpdateRequest {
    fn default() -> &'a PolicyUpdateRequest {
        <PolicyUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PolicyUpdateRequest_oneof_scope {
    global(bool),
    chan_point(ChannelPoint),
}

impl PolicyUpdateRequest {
    pub fn new() -> PolicyUpdateRequest {
        ::std::default::Default::default()
    }

    // bool global = 1;


    pub fn get_global(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(v)) => v,
            _ => false,
        }
    }
    pub fn clear_global(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_global(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: bool) {
        self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(v))
    }

    // .lnrpc.ChannelPoint chan_point = 2;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ref v)) => v,
            _ => <ChannelPoint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chan_point(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_chan_point(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(_)) = self.scope {
        } else {
            self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ChannelPoint::new()));
        }
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        if self.has_chan_point() {
            match self.scope.take() {
                ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    // int64 base_fee_msat = 3;


    pub fn get_base_fee_msat(&self) -> i64 {
        self.base_fee_msat
    }
    pub fn clear_base_fee_msat(&mut self) {
        self.base_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee_msat(&mut self, v: i64) {
        self.base_fee_msat = v;
    }

    // double fee_rate = 4;


    pub fn get_fee_rate(&self) -> f64 {
        self.fee_rate
    }
    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: f64) {
        self.fee_rate = v;
    }

    // uint32 time_lock_delta = 5;


    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    // uint64 max_htlc_msat = 6;


    pub fn get_max_htlc_msat(&self) -> u64 {
        self.max_htlc_msat
    }
    pub fn clear_max_htlc_msat(&mut self) {
        self.max_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_htlc_msat(&mut self, v: u64) {
        self.max_htlc_msat = v;
    }

    // uint64 min_htlc_msat = 7;


    pub fn get_min_htlc_msat(&self) -> u64 {
        self.min_htlc_msat
    }
    pub fn clear_min_htlc_msat(&mut self) {
        self.min_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_msat(&mut self, v: u64) {
        self.min_htlc_msat = v;
    }

    // bool min_htlc_msat_specified = 8;


    pub fn get_min_htlc_msat_specified(&self) -> bool {
        self.min_htlc_msat_specified
    }
    pub fn clear_min_htlc_msat_specified(&mut self) {
        self.min_htlc_msat_specified = false;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_msat_specified(&mut self, v: bool) {
        self.min_htlc_msat_specified = v;
    }
}

impl ::protobuf::Message for PolicyUpdateRequest {
    fn is_initialized(&self) -> bool {
        if let Some(PolicyUpdateRequest_oneof_scope::chan_point(ref v)) = self.scope {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_fee_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.fee_rate = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_htlc_msat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_htlc_msat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.min_htlc_msat_specified = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.base_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.base_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0. {
            my_size += 9;
        }
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.min_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc_msat_specified != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &PolicyUpdateRequest_oneof_scope::global(v) => {
                    my_size += 2;
                },
                &PolicyUpdateRequest_oneof_scope::chan_point(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.base_fee_msat != 0 {
            os.write_int64(3, self.base_fee_msat)?;
        }
        if self.fee_rate != 0. {
            os.write_double(4, self.fee_rate)?;
        }
        if self.time_lock_delta != 0 {
            os.write_uint32(5, self.time_lock_delta)?;
        }
        if self.max_htlc_msat != 0 {
            os.write_uint64(6, self.max_htlc_msat)?;
        }
        if self.min_htlc_msat != 0 {
            os.write_uint64(7, self.min_htlc_msat)?;
        }
        if self.min_htlc_msat_specified != false {
            os.write_bool(8, self.min_htlc_msat_specified)?;
        }
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &PolicyUpdateRequest_oneof_scope::global(v) => {
                    os.write_bool(1, v)?;
                },
                &PolicyUpdateRequest_oneof_scope::chan_point(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyUpdateRequest {
        PolicyUpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "global",
                PolicyUpdateRequest::has_global,
                PolicyUpdateRequest::get_global,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                "chan_point",
                PolicyUpdateRequest::has_chan_point,
                PolicyUpdateRequest::get_chan_point,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "base_fee_msat",
                |m: &PolicyUpdateRequest| { &m.base_fee_msat },
                |m: &mut PolicyUpdateRequest| { &mut m.base_fee_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "fee_rate",
                |m: &PolicyUpdateRequest| { &m.fee_rate },
                |m: &mut PolicyUpdateRequest| { &mut m.fee_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_lock_delta",
                |m: &PolicyUpdateRequest| { &m.time_lock_delta },
                |m: &mut PolicyUpdateRequest| { &mut m.time_lock_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_htlc_msat",
                |m: &PolicyUpdateRequest| { &m.max_htlc_msat },
                |m: &mut PolicyUpdateRequest| { &mut m.max_htlc_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "min_htlc_msat",
                |m: &PolicyUpdateRequest| { &m.min_htlc_msat },
                |m: &mut PolicyUpdateRequest| { &mut m.min_htlc_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "min_htlc_msat_specified",
                |m: &PolicyUpdateRequest| { &m.min_htlc_msat_specified },
                |m: &mut PolicyUpdateRequest| { &mut m.min_htlc_msat_specified },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PolicyUpdateRequest>(
                "PolicyUpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PolicyUpdateRequest {
        static instance: ::protobuf::rt::LazyV2<PolicyUpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PolicyUpdateRequest::new)
    }
}

impl ::protobuf::Clear for PolicyUpdateRequest {
    fn clear(&mut self) {
        self.scope = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.base_fee_msat = 0;
        self.fee_rate = 0.;
        self.time_lock_delta = 0;
        self.max_htlc_msat = 0;
        self.min_htlc_msat = 0;
        self.min_htlc_msat_specified = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PolicyUpdateResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolicyUpdateResponse {
    fn default() -> &'a PolicyUpdateResponse {
        <PolicyUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl PolicyUpdateResponse {
    pub fn new() -> PolicyUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PolicyUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyUpdateResponse {
        PolicyUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PolicyUpdateResponse>(
                "PolicyUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PolicyUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<PolicyUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PolicyUpdateResponse::new)
    }
}

impl ::protobuf::Clear for PolicyUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardingHistoryRequest {
    // message fields
    pub start_time: u64,
    pub end_time: u64,
    pub index_offset: u32,
    pub num_max_events: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingHistoryRequest {
    fn default() -> &'a ForwardingHistoryRequest {
        <ForwardingHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingHistoryRequest {
    pub fn new() -> ForwardingHistoryRequest {
        ::std::default::Default::default()
    }

    // uint64 start_time = 1;


    pub fn get_start_time(&self) -> u64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u64) {
        self.start_time = v;
    }

    // uint64 end_time = 2;


    pub fn get_end_time(&self) -> u64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u64) {
        self.end_time = v;
    }

    // uint32 index_offset = 3;


    pub fn get_index_offset(&self) -> u32 {
        self.index_offset
    }
    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u32) {
        self.index_offset = v;
    }

    // uint32 num_max_events = 4;


    pub fn get_num_max_events(&self) -> u32 {
        self.num_max_events
    }
    pub fn clear_num_max_events(&mut self) {
        self.num_max_events = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_events(&mut self, v: u32) {
        self.num_max_events = v;
    }
}

impl ::protobuf::Message for ForwardingHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index_offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_max_events = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_events != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_max_events, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_time != 0 {
            os.write_uint64(1, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_uint64(2, self.end_time)?;
        }
        if self.index_offset != 0 {
            os.write_uint32(3, self.index_offset)?;
        }
        if self.num_max_events != 0 {
            os.write_uint32(4, self.num_max_events)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingHistoryRequest {
        ForwardingHistoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_time",
                |m: &ForwardingHistoryRequest| { &m.start_time },
                |m: &mut ForwardingHistoryRequest| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "end_time",
                |m: &ForwardingHistoryRequest| { &m.end_time },
                |m: &mut ForwardingHistoryRequest| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index_offset",
                |m: &ForwardingHistoryRequest| { &m.index_offset },
                |m: &mut ForwardingHistoryRequest| { &mut m.index_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_max_events",
                |m: &ForwardingHistoryRequest| { &m.num_max_events },
                |m: &mut ForwardingHistoryRequest| { &mut m.num_max_events },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardingHistoryRequest>(
                "ForwardingHistoryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardingHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<ForwardingHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardingHistoryRequest::new)
    }
}

impl ::protobuf::Clear for ForwardingHistoryRequest {
    fn clear(&mut self) {
        self.start_time = 0;
        self.end_time = 0;
        self.index_offset = 0;
        self.num_max_events = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardingEvent {
    // message fields
    pub timestamp: u64,
    pub chan_id_in: u64,
    pub chan_id_out: u64,
    pub amt_in: u64,
    pub amt_out: u64,
    pub fee: u64,
    pub fee_msat: u64,
    pub amt_in_msat: u64,
    pub amt_out_msat: u64,
    pub timestamp_ns: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingEvent {
    fn default() -> &'a ForwardingEvent {
        <ForwardingEvent as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingEvent {
    pub fn new() -> ForwardingEvent {
        ::std::default::Default::default()
    }

    // uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // uint64 chan_id_in = 2;


    pub fn get_chan_id_in(&self) -> u64 {
        self.chan_id_in
    }
    pub fn clear_chan_id_in(&mut self) {
        self.chan_id_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id_in(&mut self, v: u64) {
        self.chan_id_in = v;
    }

    // uint64 chan_id_out = 4;


    pub fn get_chan_id_out(&self) -> u64 {
        self.chan_id_out
    }
    pub fn clear_chan_id_out(&mut self) {
        self.chan_id_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id_out(&mut self, v: u64) {
        self.chan_id_out = v;
    }

    // uint64 amt_in = 5;


    pub fn get_amt_in(&self) -> u64 {
        self.amt_in
    }
    pub fn clear_amt_in(&mut self) {
        self.amt_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_in(&mut self, v: u64) {
        self.amt_in = v;
    }

    // uint64 amt_out = 6;


    pub fn get_amt_out(&self) -> u64 {
        self.amt_out
    }
    pub fn clear_amt_out(&mut self) {
        self.amt_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_out(&mut self, v: u64) {
        self.amt_out = v;
    }

    // uint64 fee = 7;


    pub fn get_fee(&self) -> u64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = v;
    }

    // uint64 fee_msat = 8;


    pub fn get_fee_msat(&self) -> u64 {
        self.fee_msat
    }
    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: u64) {
        self.fee_msat = v;
    }

    // uint64 amt_in_msat = 9;


    pub fn get_amt_in_msat(&self) -> u64 {
        self.amt_in_msat
    }
    pub fn clear_amt_in_msat(&mut self) {
        self.amt_in_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_in_msat(&mut self, v: u64) {
        self.amt_in_msat = v;
    }

    // uint64 amt_out_msat = 10;


    pub fn get_amt_out_msat(&self) -> u64 {
        self.amt_out_msat
    }
    pub fn clear_amt_out_msat(&mut self) {
        self.amt_out_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_out_msat(&mut self, v: u64) {
        self.amt_out_msat = v;
    }

    // uint64 timestamp_ns = 11;


    pub fn get_timestamp_ns(&self) -> u64 {
        self.timestamp_ns
    }
    pub fn clear_timestamp_ns(&mut self) {
        self.timestamp_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_ns(&mut self, v: u64) {
        self.timestamp_ns = v;
    }
}

impl ::protobuf::Message for ForwardingEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id_in = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id_out = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_in = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_out = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee_msat = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_in_msat = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_out_msat = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_ns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_id_in != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_id_out != 0 {
            my_size += ::protobuf::rt::value_size(4, self.chan_id_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_in != 0 {
            my_size += ::protobuf::rt::value_size(5, self.amt_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_out != 0 {
            my_size += ::protobuf::rt::value_size(6, self.amt_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(8, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_in_msat != 0 {
            my_size += ::protobuf::rt::value_size(9, self.amt_in_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_out_msat != 0 {
            my_size += ::protobuf::rt::value_size(10, self.amt_out_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp_ns != 0 {
            my_size += ::protobuf::rt::value_size(11, self.timestamp_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        if self.chan_id_in != 0 {
            os.write_uint64(2, self.chan_id_in)?;
        }
        if self.chan_id_out != 0 {
            os.write_uint64(4, self.chan_id_out)?;
        }
        if self.amt_in != 0 {
            os.write_uint64(5, self.amt_in)?;
        }
        if self.amt_out != 0 {
            os.write_uint64(6, self.amt_out)?;
        }
        if self.fee != 0 {
            os.write_uint64(7, self.fee)?;
        }
        if self.fee_msat != 0 {
            os.write_uint64(8, self.fee_msat)?;
        }
        if self.amt_in_msat != 0 {
            os.write_uint64(9, self.amt_in_msat)?;
        }
        if self.amt_out_msat != 0 {
            os.write_uint64(10, self.amt_out_msat)?;
        }
        if self.timestamp_ns != 0 {
            os.write_uint64(11, self.timestamp_ns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingEvent {
        ForwardingEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &ForwardingEvent| { &m.timestamp },
                |m: &mut ForwardingEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id_in",
                |m: &ForwardingEvent| { &m.chan_id_in },
                |m: &mut ForwardingEvent| { &mut m.chan_id_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id_out",
                |m: &ForwardingEvent| { &m.chan_id_out },
                |m: &mut ForwardingEvent| { &mut m.chan_id_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amt_in",
                |m: &ForwardingEvent| { &m.amt_in },
                |m: &mut ForwardingEvent| { &mut m.amt_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amt_out",
                |m: &ForwardingEvent| { &m.amt_out },
                |m: &mut ForwardingEvent| { &mut m.amt_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee",
                |m: &ForwardingEvent| { &m.fee },
                |m: &mut ForwardingEvent| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee_msat",
                |m: &ForwardingEvent| { &m.fee_msat },
                |m: &mut ForwardingEvent| { &mut m.fee_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amt_in_msat",
                |m: &ForwardingEvent| { &m.amt_in_msat },
                |m: &mut ForwardingEvent| { &mut m.amt_in_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amt_out_msat",
                |m: &ForwardingEvent| { &m.amt_out_msat },
                |m: &mut ForwardingEvent| { &mut m.amt_out_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp_ns",
                |m: &ForwardingEvent| { &m.timestamp_ns },
                |m: &mut ForwardingEvent| { &mut m.timestamp_ns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardingEvent>(
                "ForwardingEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardingEvent {
        static instance: ::protobuf::rt::LazyV2<ForwardingEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardingEvent::new)
    }
}

impl ::protobuf::Clear for ForwardingEvent {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.chan_id_in = 0;
        self.chan_id_out = 0;
        self.amt_in = 0;
        self.amt_out = 0;
        self.fee = 0;
        self.fee_msat = 0;
        self.amt_in_msat = 0;
        self.amt_out_msat = 0;
        self.timestamp_ns = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ForwardingHistoryResponse {
    // message fields
    pub forwarding_events: ::protobuf::RepeatedField<ForwardingEvent>,
    pub last_offset_index: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingHistoryResponse {
    fn default() -> &'a ForwardingHistoryResponse {
        <ForwardingHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingHistoryResponse {
    pub fn new() -> ForwardingHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ForwardingEvent forwarding_events = 1;


    pub fn get_forwarding_events(&self) -> &[ForwardingEvent] {
        &self.forwarding_events
    }
    pub fn clear_forwarding_events(&mut self) {
        self.forwarding_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_forwarding_events(&mut self, v: ::protobuf::RepeatedField<ForwardingEvent>) {
        self.forwarding_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_forwarding_events(&mut self) -> &mut ::protobuf::RepeatedField<ForwardingEvent> {
        &mut self.forwarding_events
    }

    // Take field
    pub fn take_forwarding_events(&mut self) -> ::protobuf::RepeatedField<ForwardingEvent> {
        ::std::mem::replace(&mut self.forwarding_events, ::protobuf::RepeatedField::new())
    }

    // uint32 last_offset_index = 2;


    pub fn get_last_offset_index(&self) -> u32 {
        self.last_offset_index
    }
    pub fn clear_last_offset_index(&mut self) {
        self.last_offset_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_offset_index(&mut self, v: u32) {
        self.last_offset_index = v;
    }
}

impl ::protobuf::Message for ForwardingHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.forwarding_events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.forwarding_events)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_offset_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.forwarding_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_offset_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_offset_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.forwarding_events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_offset_index != 0 {
            os.write_uint32(2, self.last_offset_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingHistoryResponse {
        ForwardingHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForwardingEvent>>(
                "forwarding_events",
                |m: &ForwardingHistoryResponse| { &m.forwarding_events },
                |m: &mut ForwardingHistoryResponse| { &mut m.forwarding_events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_offset_index",
                |m: &ForwardingHistoryResponse| { &m.last_offset_index },
                |m: &mut ForwardingHistoryResponse| { &mut m.last_offset_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardingHistoryResponse>(
                "ForwardingHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardingHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<ForwardingHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardingHistoryResponse::new)
    }
}

impl ::protobuf::Clear for ForwardingHistoryResponse {
    fn clear(&mut self) {
        self.forwarding_events.clear();
        self.last_offset_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExportChannelBackupRequest {
    // message fields
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportChannelBackupRequest {
    fn default() -> &'a ExportChannelBackupRequest {
        <ExportChannelBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExportChannelBackupRequest {
    pub fn new() -> ExportChannelBackupRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint chan_point = 1;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for ExportChannelBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportChannelBackupRequest {
        ExportChannelBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "chan_point",
                |m: &ExportChannelBackupRequest| { &m.chan_point },
                |m: &mut ExportChannelBackupRequest| { &mut m.chan_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExportChannelBackupRequest>(
                "ExportChannelBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExportChannelBackupRequest {
        static instance: ::protobuf::rt::LazyV2<ExportChannelBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExportChannelBackupRequest::new)
    }
}

impl ::protobuf::Clear for ExportChannelBackupRequest {
    fn clear(&mut self) {
        self.chan_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportChannelBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportChannelBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelBackup {
    // message fields
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub chan_backup: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBackup {
    fn default() -> &'a ChannelBackup {
        <ChannelBackup as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBackup {
    pub fn new() -> ChannelBackup {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint chan_point = 1;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| <ChannelPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // bytes chan_backup = 2;


    pub fn get_chan_backup(&self) -> &[u8] {
        &self.chan_backup
    }
    pub fn clear_chan_backup(&mut self) {
        self.chan_backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_backup(&mut self, v: ::std::vec::Vec<u8>) {
        self.chan_backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.chan_backup
    }

    // Take field
    pub fn take_chan_backup(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.chan_backup, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChannelBackup {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.chan_backup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.chan_backup.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.chan_backup);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.chan_backup.is_empty() {
            os.write_bytes(2, &self.chan_backup)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBackup {
        ChannelBackup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "chan_point",
                |m: &ChannelBackup| { &m.chan_point },
                |m: &mut ChannelBackup| { &mut m.chan_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chan_backup",
                |m: &ChannelBackup| { &m.chan_backup },
                |m: &mut ChannelBackup| { &mut m.chan_backup },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelBackup>(
                "ChannelBackup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelBackup {
        static instance: ::protobuf::rt::LazyV2<ChannelBackup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelBackup::new)
    }
}

impl ::protobuf::Clear for ChannelBackup {
    fn clear(&mut self) {
        self.chan_point.clear();
        self.chan_backup.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBackup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBackup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MultiChanBackup {
    // message fields
    pub chan_points: ::protobuf::RepeatedField<ChannelPoint>,
    pub multi_chan_backup: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiChanBackup {
    fn default() -> &'a MultiChanBackup {
        <MultiChanBackup as ::protobuf::Message>::default_instance()
    }
}

impl MultiChanBackup {
    pub fn new() -> MultiChanBackup {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelPoint chan_points = 1;


    pub fn get_chan_points(&self) -> &[ChannelPoint] {
        &self.chan_points
    }
    pub fn clear_chan_points(&mut self) {
        self.chan_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_points(&mut self, v: ::protobuf::RepeatedField<ChannelPoint>) {
        self.chan_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chan_points(&mut self) -> &mut ::protobuf::RepeatedField<ChannelPoint> {
        &mut self.chan_points
    }

    // Take field
    pub fn take_chan_points(&mut self) -> ::protobuf::RepeatedField<ChannelPoint> {
        ::std::mem::replace(&mut self.chan_points, ::protobuf::RepeatedField::new())
    }

    // bytes multi_chan_backup = 2;


    pub fn get_multi_chan_backup(&self) -> &[u8] {
        &self.multi_chan_backup
    }
    pub fn clear_multi_chan_backup(&mut self) {
        self.multi_chan_backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_multi_chan_backup(&mut self, v: ::std::vec::Vec<u8>) {
        self.multi_chan_backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multi_chan_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.multi_chan_backup
    }

    // Take field
    pub fn take_multi_chan_backup(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.multi_chan_backup, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MultiChanBackup {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chan_points)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.multi_chan_backup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chan_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.multi_chan_backup.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.multi_chan_backup);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chan_points {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.multi_chan_backup.is_empty() {
            os.write_bytes(2, &self.multi_chan_backup)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiChanBackup {
        MultiChanBackup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                "chan_points",
                |m: &MultiChanBackup| { &m.chan_points },
                |m: &mut MultiChanBackup| { &mut m.chan_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "multi_chan_backup",
                |m: &MultiChanBackup| { &m.multi_chan_backup },
                |m: &mut MultiChanBackup| { &mut m.multi_chan_backup },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiChanBackup>(
                "MultiChanBackup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiChanBackup {
        static instance: ::protobuf::rt::LazyV2<MultiChanBackup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiChanBackup::new)
    }
}

impl ::protobuf::Clear for MultiChanBackup {
    fn clear(&mut self) {
        self.chan_points.clear();
        self.multi_chan_backup.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiChanBackup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiChanBackup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChanBackupExportRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanBackupExportRequest {
    fn default() -> &'a ChanBackupExportRequest {
        <ChanBackupExportRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChanBackupExportRequest {
    pub fn new() -> ChanBackupExportRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChanBackupExportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanBackupExportRequest {
        ChanBackupExportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChanBackupExportRequest>(
                "ChanBackupExportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChanBackupExportRequest {
        static instance: ::protobuf::rt::LazyV2<ChanBackupExportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChanBackupExportRequest::new)
    }
}

impl ::protobuf::Clear for ChanBackupExportRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanBackupExportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanBackupExportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChanBackupSnapshot {
    // message fields
    pub single_chan_backups: ::protobuf::SingularPtrField<ChannelBackups>,
    pub multi_chan_backup: ::protobuf::SingularPtrField<MultiChanBackup>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanBackupSnapshot {
    fn default() -> &'a ChanBackupSnapshot {
        <ChanBackupSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl ChanBackupSnapshot {
    pub fn new() -> ChanBackupSnapshot {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelBackups single_chan_backups = 1;


    pub fn get_single_chan_backups(&self) -> &ChannelBackups {
        self.single_chan_backups.as_ref().unwrap_or_else(|| <ChannelBackups as ::protobuf::Message>::default_instance())
    }
    pub fn clear_single_chan_backups(&mut self) {
        self.single_chan_backups.clear();
    }

    pub fn has_single_chan_backups(&self) -> bool {
        self.single_chan_backups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_single_chan_backups(&mut self, v: ChannelBackups) {
        self.single_chan_backups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_single_chan_backups(&mut self) -> &mut ChannelBackups {
        if self.single_chan_backups.is_none() {
            self.single_chan_backups.set_default();
        }
        self.single_chan_backups.as_mut().unwrap()
    }

    // Take field
    pub fn take_single_chan_backups(&mut self) -> ChannelBackups {
        self.single_chan_backups.take().unwrap_or_else(|| ChannelBackups::new())
    }

    // .lnrpc.MultiChanBackup multi_chan_backup = 2;


    pub fn get_multi_chan_backup(&self) -> &MultiChanBackup {
        self.multi_chan_backup.as_ref().unwrap_or_else(|| <MultiChanBackup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multi_chan_backup(&mut self) {
        self.multi_chan_backup.clear();
    }

    pub fn has_multi_chan_backup(&self) -> bool {
        self.multi_chan_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multi_chan_backup(&mut self, v: MultiChanBackup) {
        self.multi_chan_backup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multi_chan_backup(&mut self) -> &mut MultiChanBackup {
        if self.multi_chan_backup.is_none() {
            self.multi_chan_backup.set_default();
        }
        self.multi_chan_backup.as_mut().unwrap()
    }

    // Take field
    pub fn take_multi_chan_backup(&mut self) -> MultiChanBackup {
        self.multi_chan_backup.take().unwrap_or_else(|| MultiChanBackup::new())
    }
}

impl ::protobuf::Message for ChanBackupSnapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.single_chan_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_chan_backup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.single_chan_backups)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multi_chan_backup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.single_chan_backups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.multi_chan_backup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.single_chan_backups.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.multi_chan_backup.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanBackupSnapshot {
        ChanBackupSnapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelBackups>>(
                "single_chan_backups",
                |m: &ChanBackupSnapshot| { &m.single_chan_backups },
                |m: &mut ChanBackupSnapshot| { &mut m.single_chan_backups },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MultiChanBackup>>(
                "multi_chan_backup",
                |m: &ChanBackupSnapshot| { &m.multi_chan_backup },
                |m: &mut ChanBackupSnapshot| { &mut m.multi_chan_backup },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChanBackupSnapshot>(
                "ChanBackupSnapshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChanBackupSnapshot {
        static instance: ::protobuf::rt::LazyV2<ChanBackupSnapshot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChanBackupSnapshot::new)
    }
}

impl ::protobuf::Clear for ChanBackupSnapshot {
    fn clear(&mut self) {
        self.single_chan_backups.clear();
        self.multi_chan_backup.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanBackupSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanBackupSnapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelBackups {
    // message fields
    pub chan_backups: ::protobuf::RepeatedField<ChannelBackup>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBackups {
    fn default() -> &'a ChannelBackups {
        <ChannelBackups as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBackups {
    pub fn new() -> ChannelBackups {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelBackup chan_backups = 1;


    pub fn get_chan_backups(&self) -> &[ChannelBackup] {
        &self.chan_backups
    }
    pub fn clear_chan_backups(&mut self) {
        self.chan_backups.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_backups(&mut self, v: ::protobuf::RepeatedField<ChannelBackup>) {
        self.chan_backups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chan_backups(&mut self) -> &mut ::protobuf::RepeatedField<ChannelBackup> {
        &mut self.chan_backups
    }

    // Take field
    pub fn take_chan_backups(&mut self) -> ::protobuf::RepeatedField<ChannelBackup> {
        ::std::mem::replace(&mut self.chan_backups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelBackups {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chan_backups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chan_backups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chan_backups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBackups {
        ChannelBackups::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelBackup>>(
                "chan_backups",
                |m: &ChannelBackups| { &m.chan_backups },
                |m: &mut ChannelBackups| { &mut m.chan_backups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelBackups>(
                "ChannelBackups",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelBackups {
        static instance: ::protobuf::rt::LazyV2<ChannelBackups> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelBackups::new)
    }
}

impl ::protobuf::Clear for ChannelBackups {
    fn clear(&mut self) {
        self.chan_backups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBackups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBackups {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RestoreChanBackupRequest {
    // message oneof groups
    pub backup: ::std::option::Option<RestoreChanBackupRequest_oneof_backup>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreChanBackupRequest {
    fn default() -> &'a RestoreChanBackupRequest {
        <RestoreChanBackupRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RestoreChanBackupRequest_oneof_backup {
    chan_backups(ChannelBackups),
    multi_chan_backup(::std::vec::Vec<u8>),
}

impl RestoreChanBackupRequest {
    pub fn new() -> RestoreChanBackupRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelBackups chan_backups = 1;


    pub fn get_chan_backups(&self) -> &ChannelBackups {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ref v)) => v,
            _ => <ChannelBackups as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chan_backups(&mut self) {
        self.backup = ::std::option::Option::None;
    }

    pub fn has_chan_backups(&self) -> bool {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_backups(&mut self, v: ChannelBackups) {
        self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_backups(&mut self) -> &mut ChannelBackups {
        if let ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(_)) = self.backup {
        } else {
            self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ChannelBackups::new()));
        }
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_backups(&mut self) -> ChannelBackups {
        if self.has_chan_backups() {
            match self.backup.take() {
                ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelBackups::new()
        }
    }

    // bytes multi_chan_backup = 2;


    pub fn get_multi_chan_backup(&self) -> &[u8] {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_multi_chan_backup(&mut self) {
        self.backup = ::std::option::Option::None;
    }

    pub fn has_multi_chan_backup(&self) -> bool {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_chan_backup(&mut self, v: ::std::vec::Vec<u8>) {
        self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_chan_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(_)) = self.backup {
        } else {
            self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(::std::vec::Vec::new()));
        }
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_chan_backup(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_multi_chan_backup() {
            match self.backup.take() {
                ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for RestoreChanBackupRequest {
    fn is_initialized(&self) -> bool {
        if let Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ref v)) = self.backup {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.backup {
            match v {
                &RestoreChanBackupRequest_oneof_backup::chan_backups(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.backup {
            match v {
                &RestoreChanBackupRequest_oneof_backup::chan_backups(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreChanBackupRequest {
        RestoreChanBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelBackups>(
                "chan_backups",
                RestoreChanBackupRequest::has_chan_backups,
                RestoreChanBackupRequest::get_chan_backups,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "multi_chan_backup",
                RestoreChanBackupRequest::has_multi_chan_backup,
                RestoreChanBackupRequest::get_multi_chan_backup,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreChanBackupRequest>(
                "RestoreChanBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreChanBackupRequest {
        static instance: ::protobuf::rt::LazyV2<RestoreChanBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreChanBackupRequest::new)
    }
}

impl ::protobuf::Clear for RestoreChanBackupRequest {
    fn clear(&mut self) {
        self.backup = ::std::option::Option::None;
        self.backup = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreChanBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreChanBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RestoreBackupResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreBackupResponse {
    fn default() -> &'a RestoreBackupResponse {
        <RestoreBackupResponse as ::protobuf::Message>::default_instance()
    }
}

impl RestoreBackupResponse {
    pub fn new() -> RestoreBackupResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RestoreBackupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreBackupResponse {
        RestoreBackupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreBackupResponse>(
                "RestoreBackupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreBackupResponse {
        static instance: ::protobuf::rt::LazyV2<RestoreBackupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreBackupResponse::new)
    }
}

impl ::protobuf::Clear for RestoreBackupResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreBackupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreBackupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelBackupSubscription {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBackupSubscription {
    fn default() -> &'a ChannelBackupSubscription {
        <ChannelBackupSubscription as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBackupSubscription {
    pub fn new() -> ChannelBackupSubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelBackupSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBackupSubscription {
        ChannelBackupSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelBackupSubscription>(
                "ChannelBackupSubscription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelBackupSubscription {
        static instance: ::protobuf::rt::LazyV2<ChannelBackupSubscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelBackupSubscription::new)
    }
}

impl ::protobuf::Clear for ChannelBackupSubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBackupSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBackupSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VerifyChanBackupResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyChanBackupResponse {
    fn default() -> &'a VerifyChanBackupResponse {
        <VerifyChanBackupResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyChanBackupResponse {
    pub fn new() -> VerifyChanBackupResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VerifyChanBackupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyChanBackupResponse {
        VerifyChanBackupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyChanBackupResponse>(
                "VerifyChanBackupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyChanBackupResponse {
        static instance: ::protobuf::rt::LazyV2<VerifyChanBackupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyChanBackupResponse::new)
    }
}

impl ::protobuf::Clear for VerifyChanBackupResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyChanBackupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyChanBackupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MacaroonPermission {
    // message fields
    pub entity: ::std::string::String,
    pub action: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MacaroonPermission {
    fn default() -> &'a MacaroonPermission {
        <MacaroonPermission as ::protobuf::Message>::default_instance()
    }
}

impl MacaroonPermission {
    pub fn new() -> MacaroonPermission {
        ::std::default::Default::default()
    }

    // string entity = 1;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string action = 2;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MacaroonPermission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity.is_empty() {
            os.write_string(1, &self.entity)?;
        }
        if !self.action.is_empty() {
            os.write_string(2, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MacaroonPermission {
        MacaroonPermission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &MacaroonPermission| { &m.entity },
                |m: &mut MacaroonPermission| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &MacaroonPermission| { &m.action },
                |m: &mut MacaroonPermission| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MacaroonPermission>(
                "MacaroonPermission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MacaroonPermission {
        static instance: ::protobuf::rt::LazyV2<MacaroonPermission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MacaroonPermission::new)
    }
}

impl ::protobuf::Clear for MacaroonPermission {
    fn clear(&mut self) {
        self.entity.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MacaroonPermission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MacaroonPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BakeMacaroonRequest {
    // message fields
    pub permissions: ::protobuf::RepeatedField<MacaroonPermission>,
    pub root_key_id: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BakeMacaroonRequest {
    fn default() -> &'a BakeMacaroonRequest {
        <BakeMacaroonRequest as ::protobuf::Message>::default_instance()
    }
}

impl BakeMacaroonRequest {
    pub fn new() -> BakeMacaroonRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.MacaroonPermission permissions = 1;


    pub fn get_permissions(&self) -> &[MacaroonPermission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<MacaroonPermission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<MacaroonPermission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<MacaroonPermission> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }

    // uint64 root_key_id = 2;


    pub fn get_root_key_id(&self) -> u64 {
        self.root_key_id
    }
    pub fn clear_root_key_id(&mut self) {
        self.root_key_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_root_key_id(&mut self, v: u64) {
        self.root_key_id = v;
    }
}

impl ::protobuf::Message for BakeMacaroonRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.permissions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permissions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.root_key_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.root_key_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.root_key_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.permissions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.root_key_id != 0 {
            os.write_uint64(2, self.root_key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BakeMacaroonRequest {
        BakeMacaroonRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MacaroonPermission>>(
                "permissions",
                |m: &BakeMacaroonRequest| { &m.permissions },
                |m: &mut BakeMacaroonRequest| { &mut m.permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "root_key_id",
                |m: &BakeMacaroonRequest| { &m.root_key_id },
                |m: &mut BakeMacaroonRequest| { &mut m.root_key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BakeMacaroonRequest>(
                "BakeMacaroonRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BakeMacaroonRequest {
        static instance: ::protobuf::rt::LazyV2<BakeMacaroonRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BakeMacaroonRequest::new)
    }
}

impl ::protobuf::Clear for BakeMacaroonRequest {
    fn clear(&mut self) {
        self.permissions.clear();
        self.root_key_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BakeMacaroonRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BakeMacaroonRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BakeMacaroonResponse {
    // message fields
    pub macaroon: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BakeMacaroonResponse {
    fn default() -> &'a BakeMacaroonResponse {
        <BakeMacaroonResponse as ::protobuf::Message>::default_instance()
    }
}

impl BakeMacaroonResponse {
    pub fn new() -> BakeMacaroonResponse {
        ::std::default::Default::default()
    }

    // string macaroon = 1;


    pub fn get_macaroon(&self) -> &str {
        &self.macaroon
    }
    pub fn clear_macaroon(&mut self) {
        self.macaroon.clear();
    }

    // Param is passed by value, moved
    pub fn set_macaroon(&mut self, v: ::std::string::String) {
        self.macaroon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_macaroon(&mut self) -> &mut ::std::string::String {
        &mut self.macaroon
    }

    // Take field
    pub fn take_macaroon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.macaroon, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BakeMacaroonResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.macaroon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.macaroon.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.macaroon);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.macaroon.is_empty() {
            os.write_string(1, &self.macaroon)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BakeMacaroonResponse {
        BakeMacaroonResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "macaroon",
                |m: &BakeMacaroonResponse| { &m.macaroon },
                |m: &mut BakeMacaroonResponse| { &mut m.macaroon },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BakeMacaroonResponse>(
                "BakeMacaroonResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BakeMacaroonResponse {
        static instance: ::protobuf::rt::LazyV2<BakeMacaroonResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BakeMacaroonResponse::new)
    }
}

impl ::protobuf::Clear for BakeMacaroonResponse {
    fn clear(&mut self) {
        self.macaroon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BakeMacaroonResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BakeMacaroonResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListMacaroonIDsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMacaroonIDsRequest {
    fn default() -> &'a ListMacaroonIDsRequest {
        <ListMacaroonIDsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListMacaroonIDsRequest {
    pub fn new() -> ListMacaroonIDsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListMacaroonIDsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMacaroonIDsRequest {
        ListMacaroonIDsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMacaroonIDsRequest>(
                "ListMacaroonIDsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListMacaroonIDsRequest {
        static instance: ::protobuf::rt::LazyV2<ListMacaroonIDsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMacaroonIDsRequest::new)
    }
}

impl ::protobuf::Clear for ListMacaroonIDsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMacaroonIDsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMacaroonIDsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListMacaroonIDsResponse {
    // message fields
    pub root_key_ids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMacaroonIDsResponse {
    fn default() -> &'a ListMacaroonIDsResponse {
        <ListMacaroonIDsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListMacaroonIDsResponse {
    pub fn new() -> ListMacaroonIDsResponse {
        ::std::default::Default::default()
    }

    // repeated uint64 root_key_ids = 1;


    pub fn get_root_key_ids(&self) -> &[u64] {
        &self.root_key_ids
    }
    pub fn clear_root_key_ids(&mut self) {
        self.root_key_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_root_key_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.root_key_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_root_key_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.root_key_ids
    }

    // Take field
    pub fn take_root_key_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.root_key_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListMacaroonIDsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.root_key_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.root_key_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.root_key_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMacaroonIDsResponse {
        ListMacaroonIDsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "root_key_ids",
                |m: &ListMacaroonIDsResponse| { &m.root_key_ids },
                |m: &mut ListMacaroonIDsResponse| { &mut m.root_key_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMacaroonIDsResponse>(
                "ListMacaroonIDsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListMacaroonIDsResponse {
        static instance: ::protobuf::rt::LazyV2<ListMacaroonIDsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMacaroonIDsResponse::new)
    }
}

impl ::protobuf::Clear for ListMacaroonIDsResponse {
    fn clear(&mut self) {
        self.root_key_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMacaroonIDsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMacaroonIDsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeleteMacaroonIDRequest {
    // message fields
    pub root_key_id: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteMacaroonIDRequest {
    fn default() -> &'a DeleteMacaroonIDRequest {
        <DeleteMacaroonIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMacaroonIDRequest {
    pub fn new() -> DeleteMacaroonIDRequest {
        ::std::default::Default::default()
    }

    // uint64 root_key_id = 1;


    pub fn get_root_key_id(&self) -> u64 {
        self.root_key_id
    }
    pub fn clear_root_key_id(&mut self) {
        self.root_key_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_root_key_id(&mut self, v: u64) {
        self.root_key_id = v;
    }
}

impl ::protobuf::Message for DeleteMacaroonIDRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.root_key_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.root_key_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.root_key_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.root_key_id != 0 {
            os.write_uint64(1, self.root_key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteMacaroonIDRequest {
        DeleteMacaroonIDRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "root_key_id",
                |m: &DeleteMacaroonIDRequest| { &m.root_key_id },
                |m: &mut DeleteMacaroonIDRequest| { &mut m.root_key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteMacaroonIDRequest>(
                "DeleteMacaroonIDRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteMacaroonIDRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteMacaroonIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteMacaroonIDRequest::new)
    }
}

impl ::protobuf::Clear for DeleteMacaroonIDRequest {
    fn clear(&mut self) {
        self.root_key_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteMacaroonIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMacaroonIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeleteMacaroonIDResponse {
    // message fields
    pub deleted: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteMacaroonIDResponse {
    fn default() -> &'a DeleteMacaroonIDResponse {
        <DeleteMacaroonIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMacaroonIDResponse {
    pub fn new() -> DeleteMacaroonIDResponse {
        ::std::default::Default::default()
    }

    // bool deleted = 1;


    pub fn get_deleted(&self) -> bool {
        self.deleted
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = false;
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = v;
    }
}

impl ::protobuf::Message for DeleteMacaroonIDResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.deleted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.deleted != false {
            os.write_bool(1, self.deleted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteMacaroonIDResponse {
        DeleteMacaroonIDResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &DeleteMacaroonIDResponse| { &m.deleted },
                |m: &mut DeleteMacaroonIDResponse| { &mut m.deleted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteMacaroonIDResponse>(
                "DeleteMacaroonIDResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteMacaroonIDResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteMacaroonIDResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteMacaroonIDResponse::new)
    }
}

impl ::protobuf::Clear for DeleteMacaroonIDResponse {
    fn clear(&mut self) {
        self.deleted = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteMacaroonIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMacaroonIDResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MacaroonPermissionList {
    // message fields
    pub permissions: ::protobuf::RepeatedField<MacaroonPermission>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MacaroonPermissionList {
    fn default() -> &'a MacaroonPermissionList {
        <MacaroonPermissionList as ::protobuf::Message>::default_instance()
    }
}

impl MacaroonPermissionList {
    pub fn new() -> MacaroonPermissionList {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.MacaroonPermission permissions = 1;


    pub fn get_permissions(&self) -> &[MacaroonPermission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<MacaroonPermission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<MacaroonPermission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<MacaroonPermission> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MacaroonPermissionList {
    fn is_initialized(&self) -> bool {
        for v in &self.permissions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.permissions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MacaroonPermissionList {
        MacaroonPermissionList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MacaroonPermission>>(
                "permissions",
                |m: &MacaroonPermissionList| { &m.permissions },
                |m: &mut MacaroonPermissionList| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MacaroonPermissionList>(
                "MacaroonPermissionList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MacaroonPermissionList {
        static instance: ::protobuf::rt::LazyV2<MacaroonPermissionList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MacaroonPermissionList::new)
    }
}

impl ::protobuf::Clear for MacaroonPermissionList {
    fn clear(&mut self) {
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MacaroonPermissionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MacaroonPermissionList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListPermissionsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPermissionsRequest {
    fn default() -> &'a ListPermissionsRequest {
        <ListPermissionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPermissionsRequest {
    pub fn new() -> ListPermissionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListPermissionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPermissionsRequest {
        ListPermissionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPermissionsRequest>(
                "ListPermissionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPermissionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListPermissionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPermissionsRequest::new)
    }
}

impl ::protobuf::Clear for ListPermissionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPermissionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPermissionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListPermissionsResponse {
    // message fields
    pub method_permissions: ::std::collections::HashMap<::std::string::String, MacaroonPermissionList>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPermissionsResponse {
    fn default() -> &'a ListPermissionsResponse {
        <ListPermissionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPermissionsResponse {
    pub fn new() -> ListPermissionsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ListPermissionsResponse.MethodPermissionsEntry method_permissions = 1;


    pub fn get_method_permissions(&self) -> &::std::collections::HashMap<::std::string::String, MacaroonPermissionList> {
        &self.method_permissions
    }
    pub fn clear_method_permissions(&mut self) {
        self.method_permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_method_permissions(&mut self, v: ::std::collections::HashMap<::std::string::String, MacaroonPermissionList>) {
        self.method_permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_method_permissions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, MacaroonPermissionList> {
        &mut self.method_permissions
    }

    // Take field
    pub fn take_method_permissions(&mut self) -> ::std::collections::HashMap<::std::string::String, MacaroonPermissionList> {
        ::std::mem::replace(&mut self.method_permissions, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ListPermissionsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MacaroonPermissionList>>(wire_type, is, &mut self.method_permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MacaroonPermissionList>>(1, &self.method_permissions);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MacaroonPermissionList>>(1, &self.method_permissions, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPermissionsResponse {
        ListPermissionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MacaroonPermissionList>>(
                "method_permissions",
                |m: &ListPermissionsResponse| { &m.method_permissions },
                |m: &mut ListPermissionsResponse| { &mut m.method_permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPermissionsResponse>(
                "ListPermissionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPermissionsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPermissionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPermissionsResponse::new)
    }
}

impl ::protobuf::Clear for ListPermissionsResponse {
    fn clear(&mut self) {
        self.method_permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPermissionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPermissionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Failure {
    // message fields
    pub code: Failure_FailureCode,
    pub channel_update: ::protobuf::SingularPtrField<ChannelUpdate>,
    pub htlc_msat: u64,
    pub onion_sha_256: ::std::vec::Vec<u8>,
    pub cltv_expiry: u32,
    pub flags: u32,
    pub failure_source_index: u32,
    pub height: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Failure {
    fn default() -> &'a Failure {
        <Failure as ::protobuf::Message>::default_instance()
    }
}

impl Failure {
    pub fn new() -> Failure {
        ::std::default::Default::default()
    }

    // .lnrpc.Failure.FailureCode code = 1;


    pub fn get_code(&self) -> Failure_FailureCode {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = Failure_FailureCode::RESERVED;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Failure_FailureCode) {
        self.code = v;
    }

    // .lnrpc.ChannelUpdate channel_update = 3;


    pub fn get_channel_update(&self) -> &ChannelUpdate {
        self.channel_update.as_ref().unwrap_or_else(|| <ChannelUpdate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel_update(&mut self) {
        self.channel_update.clear();
    }

    pub fn has_channel_update(&self) -> bool {
        self.channel_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_update(&mut self, v: ChannelUpdate) {
        self.channel_update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_update(&mut self) -> &mut ChannelUpdate {
        if self.channel_update.is_none() {
            self.channel_update.set_default();
        }
        self.channel_update.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_update(&mut self) -> ChannelUpdate {
        self.channel_update.take().unwrap_or_else(|| ChannelUpdate::new())
    }

    // uint64 htlc_msat = 4;


    pub fn get_htlc_msat(&self) -> u64 {
        self.htlc_msat
    }
    pub fn clear_htlc_msat(&mut self) {
        self.htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_msat(&mut self, v: u64) {
        self.htlc_msat = v;
    }

    // bytes onion_sha_256 = 5;


    pub fn get_onion_sha_256(&self) -> &[u8] {
        &self.onion_sha_256
    }
    pub fn clear_onion_sha_256(&mut self) {
        self.onion_sha_256.clear();
    }

    // Param is passed by value, moved
    pub fn set_onion_sha_256(&mut self, v: ::std::vec::Vec<u8>) {
        self.onion_sha_256 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onion_sha_256(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.onion_sha_256
    }

    // Take field
    pub fn take_onion_sha_256(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.onion_sha_256, ::std::vec::Vec::new())
    }

    // uint32 cltv_expiry = 6;


    pub fn get_cltv_expiry(&self) -> u32 {
        self.cltv_expiry
    }
    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: u32) {
        self.cltv_expiry = v;
    }

    // uint32 flags = 7;


    pub fn get_flags(&self) -> u32 {
        self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = v;
    }

    // uint32 failure_source_index = 8;


    pub fn get_failure_source_index(&self) -> u32 {
        self.failure_source_index
    }
    pub fn clear_failure_source_index(&mut self) {
        self.failure_source_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_failure_source_index(&mut self, v: u32) {
        self.failure_source_index = v;
    }

    // uint32 height = 9;


    pub fn get_height(&self) -> u32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = v;
    }
}

impl ::protobuf::Message for Failure {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_update)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_msat = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.onion_sha_256)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_expiry = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.failure_source_index = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != Failure_FailureCode::RESERVED {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if let Some(ref v) = self.channel_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.onion_sha_256.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.onion_sha_256);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(6, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::value_size(7, self.flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failure_source_index != 0 {
            my_size += ::protobuf::rt::value_size(8, self.failure_source_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(9, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != Failure_FailureCode::RESERVED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if let Some(ref v) = self.channel_update.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.htlc_msat != 0 {
            os.write_uint64(4, self.htlc_msat)?;
        }
        if !self.onion_sha_256.is_empty() {
            os.write_bytes(5, &self.onion_sha_256)?;
        }
        if self.cltv_expiry != 0 {
            os.write_uint32(6, self.cltv_expiry)?;
        }
        if self.flags != 0 {
            os.write_uint32(7, self.flags)?;
        }
        if self.failure_source_index != 0 {
            os.write_uint32(8, self.failure_source_index)?;
        }
        if self.height != 0 {
            os.write_uint32(9, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Failure {
        Failure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Failure_FailureCode>>(
                "code",
                |m: &Failure| { &m.code },
                |m: &mut Failure| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelUpdate>>(
                "channel_update",
                |m: &Failure| { &m.channel_update },
                |m: &mut Failure| { &mut m.channel_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "htlc_msat",
                |m: &Failure| { &m.htlc_msat },
                |m: &mut Failure| { &mut m.htlc_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "onion_sha_256",
                |m: &Failure| { &m.onion_sha_256 },
                |m: &mut Failure| { &mut m.onion_sha_256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cltv_expiry",
                |m: &Failure| { &m.cltv_expiry },
                |m: &mut Failure| { &mut m.cltv_expiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &Failure| { &m.flags },
                |m: &mut Failure| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "failure_source_index",
                |m: &Failure| { &m.failure_source_index },
                |m: &mut Failure| { &mut m.failure_source_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &Failure| { &m.height },
                |m: &mut Failure| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Failure>(
                "Failure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Failure {
        static instance: ::protobuf::rt::LazyV2<Failure> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Failure::new)
    }
}

impl ::protobuf::Clear for Failure {
    fn clear(&mut self) {
        self.code = Failure_FailureCode::RESERVED;
        self.channel_update.clear();
        self.htlc_msat = 0;
        self.onion_sha_256.clear();
        self.cltv_expiry = 0;
        self.flags = 0;
        self.failure_source_index = 0;
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Failure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Failure_FailureCode {
    RESERVED = 0,
    INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1,
    INCORRECT_PAYMENT_AMOUNT = 2,
    FINAL_INCORRECT_CLTV_EXPIRY = 3,
    FINAL_INCORRECT_HTLC_AMOUNT = 4,
    FINAL_EXPIRY_TOO_SOON = 5,
    INVALID_REALM = 6,
    EXPIRY_TOO_SOON = 7,
    INVALID_ONION_VERSION = 8,
    INVALID_ONION_HMAC = 9,
    INVALID_ONION_KEY = 10,
    AMOUNT_BELOW_MINIMUM = 11,
    FEE_INSUFFICIENT = 12,
    INCORRECT_CLTV_EXPIRY = 13,
    CHANNEL_DISABLED = 14,
    TEMPORARY_CHANNEL_FAILURE = 15,
    REQUIRED_NODE_FEATURE_MISSING = 16,
    REQUIRED_CHANNEL_FEATURE_MISSING = 17,
    UNKNOWN_NEXT_PEER = 18,
    TEMPORARY_NODE_FAILURE = 19,
    PERMANENT_NODE_FAILURE = 20,
    PERMANENT_CHANNEL_FAILURE = 21,
    EXPIRY_TOO_FAR = 22,
    MPP_TIMEOUT = 23,
    INVALID_ONION_PAYLOAD = 24,
    INTERNAL_FAILURE = 997,
    UNKNOWN_FAILURE = 998,
    UNREADABLE_FAILURE = 999,
}

impl ::protobuf::ProtobufEnum for Failure_FailureCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Failure_FailureCode> {
        match value {
            0 => ::std::option::Option::Some(Failure_FailureCode::RESERVED),
            1 => ::std::option::Option::Some(Failure_FailureCode::INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS),
            2 => ::std::option::Option::Some(Failure_FailureCode::INCORRECT_PAYMENT_AMOUNT),
            3 => ::std::option::Option::Some(Failure_FailureCode::FINAL_INCORRECT_CLTV_EXPIRY),
            4 => ::std::option::Option::Some(Failure_FailureCode::FINAL_INCORRECT_HTLC_AMOUNT),
            5 => ::std::option::Option::Some(Failure_FailureCode::FINAL_EXPIRY_TOO_SOON),
            6 => ::std::option::Option::Some(Failure_FailureCode::INVALID_REALM),
            7 => ::std::option::Option::Some(Failure_FailureCode::EXPIRY_TOO_SOON),
            8 => ::std::option::Option::Some(Failure_FailureCode::INVALID_ONION_VERSION),
            9 => ::std::option::Option::Some(Failure_FailureCode::INVALID_ONION_HMAC),
            10 => ::std::option::Option::Some(Failure_FailureCode::INVALID_ONION_KEY),
            11 => ::std::option::Option::Some(Failure_FailureCode::AMOUNT_BELOW_MINIMUM),
            12 => ::std::option::Option::Some(Failure_FailureCode::FEE_INSUFFICIENT),
            13 => ::std::option::Option::Some(Failure_FailureCode::INCORRECT_CLTV_EXPIRY),
            14 => ::std::option::Option::Some(Failure_FailureCode::CHANNEL_DISABLED),
            15 => ::std::option::Option::Some(Failure_FailureCode::TEMPORARY_CHANNEL_FAILURE),
            16 => ::std::option::Option::Some(Failure_FailureCode::REQUIRED_NODE_FEATURE_MISSING),
            17 => ::std::option::Option::Some(Failure_FailureCode::REQUIRED_CHANNEL_FEATURE_MISSING),
            18 => ::std::option::Option::Some(Failure_FailureCode::UNKNOWN_NEXT_PEER),
            19 => ::std::option::Option::Some(Failure_FailureCode::TEMPORARY_NODE_FAILURE),
            20 => ::std::option::Option::Some(Failure_FailureCode::PERMANENT_NODE_FAILURE),
            21 => ::std::option::Option::Some(Failure_FailureCode::PERMANENT_CHANNEL_FAILURE),
            22 => ::std::option::Option::Some(Failure_FailureCode::EXPIRY_TOO_FAR),
            23 => ::std::option::Option::Some(Failure_FailureCode::MPP_TIMEOUT),
            24 => ::std::option::Option::Some(Failure_FailureCode::INVALID_ONION_PAYLOAD),
            997 => ::std::option::Option::Some(Failure_FailureCode::INTERNAL_FAILURE),
            998 => ::std::option::Option::Some(Failure_FailureCode::UNKNOWN_FAILURE),
            999 => ::std::option::Option::Some(Failure_FailureCode::UNREADABLE_FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Failure_FailureCode] = &[
            Failure_FailureCode::RESERVED,
            Failure_FailureCode::INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS,
            Failure_FailureCode::INCORRECT_PAYMENT_AMOUNT,
            Failure_FailureCode::FINAL_INCORRECT_CLTV_EXPIRY,
            Failure_FailureCode::FINAL_INCORRECT_HTLC_AMOUNT,
            Failure_FailureCode::FINAL_EXPIRY_TOO_SOON,
            Failure_FailureCode::INVALID_REALM,
            Failure_FailureCode::EXPIRY_TOO_SOON,
            Failure_FailureCode::INVALID_ONION_VERSION,
            Failure_FailureCode::INVALID_ONION_HMAC,
            Failure_FailureCode::INVALID_ONION_KEY,
            Failure_FailureCode::AMOUNT_BELOW_MINIMUM,
            Failure_FailureCode::FEE_INSUFFICIENT,
            Failure_FailureCode::INCORRECT_CLTV_EXPIRY,
            Failure_FailureCode::CHANNEL_DISABLED,
            Failure_FailureCode::TEMPORARY_CHANNEL_FAILURE,
            Failure_FailureCode::REQUIRED_NODE_FEATURE_MISSING,
            Failure_FailureCode::REQUIRED_CHANNEL_FEATURE_MISSING,
            Failure_FailureCode::UNKNOWN_NEXT_PEER,
            Failure_FailureCode::TEMPORARY_NODE_FAILURE,
            Failure_FailureCode::PERMANENT_NODE_FAILURE,
            Failure_FailureCode::PERMANENT_CHANNEL_FAILURE,
            Failure_FailureCode::EXPIRY_TOO_FAR,
            Failure_FailureCode::MPP_TIMEOUT,
            Failure_FailureCode::INVALID_ONION_PAYLOAD,
            Failure_FailureCode::INTERNAL_FAILURE,
            Failure_FailureCode::UNKNOWN_FAILURE,
            Failure_FailureCode::UNREADABLE_FAILURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Failure_FailureCode>("Failure.FailureCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Failure_FailureCode {
}

impl ::std::default::Default for Failure_FailureCode {
    fn default() -> Self {
        Failure_FailureCode::RESERVED
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure_FailureCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChannelUpdate {
    // message fields
    pub signature: ::std::vec::Vec<u8>,
    pub chain_hash: ::std::vec::Vec<u8>,
    pub chan_id: u64,
    pub timestamp: u32,
    pub message_flags: u32,
    pub channel_flags: u32,
    pub time_lock_delta: u32,
    pub htlc_minimum_msat: u64,
    pub base_fee: u32,
    pub fee_rate: u32,
    pub htlc_maximum_msat: u64,
    pub extra_opaque_data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelUpdate {
    fn default() -> &'a ChannelUpdate {
        <ChannelUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelUpdate {
    pub fn new() -> ChannelUpdate {
        ::std::default::Default::default()
    }

    // bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes chain_hash = 2;


    pub fn get_chain_hash(&self) -> &[u8] {
        &self.chain_hash
    }
    pub fn clear_chain_hash(&mut self) {
        self.chain_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.chain_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.chain_hash
    }

    // Take field
    pub fn take_chain_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.chain_hash, ::std::vec::Vec::new())
    }

    // uint64 chan_id = 3;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // uint32 timestamp = 4;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = v;
    }

    // uint32 message_flags = 10;


    pub fn get_message_flags(&self) -> u32 {
        self.message_flags
    }
    pub fn clear_message_flags(&mut self) {
        self.message_flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_message_flags(&mut self, v: u32) {
        self.message_flags = v;
    }

    // uint32 channel_flags = 5;


    pub fn get_channel_flags(&self) -> u32 {
        self.channel_flags
    }
    pub fn clear_channel_flags(&mut self) {
        self.channel_flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_flags(&mut self, v: u32) {
        self.channel_flags = v;
    }

    // uint32 time_lock_delta = 6;


    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    // uint64 htlc_minimum_msat = 7;


    pub fn get_htlc_minimum_msat(&self) -> u64 {
        self.htlc_minimum_msat
    }
    pub fn clear_htlc_minimum_msat(&mut self) {
        self.htlc_minimum_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_minimum_msat(&mut self, v: u64) {
        self.htlc_minimum_msat = v;
    }

    // uint32 base_fee = 8;


    pub fn get_base_fee(&self) -> u32 {
        self.base_fee
    }
    pub fn clear_base_fee(&mut self) {
        self.base_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee(&mut self, v: u32) {
        self.base_fee = v;
    }

    // uint32 fee_rate = 9;


    pub fn get_fee_rate(&self) -> u32 {
        self.fee_rate
    }
    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: u32) {
        self.fee_rate = v;
    }

    // uint64 htlc_maximum_msat = 11;


    pub fn get_htlc_maximum_msat(&self) -> u64 {
        self.htlc_maximum_msat
    }
    pub fn clear_htlc_maximum_msat(&mut self) {
        self.htlc_maximum_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_maximum_msat(&mut self, v: u64) {
        self.htlc_maximum_msat = v;
    }

    // bytes extra_opaque_data = 12;


    pub fn get_extra_opaque_data(&self) -> &[u8] {
        &self.extra_opaque_data
    }
    pub fn clear_extra_opaque_data(&mut self) {
        self.extra_opaque_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_opaque_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_opaque_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_opaque_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extra_opaque_data
    }

    // Take field
    pub fn take_extra_opaque_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extra_opaque_data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChannelUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.chain_hash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_flags = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_flags = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_minimum_msat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_fee = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_rate = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_maximum_msat = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extra_opaque_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signature);
        }
        if !self.chain_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.chain_hash);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.message_flags != 0 {
            my_size += ::protobuf::rt::value_size(10, self.message_flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel_flags != 0 {
            my_size += ::protobuf::rt::value_size(5, self.channel_flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(6, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_minimum_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.htlc_minimum_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.base_fee != 0 {
            my_size += ::protobuf::rt::value_size(8, self.base_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0 {
            my_size += ::protobuf::rt::value_size(9, self.fee_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_maximum_msat != 0 {
            my_size += ::protobuf::rt::value_size(11, self.htlc_maximum_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.extra_opaque_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.extra_opaque_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_bytes(1, &self.signature)?;
        }
        if !self.chain_hash.is_empty() {
            os.write_bytes(2, &self.chain_hash)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(3, self.chan_id)?;
        }
        if self.timestamp != 0 {
            os.write_uint32(4, self.timestamp)?;
        }
        if self.message_flags != 0 {
            os.write_uint32(10, self.message_flags)?;
        }
        if self.channel_flags != 0 {
            os.write_uint32(5, self.channel_flags)?;
        }
        if self.time_lock_delta != 0 {
            os.write_uint32(6, self.time_lock_delta)?;
        }
        if self.htlc_minimum_msat != 0 {
            os.write_uint64(7, self.htlc_minimum_msat)?;
        }
        if self.base_fee != 0 {
            os.write_uint32(8, self.base_fee)?;
        }
        if self.fee_rate != 0 {
            os.write_uint32(9, self.fee_rate)?;
        }
        if self.htlc_maximum_msat != 0 {
            os.write_uint64(11, self.htlc_maximum_msat)?;
        }
        if !self.extra_opaque_data.is_empty() {
            os.write_bytes(12, &self.extra_opaque_data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelUpdate {
        ChannelUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &ChannelUpdate| { &m.signature },
                |m: &mut ChannelUpdate| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chain_hash",
                |m: &ChannelUpdate| { &m.chain_hash },
                |m: &mut ChannelUpdate| { &mut m.chain_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chan_id",
                |m: &ChannelUpdate| { &m.chan_id },
                |m: &mut ChannelUpdate| { &mut m.chan_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &ChannelUpdate| { &m.timestamp },
                |m: &mut ChannelUpdate| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "message_flags",
                |m: &ChannelUpdate| { &m.message_flags },
                |m: &mut ChannelUpdate| { &mut m.message_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel_flags",
                |m: &ChannelUpdate| { &m.channel_flags },
                |m: &mut ChannelUpdate| { &mut m.channel_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_lock_delta",
                |m: &ChannelUpdate| { &m.time_lock_delta },
                |m: &mut ChannelUpdate| { &mut m.time_lock_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "htlc_minimum_msat",
                |m: &ChannelUpdate| { &m.htlc_minimum_msat },
                |m: &mut ChannelUpdate| { &mut m.htlc_minimum_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "base_fee",
                |m: &ChannelUpdate| { &m.base_fee },
                |m: &mut ChannelUpdate| { &mut m.base_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fee_rate",
                |m: &ChannelUpdate| { &m.fee_rate },
                |m: &mut ChannelUpdate| { &mut m.fee_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "htlc_maximum_msat",
                |m: &ChannelUpdate| { &m.htlc_maximum_msat },
                |m: &mut ChannelUpdate| { &mut m.htlc_maximum_msat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "extra_opaque_data",
                |m: &ChannelUpdate| { &m.extra_opaque_data },
                |m: &mut ChannelUpdate| { &mut m.extra_opaque_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelUpdate>(
                "ChannelUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelUpdate {
        static instance: ::protobuf::rt::LazyV2<ChannelUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelUpdate::new)
    }
}

impl ::protobuf::Clear for ChannelUpdate {
    fn clear(&mut self) {
        self.signature.clear();
        self.chain_hash.clear();
        self.chan_id = 0;
        self.timestamp = 0;
        self.message_flags = 0;
        self.channel_flags = 0;
        self.time_lock_delta = 0;
        self.htlc_minimum_msat = 0;
        self.base_fee = 0;
        self.fee_rate = 0;
        self.htlc_maximum_msat = 0;
        self.extra_opaque_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MacaroonId {
    // message fields
    pub nonce: ::std::vec::Vec<u8>,
    pub storageId: ::std::vec::Vec<u8>,
    pub ops: ::protobuf::RepeatedField<Op>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MacaroonId {
    fn default() -> &'a MacaroonId {
        <MacaroonId as ::protobuf::Message>::default_instance()
    }
}

impl MacaroonId {
    pub fn new() -> MacaroonId {
        ::std::default::Default::default()
    }

    // bytes nonce = 1;


    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    // bytes storageId = 2;


    pub fn get_storageId(&self) -> &[u8] {
        &self.storageId
    }
    pub fn clear_storageId(&mut self) {
        self.storageId.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageId(&mut self, v: ::std::vec::Vec<u8>) {
        self.storageId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.storageId
    }

    // Take field
    pub fn take_storageId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.storageId, ::std::vec::Vec::new())
    }

    // repeated .lnrpc.Op ops = 3;


    pub fn get_ops(&self) -> &[Op] {
        &self.ops
    }
    pub fn clear_ops(&mut self) {
        self.ops.clear();
    }

    // Param is passed by value, moved
    pub fn set_ops(&mut self, v: ::protobuf::RepeatedField<Op>) {
        self.ops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ops(&mut self) -> &mut ::protobuf::RepeatedField<Op> {
        &mut self.ops
    }

    // Take field
    pub fn take_ops(&mut self) -> ::protobuf::RepeatedField<Op> {
        ::std::mem::replace(&mut self.ops, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MacaroonId {
    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.storageId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ops)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.nonce);
        }
        if !self.storageId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.storageId);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.nonce.is_empty() {
            os.write_bytes(1, &self.nonce)?;
        }
        if !self.storageId.is_empty() {
            os.write_bytes(2, &self.storageId)?;
        }
        for v in &self.ops {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MacaroonId {
        MacaroonId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nonce",
                |m: &MacaroonId| { &m.nonce },
                |m: &mut MacaroonId| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "storageId",
                |m: &MacaroonId| { &m.storageId },
                |m: &mut MacaroonId| { &mut m.storageId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Op>>(
                "ops",
                |m: &MacaroonId| { &m.ops },
                |m: &mut MacaroonId| { &mut m.ops },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MacaroonId>(
                "MacaroonId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MacaroonId {
        static instance: ::protobuf::rt::LazyV2<MacaroonId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MacaroonId::new)
    }
}

impl ::protobuf::Clear for MacaroonId {
    fn clear(&mut self) {
        self.nonce.clear();
        self.storageId.clear();
        self.ops.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MacaroonId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MacaroonId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Op {
    // message fields
    pub entity: ::std::string::String,
    pub actions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Op {
    fn default() -> &'a Op {
        <Op as ::protobuf::Message>::default_instance()
    }
}

impl Op {
    pub fn new() -> Op {
        ::std::default::Default::default()
    }

    // string entity = 1;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // repeated string actions = 2;


    pub fn get_actions(&self) -> &[::std::string::String] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Op {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity);
        }
        for value in &self.actions {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity.is_empty() {
            os.write_string(1, &self.entity)?;
        }
        for v in &self.actions {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Op {
        Op::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &Op| { &m.entity },
                |m: &mut Op| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actions",
                |m: &Op| { &m.actions },
                |m: &mut Op| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Op>(
                "Op",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Op {
        static instance: ::protobuf::rt::LazyV2<Op> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Op::new)
    }
}

impl ::protobuf::Clear for Op {
    fn clear(&mut self) {
        self.entity.clear();
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Op {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AddressType {
    WITNESS_PUBKEY_HASH = 0,
    NESTED_PUBKEY_HASH = 1,
    UNUSED_WITNESS_PUBKEY_HASH = 2,
    UNUSED_NESTED_PUBKEY_HASH = 3,
}

impl ::protobuf::ProtobufEnum for AddressType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddressType> {
        match value {
            0 => ::std::option::Option::Some(AddressType::WITNESS_PUBKEY_HASH),
            1 => ::std::option::Option::Some(AddressType::NESTED_PUBKEY_HASH),
            2 => ::std::option::Option::Some(AddressType::UNUSED_WITNESS_PUBKEY_HASH),
            3 => ::std::option::Option::Some(AddressType::UNUSED_NESTED_PUBKEY_HASH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddressType] = &[
            AddressType::WITNESS_PUBKEY_HASH,
            AddressType::NESTED_PUBKEY_HASH,
            AddressType::UNUSED_WITNESS_PUBKEY_HASH,
            AddressType::UNUSED_NESTED_PUBKEY_HASH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AddressType>("AddressType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AddressType {
}

impl ::std::default::Default for AddressType {
    fn default() -> Self {
        AddressType::WITNESS_PUBKEY_HASH
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CommitmentType {
    LEGACY = 0,
    STATIC_REMOTE_KEY = 1,
    ANCHORS = 2,
    UNKNOWN_COMMITMENT_TYPE = 999,
}

impl ::protobuf::ProtobufEnum for CommitmentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommitmentType> {
        match value {
            0 => ::std::option::Option::Some(CommitmentType::LEGACY),
            1 => ::std::option::Option::Some(CommitmentType::STATIC_REMOTE_KEY),
            2 => ::std::option::Option::Some(CommitmentType::ANCHORS),
            999 => ::std::option::Option::Some(CommitmentType::UNKNOWN_COMMITMENT_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommitmentType] = &[
            CommitmentType::LEGACY,
            CommitmentType::STATIC_REMOTE_KEY,
            CommitmentType::ANCHORS,
            CommitmentType::UNKNOWN_COMMITMENT_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CommitmentType>("CommitmentType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CommitmentType {
}

impl ::std::default::Default for CommitmentType {
    fn default() -> Self {
        CommitmentType::LEGACY
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitmentType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Initiator {
    INITIATOR_UNKNOWN = 0,
    INITIATOR_LOCAL = 1,
    INITIATOR_REMOTE = 2,
    INITIATOR_BOTH = 3,
}

impl ::protobuf::ProtobufEnum for Initiator {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Initiator> {
        match value {
            0 => ::std::option::Option::Some(Initiator::INITIATOR_UNKNOWN),
            1 => ::std::option::Option::Some(Initiator::INITIATOR_LOCAL),
            2 => ::std::option::Option::Some(Initiator::INITIATOR_REMOTE),
            3 => ::std::option::Option::Some(Initiator::INITIATOR_BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Initiator] = &[
            Initiator::INITIATOR_UNKNOWN,
            Initiator::INITIATOR_LOCAL,
            Initiator::INITIATOR_REMOTE,
            Initiator::INITIATOR_BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Initiator>("Initiator", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Initiator {
}

impl ::std::default::Default for Initiator {
    fn default() -> Self {
        Initiator::INITIATOR_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Initiator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ResolutionType {
    TYPE_UNKNOWN = 0,
    ANCHOR = 1,
    INCOMING_HTLC = 2,
    OUTGOING_HTLC = 3,
    COMMIT = 4,
}

impl ::protobuf::ProtobufEnum for ResolutionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResolutionType> {
        match value {
            0 => ::std::option::Option::Some(ResolutionType::TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ResolutionType::ANCHOR),
            2 => ::std::option::Option::Some(ResolutionType::INCOMING_HTLC),
            3 => ::std::option::Option::Some(ResolutionType::OUTGOING_HTLC),
            4 => ::std::option::Option::Some(ResolutionType::COMMIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResolutionType] = &[
            ResolutionType::TYPE_UNKNOWN,
            ResolutionType::ANCHOR,
            ResolutionType::INCOMING_HTLC,
            ResolutionType::OUTGOING_HTLC,
            ResolutionType::COMMIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResolutionType>("ResolutionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResolutionType {
}

impl ::std::default::Default for ResolutionType {
    fn default() -> Self {
        ResolutionType::TYPE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolutionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ResolutionOutcome {
    OUTCOME_UNKNOWN = 0,
    CLAIMED = 1,
    UNCLAIMED = 2,
    ABANDONED = 3,
    FIRST_STAGE = 4,
    TIMEOUT = 5,
}

impl ::protobuf::ProtobufEnum for ResolutionOutcome {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResolutionOutcome> {
        match value {
            0 => ::std::option::Option::Some(ResolutionOutcome::OUTCOME_UNKNOWN),
            1 => ::std::option::Option::Some(ResolutionOutcome::CLAIMED),
            2 => ::std::option::Option::Some(ResolutionOutcome::UNCLAIMED),
            3 => ::std::option::Option::Some(ResolutionOutcome::ABANDONED),
            4 => ::std::option::Option::Some(ResolutionOutcome::FIRST_STAGE),
            5 => ::std::option::Option::Some(ResolutionOutcome::TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResolutionOutcome] = &[
            ResolutionOutcome::OUTCOME_UNKNOWN,
            ResolutionOutcome::CLAIMED,
            ResolutionOutcome::UNCLAIMED,
            ResolutionOutcome::ABANDONED,
            ResolutionOutcome::FIRST_STAGE,
            ResolutionOutcome::TIMEOUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResolutionOutcome>("ResolutionOutcome", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResolutionOutcome {
}

impl ::std::default::Default for ResolutionOutcome {
    fn default() -> Self {
        ResolutionOutcome::OUTCOME_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolutionOutcome {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum NodeMetricType {
    UNKNOWN = 0,
    BETWEENNESS_CENTRALITY = 1,
}

impl ::protobuf::ProtobufEnum for NodeMetricType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeMetricType> {
        match value {
            0 => ::std::option::Option::Some(NodeMetricType::UNKNOWN),
            1 => ::std::option::Option::Some(NodeMetricType::BETWEENNESS_CENTRALITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NodeMetricType] = &[
            NodeMetricType::UNKNOWN,
            NodeMetricType::BETWEENNESS_CENTRALITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NodeMetricType>("NodeMetricType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NodeMetricType {
}

impl ::std::default::Default for NodeMetricType {
    fn default() -> Self {
        NodeMetricType::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeMetricType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum InvoiceHTLCState {
    ACCEPTED = 0,
    SETTLED = 1,
    CANCELED = 2,
}

impl ::protobuf::ProtobufEnum for InvoiceHTLCState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InvoiceHTLCState> {
        match value {
            0 => ::std::option::Option::Some(InvoiceHTLCState::ACCEPTED),
            1 => ::std::option::Option::Some(InvoiceHTLCState::SETTLED),
            2 => ::std::option::Option::Some(InvoiceHTLCState::CANCELED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InvoiceHTLCState] = &[
            InvoiceHTLCState::ACCEPTED,
            InvoiceHTLCState::SETTLED,
            InvoiceHTLCState::CANCELED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<InvoiceHTLCState>("InvoiceHTLCState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for InvoiceHTLCState {
}

impl ::std::default::Default for InvoiceHTLCState {
    fn default() -> Self {
        InvoiceHTLCState::ACCEPTED
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceHTLCState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PaymentFailureReason {
    FAILURE_REASON_NONE = 0,
    FAILURE_REASON_TIMEOUT = 1,
    FAILURE_REASON_NO_ROUTE = 2,
    FAILURE_REASON_ERROR = 3,
    FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4,
    FAILURE_REASON_INSUFFICIENT_BALANCE = 5,
}

impl ::protobuf::ProtobufEnum for PaymentFailureReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PaymentFailureReason> {
        match value {
            0 => ::std::option::Option::Some(PaymentFailureReason::FAILURE_REASON_NONE),
            1 => ::std::option::Option::Some(PaymentFailureReason::FAILURE_REASON_TIMEOUT),
            2 => ::std::option::Option::Some(PaymentFailureReason::FAILURE_REASON_NO_ROUTE),
            3 => ::std::option::Option::Some(PaymentFailureReason::FAILURE_REASON_ERROR),
            4 => ::std::option::Option::Some(PaymentFailureReason::FAILURE_REASON_INCORRECT_PAYMENT_DETAILS),
            5 => ::std::option::Option::Some(PaymentFailureReason::FAILURE_REASON_INSUFFICIENT_BALANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PaymentFailureReason] = &[
            PaymentFailureReason::FAILURE_REASON_NONE,
            PaymentFailureReason::FAILURE_REASON_TIMEOUT,
            PaymentFailureReason::FAILURE_REASON_NO_ROUTE,
            PaymentFailureReason::FAILURE_REASON_ERROR,
            PaymentFailureReason::FAILURE_REASON_INCORRECT_PAYMENT_DETAILS,
            PaymentFailureReason::FAILURE_REASON_INSUFFICIENT_BALANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PaymentFailureReason>("PaymentFailureReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PaymentFailureReason {
}

impl ::std::default::Default for PaymentFailureReason {
    fn default() -> Self {
        PaymentFailureReason::FAILURE_REASON_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentFailureReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FeatureBit {
    DATALOSS_PROTECT_REQ = 0,
    DATALOSS_PROTECT_OPT = 1,
    INITIAL_ROUING_SYNC = 3,
    UPFRONT_SHUTDOWN_SCRIPT_REQ = 4,
    UPFRONT_SHUTDOWN_SCRIPT_OPT = 5,
    GOSSIP_QUERIES_REQ = 6,
    GOSSIP_QUERIES_OPT = 7,
    TLV_ONION_REQ = 8,
    TLV_ONION_OPT = 9,
    EXT_GOSSIP_QUERIES_REQ = 10,
    EXT_GOSSIP_QUERIES_OPT = 11,
    STATIC_REMOTE_KEY_REQ = 12,
    STATIC_REMOTE_KEY_OPT = 13,
    PAYMENT_ADDR_REQ = 14,
    PAYMENT_ADDR_OPT = 15,
    MPP_REQ = 16,
    MPP_OPT = 17,
    WUMBO_CHANNELS_REQ = 18,
    WUMBO_CHANNELS_OPT = 19,
    ANCHORS_REQ = 20,
    ANCHORS_OPT = 21,
    ANCHORS_ZERO_FEE_HTLC_REQ = 22,
    ANCHORS_ZERO_FEE_HTLC_OPT = 23,
    AMP_REQ = 30,
    AMP_OPT = 31,
}

impl ::protobuf::ProtobufEnum for FeatureBit {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FeatureBit> {
        match value {
            0 => ::std::option::Option::Some(FeatureBit::DATALOSS_PROTECT_REQ),
            1 => ::std::option::Option::Some(FeatureBit::DATALOSS_PROTECT_OPT),
            3 => ::std::option::Option::Some(FeatureBit::INITIAL_ROUING_SYNC),
            4 => ::std::option::Option::Some(FeatureBit::UPFRONT_SHUTDOWN_SCRIPT_REQ),
            5 => ::std::option::Option::Some(FeatureBit::UPFRONT_SHUTDOWN_SCRIPT_OPT),
            6 => ::std::option::Option::Some(FeatureBit::GOSSIP_QUERIES_REQ),
            7 => ::std::option::Option::Some(FeatureBit::GOSSIP_QUERIES_OPT),
            8 => ::std::option::Option::Some(FeatureBit::TLV_ONION_REQ),
            9 => ::std::option::Option::Some(FeatureBit::TLV_ONION_OPT),
            10 => ::std::option::Option::Some(FeatureBit::EXT_GOSSIP_QUERIES_REQ),
            11 => ::std::option::Option::Some(FeatureBit::EXT_GOSSIP_QUERIES_OPT),
            12 => ::std::option::Option::Some(FeatureBit::STATIC_REMOTE_KEY_REQ),
            13 => ::std::option::Option::Some(FeatureBit::STATIC_REMOTE_KEY_OPT),
            14 => ::std::option::Option::Some(FeatureBit::PAYMENT_ADDR_REQ),
            15 => ::std::option::Option::Some(FeatureBit::PAYMENT_ADDR_OPT),
            16 => ::std::option::Option::Some(FeatureBit::MPP_REQ),
            17 => ::std::option::Option::Some(FeatureBit::MPP_OPT),
            18 => ::std::option::Option::Some(FeatureBit::WUMBO_CHANNELS_REQ),
            19 => ::std::option::Option::Some(FeatureBit::WUMBO_CHANNELS_OPT),
            20 => ::std::option::Option::Some(FeatureBit::ANCHORS_REQ),
            21 => ::std::option::Option::Some(FeatureBit::ANCHORS_OPT),
            22 => ::std::option::Option::Some(FeatureBit::ANCHORS_ZERO_FEE_HTLC_REQ),
            23 => ::std::option::Option::Some(FeatureBit::ANCHORS_ZERO_FEE_HTLC_OPT),
            30 => ::std::option::Option::Some(FeatureBit::AMP_REQ),
            31 => ::std::option::Option::Some(FeatureBit::AMP_OPT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FeatureBit] = &[
            FeatureBit::DATALOSS_PROTECT_REQ,
            FeatureBit::DATALOSS_PROTECT_OPT,
            FeatureBit::INITIAL_ROUING_SYNC,
            FeatureBit::UPFRONT_SHUTDOWN_SCRIPT_REQ,
            FeatureBit::UPFRONT_SHUTDOWN_SCRIPT_OPT,
            FeatureBit::GOSSIP_QUERIES_REQ,
            FeatureBit::GOSSIP_QUERIES_OPT,
            FeatureBit::TLV_ONION_REQ,
            FeatureBit::TLV_ONION_OPT,
            FeatureBit::EXT_GOSSIP_QUERIES_REQ,
            FeatureBit::EXT_GOSSIP_QUERIES_OPT,
            FeatureBit::STATIC_REMOTE_KEY_REQ,
            FeatureBit::STATIC_REMOTE_KEY_OPT,
            FeatureBit::PAYMENT_ADDR_REQ,
            FeatureBit::PAYMENT_ADDR_OPT,
            FeatureBit::MPP_REQ,
            FeatureBit::MPP_OPT,
            FeatureBit::WUMBO_CHANNELS_REQ,
            FeatureBit::WUMBO_CHANNELS_OPT,
            FeatureBit::ANCHORS_REQ,
            FeatureBit::ANCHORS_OPT,
            FeatureBit::ANCHORS_ZERO_FEE_HTLC_REQ,
            FeatureBit::ANCHORS_ZERO_FEE_HTLC_OPT,
            FeatureBit::AMP_REQ,
            FeatureBit::AMP_OPT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FeatureBit>("FeatureBit", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FeatureBit {
}

impl ::std::default::Default for FeatureBit {
    fn default() -> Self {
        FeatureBit::DATALOSS_PROTECT_REQ
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureBit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\trpc.proto\x12\x05lnrpc\"\xe6\x01\n\x04Utxo\x125\n\x0caddress_type\
    \x18\x01\x20\x01(\x0e2\x12.lnrpc.AddressTypeR\x0baddressType\x12\x18\n\
    \x07address\x18\x02\x20\x01(\tR\x07address\x12\x1d\n\namount_sat\x18\x03\
    \x20\x01(\x03R\tamountSat\x12\x1b\n\tpk_script\x18\x04\x20\x01(\tR\x08pk\
    Script\x12+\n\x08outpoint\x18\x05\x20\x01(\x0b2\x0f.lnrpc.OutPointR\x08o\
    utpoint\x12$\n\rconfirmations\x18\x06\x20\x01(\x03R\rconfirmations\"\xc6\
    \x02\n\x0bTransaction\x12\x17\n\x07tx_hash\x18\x01\x20\x01(\tR\x06txHash\
    \x12\x16\n\x06amount\x18\x02\x20\x01(\x03R\x06amount\x12+\n\x11num_confi\
    rmations\x18\x03\x20\x01(\x05R\x10numConfirmations\x12\x1d\n\nblock_hash\
    \x18\x04\x20\x01(\tR\tblockHash\x12!\n\x0cblock_height\x18\x05\x20\x01(\
    \x05R\x0bblockHeight\x12\x1d\n\ntime_stamp\x18\x06\x20\x01(\x03R\ttimeSt\
    amp\x12\x1d\n\ntotal_fees\x18\x07\x20\x01(\x03R\ttotalFees\x12%\n\x0edes\
    t_addresses\x18\x08\x20\x03(\tR\rdestAddresses\x12\x1c\n\nraw_tx_hex\x18\
    \t\x20\x01(\tR\x08rawTxHex\x12\x14\n\x05label\x18\n\x20\x01(\tR\x05label\
    \"t\n\x16GetTransactionsRequest\x12!\n\x0cstart_height\x18\x01\x20\x01(\
    \x05R\x0bstartHeight\x12\x1d\n\nend_height\x18\x02\x20\x01(\x05R\tendHei\
    ght\x12\x18\n\x07account\x18\x03\x20\x01(\tR\x07account\"L\n\x12Transact\
    ionDetails\x126\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x12.lnrpc.Transa\
    ctionR\x0ctransactions\"h\n\x08FeeLimit\x12\x16\n\x05fixed\x18\x01\x20\
    \x01(\x03H\0R\x05fixed\x12\x1f\n\nfixed_msat\x18\x03\x20\x01(\x03H\0R\tf\
    ixedMsat\x12\x1a\n\x07percent\x18\x02\x20\x01(\x03H\0R\x07percentB\x07\n\
    \x05limit\"\xea\x05\n\x0bSendRequest\x12\x12\n\x04dest\x18\x01\x20\x01(\
    \x0cR\x04dest\x12#\n\x0bdest_string\x18\x02\x20\x01(\tR\ndestStringB\x02\
    \x18\x01\x12\x10\n\x03amt\x18\x03\x20\x01(\x03R\x03amt\x12\x19\n\x08amt_\
    msat\x18\x0c\x20\x01(\x03R\x07amtMsat\x12!\n\x0cpayment_hash\x18\x04\x20\
    \x01(\x0cR\x0bpaymentHash\x122\n\x13payment_hash_string\x18\x05\x20\x01(\
    \tR\x11paymentHashStringB\x02\x18\x01\x12'\n\x0fpayment_request\x18\x06\
    \x20\x01(\tR\x0epaymentRequest\x12(\n\x10final_cltv_delta\x18\x07\x20\
    \x01(\x05R\x0efinalCltvDelta\x12,\n\tfee_limit\x18\x08\x20\x01(\x0b2\x0f\
    .lnrpc.FeeLimitR\x08feeLimit\x12,\n\x10outgoing_chan_id\x18\t\x20\x01(\
    \x04R\x0eoutgoingChanIdB\x020\x01\x12&\n\x0flast_hop_pubkey\x18\r\x20\
    \x01(\x0cR\rlastHopPubkey\x12\x1d\n\ncltv_limit\x18\n\x20\x01(\rR\tcltvL\
    imit\x12Y\n\x13dest_custom_records\x18\x0b\x20\x03(\x0b2).lnrpc.SendRequ\
    est.DestCustomRecordsEntryR\x11destCustomRecords\x12,\n\x12allow_self_pa\
    yment\x18\x0e\x20\x01(\x08R\x10allowSelfPayment\x126\n\rdest_features\
    \x18\x0f\x20\x03(\x0e2\x11.lnrpc.FeatureBitR\x0cdestFeatures\x12!\n\x0cp\
    ayment_addr\x18\x10\x20\x01(\x0cR\x0bpaymentAddr\x1aD\n\x16DestCustomRec\
    ordsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\"\xb4\x01\n\x0cSendResponse\
    \x12#\n\rpayment_error\x18\x01\x20\x01(\tR\x0cpaymentError\x12)\n\x10pay\
    ment_preimage\x18\x02\x20\x01(\x0cR\x0fpaymentPreimage\x121\n\rpayment_r\
    oute\x18\x03\x20\x01(\x0b2\x0c.lnrpc.RouteR\x0cpaymentRoute\x12!\n\x0cpa\
    yment_hash\x18\x04\x20\x01(\x0cR\x0bpaymentHash\"\x95\x01\n\x12SendToRou\
    teRequest\x12!\n\x0cpayment_hash\x18\x01\x20\x01(\x0cR\x0bpaymentHash\
    \x122\n\x13payment_hash_string\x18\x02\x20\x01(\tR\x11paymentHashStringB\
    \x02\x18\x01\x12\"\n\x05route\x18\x04\x20\x01(\x0b2\x0c.lnrpc.RouteR\x05\
    routeJ\x04\x08\x03\x10\x04\"\xda\x03\n\x14ChannelAcceptRequest\x12\x1f\n\
    \x0bnode_pubkey\x18\x01\x20\x01(\x0cR\nnodePubkey\x12\x1d\n\nchain_hash\
    \x18\x02\x20\x01(\x0cR\tchainHash\x12&\n\x0fpending_chan_id\x18\x03\x20\
    \x01(\x0cR\rpendingChanId\x12\x1f\n\x0bfunding_amt\x18\x04\x20\x01(\x04R\
    \nfundingAmt\x12\x19\n\x08push_amt\x18\x05\x20\x01(\x04R\x07pushAmt\x12\
    \x1d\n\ndust_limit\x18\x06\x20\x01(\x04R\tdustLimit\x12-\n\x13max_value_\
    in_flight\x18\x07\x20\x01(\x04R\x10maxValueInFlight\x12'\n\x0fchannel_re\
    serve\x18\x08\x20\x01(\x04R\x0echannelReserve\x12\x19\n\x08min_htlc\x18\
    \t\x20\x01(\x04R\x07minHtlc\x12\x1c\n\nfee_per_kw\x18\n\x20\x01(\x04R\
    \x08feePerKw\x12\x1b\n\tcsv_delay\x18\x0b\x20\x01(\rR\x08csvDelay\x12,\n\
    \x12max_accepted_htlcs\x18\x0c\x20\x01(\rR\x10maxAcceptedHtlcs\x12#\n\rc\
    hannel_flags\x18\r\x20\x01(\rR\x0cchannelFlags\"\xf3\x02\n\x15ChannelAcc\
    eptResponse\x12\x16\n\x06accept\x18\x01\x20\x01(\x08R\x06accept\x12&\n\
    \x0fpending_chan_id\x18\x02\x20\x01(\x0cR\rpendingChanId\x12\x14\n\x05er\
    ror\x18\x03\x20\x01(\tR\x05error\x12)\n\x10upfront_shutdown\x18\x04\x20\
    \x01(\tR\x0fupfrontShutdown\x12\x1b\n\tcsv_delay\x18\x05\x20\x01(\rR\x08\
    csvDelay\x12\x1f\n\x0breserve_sat\x18\x06\x20\x01(\x04R\nreserveSat\x12+\
    \n\x12in_flight_max_msat\x18\x07\x20\x01(\x04R\x0finFlightMaxMsat\x12$\n\
    \x0emax_htlc_count\x18\x08\x20\x01(\rR\x0cmaxHtlcCount\x12\x1e\n\x0bmin_\
    htlc_in\x18\t\x20\x01(\x04R\tminHtlcIn\x12(\n\x10min_accept_depth\x18\n\
    \x20\x01(\rR\x0eminAcceptDepth\"\x9d\x01\n\x0cChannelPoint\x12.\n\x12fun\
    ding_txid_bytes\x18\x01\x20\x01(\x0cH\0R\x10fundingTxidBytes\x12*\n\x10f\
    unding_txid_str\x18\x02\x20\x01(\tH\0R\x0efundingTxidStr\x12!\n\x0coutpu\
    t_index\x18\x03\x20\x01(\rR\x0boutputIndexB\x0e\n\x0cfunding_txid\"g\n\
    \x08OutPoint\x12\x1d\n\ntxid_bytes\x18\x01\x20\x01(\x0cR\ttxidBytes\x12\
    \x19\n\x08txid_str\x18\x02\x20\x01(\tR\x07txidStr\x12!\n\x0coutput_index\
    \x18\x03\x20\x01(\rR\x0boutputIndex\">\n\x10LightningAddress\x12\x16\n\
    \x06pubkey\x18\x01\x20\x01(\tR\x06pubkey\x12\x12\n\x04host\x18\x02\x20\
    \x01(\tR\x04host\"\x91\x02\n\x12EstimateFeeRequest\x12O\n\x0cAddrToAmoun\
    t\x18\x01\x20\x03(\x0b2+.lnrpc.EstimateFeeRequest.AddrToAmountEntryR\x0c\
    AddrToAmount\x12\x1f\n\x0btarget_conf\x18\x02\x20\x01(\x05R\ntargetConf\
    \x12\x1b\n\tmin_confs\x18\x03\x20\x01(\x05R\x08minConfs\x12+\n\x11spend_\
    unconfirmed\x18\x04\x20\x01(\x08R\x10spendUnconfirmed\x1a?\n\x11AddrToAm\
    ountEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x03R\x05value:\x028\x01\"\x87\x01\n\x13EstimateFeeResp\
    onse\x12\x17\n\x07fee_sat\x18\x01\x20\x01(\x03R\x06feeSat\x123\n\x14feer\
    ate_sat_per_byte\x18\x02\x20\x01(\x03R\x11feerateSatPerByteB\x02\x18\x01\
    \x12\"\n\rsat_per_vbyte\x18\x03\x20\x01(\x04R\x0bsatPerVbyte\"\xeb\x02\n\
    \x0fSendManyRequest\x12L\n\x0cAddrToAmount\x18\x01\x20\x03(\x0b2(.lnrpc.\
    SendManyRequest.AddrToAmountEntryR\x0cAddrToAmount\x12\x1f\n\x0btarget_c\
    onf\x18\x03\x20\x01(\x05R\ntargetConf\x12\"\n\rsat_per_vbyte\x18\x04\x20\
    \x01(\x04R\x0bsatPerVbyte\x12$\n\x0csat_per_byte\x18\x05\x20\x01(\x03R\n\
    satPerByteB\x02\x18\x01\x12\x14\n\x05label\x18\x06\x20\x01(\tR\x05label\
    \x12\x1b\n\tmin_confs\x18\x07\x20\x01(\x05R\x08minConfs\x12+\n\x11spend_\
    unconfirmed\x18\x08\x20\x01(\x08R\x10spendUnconfirmed\x1a?\n\x11AddrToAm\
    ountEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x03R\x05value:\x028\x01\"&\n\x10SendManyResponse\x12\
    \x12\n\x04txid\x18\x01\x20\x01(\tR\x04txid\"\xa4\x02\n\x10SendCoinsReque\
    st\x12\x12\n\x04addr\x18\x01\x20\x01(\tR\x04addr\x12\x16\n\x06amount\x18\
    \x02\x20\x01(\x03R\x06amount\x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\
    \x05R\ntargetConf\x12\"\n\rsat_per_vbyte\x18\x04\x20\x01(\x04R\x0bsatPer\
    Vbyte\x12$\n\x0csat_per_byte\x18\x05\x20\x01(\x03R\nsatPerByteB\x02\x18\
    \x01\x12\x19\n\x08send_all\x18\x06\x20\x01(\x08R\x07sendAll\x12\x14\n\
    \x05label\x18\x07\x20\x01(\tR\x05label\x12\x1b\n\tmin_confs\x18\x08\x20\
    \x01(\x05R\x08minConfs\x12+\n\x11spend_unconfirmed\x18\t\x20\x01(\x08R\
    \x10spendUnconfirmed\"'\n\x11SendCoinsResponse\x12\x12\n\x04txid\x18\x01\
    \x20\x01(\tR\x04txid\"h\n\x12ListUnspentRequest\x12\x1b\n\tmin_confs\x18\
    \x01\x20\x01(\x05R\x08minConfs\x12\x1b\n\tmax_confs\x18\x02\x20\x01(\x05\
    R\x08maxConfs\x12\x18\n\x07account\x18\x03\x20\x01(\tR\x07account\"8\n\
    \x13ListUnspentResponse\x12!\n\x05utxos\x18\x01\x20\x03(\x0b2\x0b.lnrpc.\
    UtxoR\x05utxos\"U\n\x11NewAddressRequest\x12&\n\x04type\x18\x01\x20\x01(\
    \x0e2\x12.lnrpc.AddressTypeR\x04type\x12\x18\n\x07account\x18\x02\x20\
    \x01(\tR\x07account\".\n\x12NewAddressResponse\x12\x18\n\x07address\x18\
    \x01\x20\x01(\tR\x07address\"&\n\x12SignMessageRequest\x12\x10\n\x03msg\
    \x18\x01\x20\x01(\x0cR\x03msg\"3\n\x13SignMessageResponse\x12\x1c\n\tsig\
    nature\x18\x01\x20\x01(\tR\tsignature\"F\n\x14VerifyMessageRequest\x12\
    \x10\n\x03msg\x18\x01\x20\x01(\x0cR\x03msg\x12\x1c\n\tsignature\x18\x02\
    \x20\x01(\tR\tsignature\"E\n\x15VerifyMessageResponse\x12\x14\n\x05valid\
    \x18\x01\x20\x01(\x08R\x05valid\x12\x16\n\x06pubkey\x18\x02\x20\x01(\tR\
    \x06pubkey\"o\n\x12ConnectPeerRequest\x12+\n\x04addr\x18\x01\x20\x01(\
    \x0b2\x17.lnrpc.LightningAddressR\x04addr\x12\x12\n\x04perm\x18\x02\x20\
    \x01(\x08R\x04perm\x12\x18\n\x07timeout\x18\x03\x20\x01(\x04R\x07timeout\
    \"\x15\n\x13ConnectPeerResponse\"0\n\x15DisconnectPeerRequest\x12\x17\n\
    \x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\"\x18\n\x16DisconnectPeerRespo\
    nse\"\x86\x02\n\x04HTLC\x12\x1a\n\x08incoming\x18\x01\x20\x01(\x08R\x08i\
    ncoming\x12\x16\n\x06amount\x18\x02\x20\x01(\x03R\x06amount\x12\x1b\n\th\
    ash_lock\x18\x03\x20\x01(\x0cR\x08hashLock\x12+\n\x11expiration_height\
    \x18\x04\x20\x01(\rR\x10expirationHeight\x12\x1d\n\nhtlc_index\x18\x05\
    \x20\x01(\x04R\thtlcIndex\x12-\n\x12forwarding_channel\x18\x06\x20\x01(\
    \x04R\x11forwardingChannel\x122\n\x15forwarding_htlc_index\x18\x07\x20\
    \x01(\x04R\x13forwardingHtlcIndex\"\x84\x02\n\x12ChannelConstraints\x12\
    \x1b\n\tcsv_delay\x18\x01\x20\x01(\rR\x08csvDelay\x12(\n\x10chan_reserve\
    _sat\x18\x02\x20\x01(\x04R\x0echanReserveSat\x12$\n\x0edust_limit_sat\
    \x18\x03\x20\x01(\x04R\x0cdustLimitSat\x12/\n\x14max_pending_amt_msat\
    \x18\x04\x20\x01(\x04R\x11maxPendingAmtMsat\x12\"\n\rmin_htlc_msat\x18\
    \x05\x20\x01(\x04R\x0bminHtlcMsat\x12,\n\x12max_accepted_htlcs\x18\x06\
    \x20\x01(\rR\x10maxAcceptedHtlcs\"\xd7\t\n\x07Channel\x12\x16\n\x06activ\
    e\x18\x01\x20\x01(\x08R\x06active\x12#\n\rremote_pubkey\x18\x02\x20\x01(\
    \tR\x0cremotePubkey\x12#\n\rchannel_point\x18\x03\x20\x01(\tR\x0cchannel\
    Point\x12\x1b\n\x07chan_id\x18\x04\x20\x01(\x04R\x06chanIdB\x020\x01\x12\
    \x1a\n\x08capacity\x18\x05\x20\x01(\x03R\x08capacity\x12#\n\rlocal_balan\
    ce\x18\x06\x20\x01(\x03R\x0clocalBalance\x12%\n\x0eremote_balance\x18\
    \x07\x20\x01(\x03R\rremoteBalance\x12\x1d\n\ncommit_fee\x18\x08\x20\x01(\
    \x03R\tcommitFee\x12#\n\rcommit_weight\x18\t\x20\x01(\x03R\x0ccommitWeig\
    ht\x12\x1c\n\nfee_per_kw\x18\n\x20\x01(\x03R\x08feePerKw\x12+\n\x11unset\
    tled_balance\x18\x0b\x20\x01(\x03R\x10unsettledBalance\x12.\n\x13total_s\
    atoshis_sent\x18\x0c\x20\x01(\x03R\x11totalSatoshisSent\x126\n\x17total_\
    satoshis_received\x18\r\x20\x01(\x03R\x15totalSatoshisReceived\x12\x1f\n\
    \x0bnum_updates\x18\x0e\x20\x01(\x04R\nnumUpdates\x120\n\rpending_htlcs\
    \x18\x0f\x20\x03(\x0b2\x0b.lnrpc.HTLCR\x0cpendingHtlcs\x12\x1f\n\tcsv_de\
    lay\x18\x10\x20\x01(\rR\x08csvDelayB\x02\x18\x01\x12\x18\n\x07private\
    \x18\x11\x20\x01(\x08R\x07private\x12\x1c\n\tinitiator\x18\x12\x20\x01(\
    \x08R\tinitiator\x12*\n\x11chan_status_flags\x18\x13\x20\x01(\tR\x0fchan\
    StatusFlags\x127\n\x16local_chan_reserve_sat\x18\x14\x20\x01(\x03R\x13lo\
    calChanReserveSatB\x02\x18\x01\x129\n\x17remote_chan_reserve_sat\x18\x15\
    \x20\x01(\x03R\x14remoteChanReserveSatB\x02\x18\x01\x12.\n\x11static_rem\
    ote_key\x18\x16\x20\x01(\x08R\x0fstaticRemoteKeyB\x02\x18\x01\x12>\n\x0f\
    commitment_type\x18\x1a\x20\x01(\x0e2\x15.lnrpc.CommitmentTypeR\x0ecommi\
    tmentType\x12\x1a\n\x08lifetime\x18\x17\x20\x01(\x03R\x08lifetime\x12\
    \x16\n\x06uptime\x18\x18\x20\x01(\x03R\x06uptime\x12#\n\rclose_address\
    \x18\x19\x20\x01(\tR\x0ccloseAddress\x12&\n\x0fpush_amount_sat\x18\x1b\
    \x20\x01(\x04R\rpushAmountSat\x12\x1f\n\x0bthaw_height\x18\x1c\x20\x01(\
    \rR\nthawHeight\x12F\n\x11local_constraints\x18\x1d\x20\x01(\x0b2\x19.ln\
    rpc.ChannelConstraintsR\x10localConstraints\x12H\n\x12remote_constraints\
    \x18\x1e\x20\x01(\x0b2\x19.lnrpc.ChannelConstraintsR\x11remoteConstraint\
    s\"\xb3\x01\n\x13ListChannelsRequest\x12\x1f\n\x0bactive_only\x18\x01\
    \x20\x01(\x08R\nactiveOnly\x12#\n\rinactive_only\x18\x02\x20\x01(\x08R\
    \x0cinactiveOnly\x12\x1f\n\x0bpublic_only\x18\x03\x20\x01(\x08R\npublicO\
    nly\x12!\n\x0cprivate_only\x18\x04\x20\x01(\x08R\x0bprivateOnly\x12\x12\
    \n\x04peer\x18\x05\x20\x01(\x0cR\x04peer\"B\n\x14ListChannelsResponse\
    \x12*\n\x08channels\x18\x0b\x20\x03(\x0b2\x0e.lnrpc.ChannelR\x08channels\
    \"\xd8\x05\n\x13ChannelCloseSummary\x12#\n\rchannel_point\x18\x01\x20\
    \x01(\tR\x0cchannelPoint\x12\x1b\n\x07chan_id\x18\x02\x20\x01(\x04R\x06c\
    hanIdB\x020\x01\x12\x1d\n\nchain_hash\x18\x03\x20\x01(\tR\tchainHash\x12\
    &\n\x0fclosing_tx_hash\x18\x04\x20\x01(\tR\rclosingTxHash\x12#\n\rremote\
    _pubkey\x18\x05\x20\x01(\tR\x0cremotePubkey\x12\x1a\n\x08capacity\x18\
    \x06\x20\x01(\x03R\x08capacity\x12!\n\x0cclose_height\x18\x07\x20\x01(\r\
    R\x0bcloseHeight\x12'\n\x0fsettled_balance\x18\x08\x20\x01(\x03R\x0esett\
    ledBalance\x12.\n\x13time_locked_balance\x18\t\x20\x01(\x03R\x11timeLock\
    edBalance\x12E\n\nclose_type\x18\n\x20\x01(\x0e2&.lnrpc.ChannelCloseSumm\
    ary.ClosureTypeR\tcloseType\x127\n\x0eopen_initiator\x18\x0b\x20\x01(\
    \x0e2\x10.lnrpc.InitiatorR\ropenInitiator\x129\n\x0fclose_initiator\x18\
    \x0c\x20\x01(\x0e2\x10.lnrpc.InitiatorR\x0ecloseInitiator\x123\n\x0breso\
    lutions\x18\r\x20\x03(\x0b2\x11.lnrpc.ResolutionR\x0bresolutions\"\x8a\
    \x01\n\x0bClosureType\x12\x15\n\x11COOPERATIVE_CLOSE\x10\0\x12\x15\n\x11\
    LOCAL_FORCE_CLOSE\x10\x01\x12\x16\n\x12REMOTE_FORCE_CLOSE\x10\x02\x12\
    \x10\n\x0cBREACH_CLOSE\x10\x03\x12\x14\n\x10FUNDING_CANCELED\x10\x04\x12\
    \r\n\tABANDONED\x10\x05\"\xeb\x01\n\nResolution\x12>\n\x0fresolution_typ\
    e\x18\x01\x20\x01(\x0e2\x15.lnrpc.ResolutionTypeR\x0eresolutionType\x122\
    \n\x07outcome\x18\x02\x20\x01(\x0e2\x18.lnrpc.ResolutionOutcomeR\x07outc\
    ome\x12+\n\x08outpoint\x18\x03\x20\x01(\x0b2\x0f.lnrpc.OutPointR\x08outp\
    oint\x12\x1d\n\namount_sat\x18\x04\x20\x01(\x04R\tamountSat\x12\x1d\n\ns\
    weep_txid\x18\x05\x20\x01(\tR\tsweepTxid\"\xde\x01\n\x15ClosedChannelsRe\
    quest\x12\x20\n\x0bcooperative\x18\x01\x20\x01(\x08R\x0bcooperative\x12\
    \x1f\n\x0blocal_force\x18\x02\x20\x01(\x08R\nlocalForce\x12!\n\x0cremote\
    _force\x18\x03\x20\x01(\x08R\x0bremoteForce\x12\x16\n\x06breach\x18\x04\
    \x20\x01(\x08R\x06breach\x12)\n\x10funding_canceled\x18\x05\x20\x01(\x08\
    R\x0ffundingCanceled\x12\x1c\n\tabandoned\x18\x06\x20\x01(\x08R\tabandon\
    ed\"P\n\x16ClosedChannelsResponse\x126\n\x08channels\x18\x01\x20\x03(\
    \x0b2\x1a.lnrpc.ChannelCloseSummaryR\x08channels\"\xdf\x04\n\x04Peer\x12\
    \x17\n\x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\x12\x18\n\x07address\x18\
    \x03\x20\x01(\tR\x07address\x12\x1d\n\nbytes_sent\x18\x04\x20\x01(\x04R\
    \tbytesSent\x12\x1d\n\nbytes_recv\x18\x05\x20\x01(\x04R\tbytesRecv\x12\
    \x19\n\x08sat_sent\x18\x06\x20\x01(\x03R\x07satSent\x12\x19\n\x08sat_rec\
    v\x18\x07\x20\x01(\x03R\x07satRecv\x12\x18\n\x07inbound\x18\x08\x20\x01(\
    \x08R\x07inbound\x12\x1b\n\tping_time\x18\t\x20\x01(\x03R\x08pingTime\
    \x121\n\tsync_type\x18\n\x20\x01(\x0e2\x14.lnrpc.Peer.SyncTypeR\x08syncT\
    ype\x125\n\x08features\x18\x0b\x20\x03(\x0b2\x19.lnrpc.Peer.FeaturesEntr\
    yR\x08features\x12/\n\x06errors\x18\x0c\x20\x03(\x0b2\x17.lnrpc.Timestam\
    pedErrorR\x06errors\x12\x1d\n\nflap_count\x18\r\x20\x01(\x05R\tflapCount\
    \x12\x20\n\x0clast_flap_ns\x18\x0e\x20\x01(\x03R\nlastFlapNs\x1aK\n\rFea\
    turesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12$\n\x05value\
    \x18\x02\x20\x01(\x0b2\x0e.lnrpc.FeatureR\x05value:\x028\x01\"P\n\x08Syn\
    cType\x12\x10\n\x0cUNKNOWN_SYNC\x10\0\x12\x0f\n\x0bACTIVE_SYNC\x10\x01\
    \x12\x10\n\x0cPASSIVE_SYNC\x10\x02\x12\x0f\n\x0bPINNED_SYNC\x10\x03\"F\n\
    \x10TimestampedError\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimesta\
    mp\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\"5\n\x10ListPeersRequ\
    est\x12!\n\x0clatest_error\x18\x01\x20\x01(\x08R\x0blatestError\"6\n\x11\
    ListPeersResponse\x12!\n\x05peers\x18\x01\x20\x03(\x0b2\x0b.lnrpc.PeerR\
    \x05peers\"\x17\n\x15PeerEventSubscription\"\x84\x01\n\tPeerEvent\x12\
    \x17\n\x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\x12.\n\x04type\x18\x02\
    \x20\x01(\x0e2\x1a.lnrpc.PeerEvent.EventTypeR\x04type\".\n\tEventType\
    \x12\x0f\n\x0bPEER_ONLINE\x10\0\x12\x10\n\x0cPEER_OFFLINE\x10\x01\"\x10\
    \n\x0eGetInfoRequest\"\x87\x06\n\x0fGetInfoResponse\x12\x18\n\x07version\
    \x18\x0e\x20\x01(\tR\x07version\x12\x1f\n\x0bcommit_hash\x18\x14\x20\x01\
    (\tR\ncommitHash\x12'\n\x0fidentity_pubkey\x18\x01\x20\x01(\tR\x0eidenti\
    tyPubkey\x12\x14\n\x05alias\x18\x02\x20\x01(\tR\x05alias\x12\x14\n\x05co\
    lor\x18\x11\x20\x01(\tR\x05color\x120\n\x14num_pending_channels\x18\x03\
    \x20\x01(\rR\x12numPendingChannels\x12.\n\x13num_active_channels\x18\x04\
    \x20\x01(\rR\x11numActiveChannels\x122\n\x15num_inactive_channels\x18\
    \x0f\x20\x01(\rR\x13numInactiveChannels\x12\x1b\n\tnum_peers\x18\x05\x20\
    \x01(\rR\x08numPeers\x12!\n\x0cblock_height\x18\x06\x20\x01(\rR\x0bblock\
    Height\x12\x1d\n\nblock_hash\x18\x08\x20\x01(\tR\tblockHash\x122\n\x15be\
    st_header_timestamp\x18\r\x20\x01(\x03R\x13bestHeaderTimestamp\x12&\n\
    \x0fsynced_to_chain\x18\t\x20\x01(\x08R\rsyncedToChain\x12&\n\x0fsynced_\
    to_graph\x18\x12\x20\x01(\x08R\rsyncedToGraph\x12\x1c\n\x07testnet\x18\n\
    \x20\x01(\x08R\x07testnetB\x02\x18\x01\x12$\n\x06chains\x18\x10\x20\x03(\
    \x0b2\x0c.lnrpc.ChainR\x06chains\x12\x12\n\x04uris\x18\x0c\x20\x03(\tR\
    \x04uris\x12@\n\x08features\x18\x13\x20\x03(\x0b2$.lnrpc.GetInfoResponse\
    .FeaturesEntryR\x08features\x1aK\n\rFeaturesEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\rR\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\x0e.lnrpc.\
    FeatureR\x05value:\x028\x01J\x04\x08\x0b\x10\x0c\"\x18\n\x16GetRecoveryI\
    nfoRequest\"\x87\x01\n\x17GetRecoveryInfoResponse\x12#\n\rrecovery_mode\
    \x18\x01\x20\x01(\x08R\x0crecoveryMode\x12+\n\x11recovery_finished\x18\
    \x02\x20\x01(\x08R\x10recoveryFinished\x12\x1a\n\x08progress\x18\x03\x20\
    \x01(\x01R\x08progress\"7\n\x05Chain\x12\x14\n\x05chain\x18\x01\x20\x01(\
    \tR\x05chain\x12\x18\n\x07network\x18\x02\x20\x01(\tR\x07network\"z\n\
    \x12ConfirmationUpdate\x12\x1b\n\tblock_sha\x18\x01\x20\x01(\x0cR\x08blo\
    ckSha\x12!\n\x0cblock_height\x18\x02\x20\x01(\x05R\x0bblockHeight\x12$\n\
    \x0enum_confs_left\x18\x03\x20\x01(\rR\x0cnumConfsLeft\"M\n\x11ChannelOp\
    enUpdate\x128\n\rchannel_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPo\
    intR\x0cchannelPoint\"Q\n\x12ChannelCloseUpdate\x12!\n\x0cclosing_txid\
    \x18\x01\x20\x01(\x0cR\x0bclosingTxid\x12\x18\n\x07success\x18\x02\x20\
    \x01(\x08R\x07success\"\xfb\x01\n\x13CloseChannelRequest\x128\n\rchannel\
    _point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\x0cchannelPoint\x12\
    \x14\n\x05force\x18\x02\x20\x01(\x08R\x05force\x12\x1f\n\x0btarget_conf\
    \x18\x03\x20\x01(\x05R\ntargetConf\x12$\n\x0csat_per_byte\x18\x04\x20\
    \x01(\x03R\nsatPerByteB\x02\x18\x01\x12)\n\x10delivery_address\x18\x05\
    \x20\x01(\tR\x0fdeliveryAddress\x12\"\n\rsat_per_vbyte\x18\x06\x20\x01(\
    \x04R\x0bsatPerVbyte\"\x96\x01\n\x11CloseStatusUpdate\x12;\n\rclose_pend\
    ing\x18\x01\x20\x01(\x0b2\x14.lnrpc.PendingUpdateH\0R\x0cclosePending\
    \x12:\n\nchan_close\x18\x03\x20\x01(\x0b2\x19.lnrpc.ChannelCloseUpdateH\
    \0R\tchanCloseB\x08\n\x06update\"F\n\rPendingUpdate\x12\x12\n\x04txid\
    \x18\x01\x20\x01(\x0cR\x04txid\x12!\n\x0coutput_index\x18\x02\x20\x01(\r\
    R\x0boutputIndex\"y\n\x13ReadyForPsbtFunding\x12'\n\x0ffunding_address\
    \x18\x01\x20\x01(\tR\x0efundingAddress\x12%\n\x0efunding_amount\x18\x02\
    \x20\x01(\x03R\rfundingAmount\x12\x12\n\x04psbt\x18\x03\x20\x01(\x0cR\
    \x04psbt\"\xc0\x05\n\x12OpenChannelRequest\x12\"\n\rsat_per_vbyte\x18\
    \x01\x20\x01(\x04R\x0bsatPerVbyte\x12\x1f\n\x0bnode_pubkey\x18\x02\x20\
    \x01(\x0cR\nnodePubkey\x120\n\x12node_pubkey_string\x18\x03\x20\x01(\tR\
    \x10nodePubkeyStringB\x02\x18\x01\x120\n\x14local_funding_amount\x18\x04\
    \x20\x01(\x03R\x12localFundingAmount\x12\x19\n\x08push_sat\x18\x05\x20\
    \x01(\x03R\x07pushSat\x12\x1f\n\x0btarget_conf\x18\x06\x20\x01(\x05R\nta\
    rgetConf\x12$\n\x0csat_per_byte\x18\x07\x20\x01(\x03R\nsatPerByteB\x02\
    \x18\x01\x12\x18\n\x07private\x18\x08\x20\x01(\x08R\x07private\x12\"\n\r\
    min_htlc_msat\x18\t\x20\x01(\x03R\x0bminHtlcMsat\x12(\n\x10remote_csv_de\
    lay\x18\n\x20\x01(\rR\x0eremoteCsvDelay\x12\x1b\n\tmin_confs\x18\x0b\x20\
    \x01(\x05R\x08minConfs\x12+\n\x11spend_unconfirmed\x18\x0c\x20\x01(\x08R\
    \x10spendUnconfirmed\x12#\n\rclose_address\x18\r\x20\x01(\tR\x0ccloseAdd\
    ress\x125\n\x0cfunding_shim\x18\x0e\x20\x01(\x0b2\x12.lnrpc.FundingShimR\
    \x0bfundingShim\x12C\n\x1fremote_max_value_in_flight_msat\x18\x0f\x20\
    \x01(\x04R\x1aremoteMaxValueInFlightMsat\x12(\n\x10remote_max_htlcs\x18\
    \x10\x20\x01(\rR\x0eremoteMaxHtlcs\x12\"\n\rmax_local_csv\x18\x11\x20\
    \x01(\rR\x0bmaxLocalCsv\"\xf3\x01\n\x10OpenStatusUpdate\x129\n\x0cchan_p\
    ending\x18\x01\x20\x01(\x0b2\x14.lnrpc.PendingUpdateH\0R\x0bchanPending\
    \x127\n\tchan_open\x18\x03\x20\x01(\x0b2\x18.lnrpc.ChannelOpenUpdateH\0R\
    \x08chanOpen\x129\n\tpsbt_fund\x18\x05\x20\x01(\x0b2\x1a.lnrpc.ReadyForP\
    sbtFundingH\0R\x08psbtFund\x12&\n\x0fpending_chan_id\x18\x04\x20\x01(\
    \x0cR\rpendingChanIdB\x08\n\x06update\"H\n\nKeyLocator\x12\x1d\n\nkey_fa\
    mily\x18\x01\x20\x01(\x05R\tkeyFamily\x12\x1b\n\tkey_index\x18\x02\x20\
    \x01(\x05R\x08keyIndex\"_\n\rKeyDescriptor\x12\"\n\rraw_key_bytes\x18\
    \x01\x20\x01(\x0cR\x0brawKeyBytes\x12*\n\x07key_loc\x18\x02\x20\x01(\x0b\
    2\x11.lnrpc.KeyLocatorR\x06keyLoc\"\xf0\x01\n\rChanPointShim\x12\x10\n\
    \x03amt\x18\x01\x20\x01(\x03R\x03amt\x122\n\nchan_point\x18\x02\x20\x01(\
    \x0b2\x13.lnrpc.ChannelPointR\tchanPoint\x121\n\tlocal_key\x18\x03\x20\
    \x01(\x0b2\x14.lnrpc.KeyDescriptorR\x08localKey\x12\x1d\n\nremote_key\
    \x18\x04\x20\x01(\x0cR\tremoteKey\x12&\n\x0fpending_chan_id\x18\x05\x20\
    \x01(\x0cR\rpendingChanId\x12\x1f\n\x0bthaw_height\x18\x06\x20\x01(\rR\n\
    thawHeight\"n\n\x08PsbtShim\x12&\n\x0fpending_chan_id\x18\x01\x20\x01(\
    \x0cR\rpendingChanId\x12\x1b\n\tbase_psbt\x18\x02\x20\x01(\x0cR\x08baseP\
    sbt\x12\x1d\n\nno_publish\x18\x03\x20\x01(\x08R\tnoPublish\"\x85\x01\n\
    \x0bFundingShim\x12>\n\x0fchan_point_shim\x18\x01\x20\x01(\x0b2\x14.lnrp\
    c.ChanPointShimH\0R\rchanPointShim\x12.\n\tpsbt_shim\x18\x02\x20\x01(\
    \x0b2\x0f.lnrpc.PsbtShimH\0R\x08psbtShimB\x06\n\x04shim\";\n\x11FundingS\
    himCancel\x12&\n\x0fpending_chan_id\x18\x01\x20\x01(\x0cR\rpendingChanId\
    \"\\\n\x11FundingPsbtVerify\x12\x1f\n\x0bfunded_psbt\x18\x01\x20\x01(\
    \x0cR\nfundedPsbt\x12&\n\x0fpending_chan_id\x18\x02\x20\x01(\x0cR\rpendi\
    ngChanId\"\x80\x01\n\x13FundingPsbtFinalize\x12\x1f\n\x0bsigned_psbt\x18\
    \x01\x20\x01(\x0cR\nsignedPsbt\x12&\n\x0fpending_chan_id\x18\x02\x20\x01\
    (\x0cR\rpendingChanId\x12\x20\n\x0cfinal_raw_tx\x18\x03\x20\x01(\x0cR\nf\
    inalRawTx\"\x99\x02\n\x14FundingTransitionMsg\x129\n\rshim_register\x18\
    \x01\x20\x01(\x0b2\x12.lnrpc.FundingShimH\0R\x0cshimRegister\x12;\n\x0bs\
    him_cancel\x18\x02\x20\x01(\x0b2\x18.lnrpc.FundingShimCancelH\0R\nshimCa\
    ncel\x12;\n\x0bpsbt_verify\x18\x03\x20\x01(\x0b2\x18.lnrpc.FundingPsbtVe\
    rifyH\0R\npsbtVerify\x12A\n\rpsbt_finalize\x18\x04\x20\x01(\x0b2\x1a.lnr\
    pc.FundingPsbtFinalizeH\0R\x0cpsbtFinalizeB\t\n\x07trigger\"\x16\n\x14Fu\
    ndingStateStepResp\"\xcc\x01\n\x0bPendingHTLC\x12\x1a\n\x08incoming\x18\
    \x01\x20\x01(\x08R\x08incoming\x12\x16\n\x06amount\x18\x02\x20\x01(\x03R\
    \x06amount\x12\x1a\n\x08outpoint\x18\x03\x20\x01(\tR\x08outpoint\x12'\n\
    \x0fmaturity_height\x18\x04\x20\x01(\rR\x0ematurityHeight\x12.\n\x13bloc\
    ks_til_maturity\x18\x05\x20\x01(\x05R\x11blocksTilMaturity\x12\x14\n\x05\
    stage\x18\x06\x20\x01(\rR\x05stage\"\x18\n\x16PendingChannelsRequest\"\
    \xfd\x11\n\x17PendingChannelsResponse\x12.\n\x13total_limbo_balance\x18\
    \x01\x20\x01(\x03R\x11totalLimboBalance\x12e\n\x15pending_open_channels\
    \x18\x02\x20\x03(\x0b21.lnrpc.PendingChannelsResponse.PendingOpenChannel\
    R\x13pendingOpenChannels\x12j\n\x18pending_closing_channels\x18\x03\x20\
    \x03(\x0b2,.lnrpc.PendingChannelsResponse.ClosedChannelR\x16pendingClosi\
    ngChannelsB\x02\x18\x01\x12v\n\x1epending_force_closing_channels\x18\x04\
    \x20\x03(\x0b21.lnrpc.PendingChannelsResponse.ForceClosedChannelR\x1bpen\
    dingForceClosingChannels\x12h\n\x16waiting_close_channels\x18\x05\x20\
    \x03(\x0b22.lnrpc.PendingChannelsResponse.WaitingCloseChannelR\x14waitin\
    gCloseChannels\x1a\xa1\x03\n\x0ePendingChannel\x12&\n\x0fremote_node_pub\
    \x18\x01\x20\x01(\tR\rremoteNodePub\x12#\n\rchannel_point\x18\x02\x20\
    \x01(\tR\x0cchannelPoint\x12\x1a\n\x08capacity\x18\x03\x20\x01(\x03R\x08\
    capacity\x12#\n\rlocal_balance\x18\x04\x20\x01(\x03R\x0clocalBalance\x12\
    %\n\x0eremote_balance\x18\x05\x20\x01(\x03R\rremoteBalance\x123\n\x16loc\
    al_chan_reserve_sat\x18\x06\x20\x01(\x03R\x13localChanReserveSat\x125\n\
    \x17remote_chan_reserve_sat\x18\x07\x20\x01(\x03R\x14remoteChanReserveSa\
    t\x12.\n\tinitiator\x18\x08\x20\x01(\x0e2\x10.lnrpc.InitiatorR\tinitiato\
    r\x12>\n\x0fcommitment_type\x18\t\x20\x01(\x0e2\x15.lnrpc.CommitmentType\
    R\x0ecommitmentType\x1a\xf0\x01\n\x12PendingOpenChannel\x12G\n\x07channe\
    l\x18\x01\x20\x01(\x0b2-.lnrpc.PendingChannelsResponse.PendingChannelR\
    \x07channel\x12/\n\x13confirmation_height\x18\x02\x20\x01(\rR\x12confirm\
    ationHeight\x12\x1d\n\ncommit_fee\x18\x04\x20\x01(\x03R\tcommitFee\x12#\
    \n\rcommit_weight\x18\x05\x20\x01(\x03R\x0ccommitWeight\x12\x1c\n\nfee_p\
    er_kw\x18\x06\x20\x01(\x03R\x08feePerKw\x1a\xd1\x01\n\x13WaitingCloseCha\
    nnel\x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.PendingChannelsRespo\
    nse.PendingChannelR\x07channel\x12#\n\rlimbo_balance\x18\x02\x20\x01(\
    \x03R\x0climboBalance\x12L\n\x0bcommitments\x18\x03\x20\x01(\x0b2*.lnrpc\
    .PendingChannelsResponse.CommitmentsR\x0bcommitments\x1a\xa3\x02\n\x0bCo\
    mmitments\x12\x1d\n\nlocal_txid\x18\x01\x20\x01(\tR\tlocalTxid\x12\x1f\n\
    \x0bremote_txid\x18\x02\x20\x01(\tR\nremoteTxid\x12.\n\x13remote_pending\
    _txid\x18\x03\x20\x01(\tR\x11remotePendingTxid\x12/\n\x14local_commit_fe\
    e_sat\x18\x04\x20\x01(\x04R\x11localCommitFeeSat\x121\n\x15remote_commit\
    _fee_sat\x18\x05\x20\x01(\x04R\x12remoteCommitFeeSat\x12@\n\x1dremote_pe\
    nding_commit_fee_sat\x18\x06\x20\x01(\x04R\x19remotePendingCommitFeeSat\
    \x1a{\n\rClosedChannel\x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.Pe\
    ndingChannelsResponse.PendingChannelR\x07channel\x12!\n\x0cclosing_txid\
    \x18\x02\x20\x01(\tR\x0bclosingTxid\x1a\xee\x03\n\x12ForceClosedChannel\
    \x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.PendingChannelsResponse.\
    PendingChannelR\x07channel\x12!\n\x0cclosing_txid\x18\x02\x20\x01(\tR\
    \x0bclosingTxid\x12#\n\rlimbo_balance\x18\x03\x20\x01(\x03R\x0climboBala\
    nce\x12'\n\x0fmaturity_height\x18\x04\x20\x01(\rR\x0ematurityHeight\x12.\
    \n\x13blocks_til_maturity\x18\x05\x20\x01(\x05R\x11blocksTilMaturity\x12\
    +\n\x11recovered_balance\x18\x06\x20\x01(\x03R\x10recoveredBalance\x127\
    \n\rpending_htlcs\x18\x08\x20\x03(\x0b2\x12.lnrpc.PendingHTLCR\x0cpendin\
    gHtlcs\x12U\n\x06anchor\x18\t\x20\x01(\x0e2=.lnrpc.PendingChannelsRespon\
    se.ForceClosedChannel.AnchorStateR\x06anchor\"1\n\x0bAnchorState\x12\t\n\
    \x05LIMBO\x10\0\x12\r\n\tRECOVERED\x10\x01\x12\x08\n\x04LOST\x10\x02\"\
    \x1a\n\x18ChannelEventSubscription\"\x95\x04\n\x12ChannelEventUpdate\x12\
    3\n\x0copen_channel\x18\x01\x20\x01(\x0b2\x0e.lnrpc.ChannelH\0R\x0bopenC\
    hannel\x12C\n\x0eclosed_channel\x18\x02\x20\x01(\x0b2\x1a.lnrpc.ChannelC\
    loseSummaryH\0R\rclosedChannel\x12<\n\x0eactive_channel\x18\x03\x20\x01(\
    \x0b2\x13.lnrpc.ChannelPointH\0R\ractiveChannel\x12@\n\x10inactive_chann\
    el\x18\x04\x20\x01(\x0b2\x13.lnrpc.ChannelPointH\0R\x0finactiveChannel\
    \x12H\n\x14pending_open_channel\x18\x06\x20\x01(\x0b2\x14.lnrpc.PendingU\
    pdateH\0R\x12pendingOpenChannel\x128\n\x04type\x18\x05\x20\x01(\x0e2$.ln\
    rpc.ChannelEventUpdate.UpdateTypeR\x04type\"v\n\nUpdateType\x12\x10\n\
    \x0cOPEN_CHANNEL\x10\0\x12\x12\n\x0eCLOSED_CHANNEL\x10\x01\x12\x12\n\x0e\
    ACTIVE_CHANNEL\x10\x02\x12\x14\n\x10INACTIVE_CHANNEL\x10\x03\x12\x18\n\
    \x14PENDING_OPEN_CHANNEL\x10\x04B\t\n\x07channel\"t\n\x14WalletAccountBa\
    lance\x12+\n\x11confirmed_balance\x18\x01\x20\x01(\x03R\x10confirmedBala\
    nce\x12/\n\x13unconfirmed_balance\x18\x02\x20\x01(\x03R\x12unconfirmedBa\
    lance\"\x16\n\x14WalletBalanceRequest\"\xd5\x02\n\x15WalletBalanceRespon\
    se\x12#\n\rtotal_balance\x18\x01\x20\x01(\x03R\x0ctotalBalance\x12+\n\
    \x11confirmed_balance\x18\x02\x20\x01(\x03R\x10confirmedBalance\x12/\n\
    \x13unconfirmed_balance\x18\x03\x20\x01(\x03R\x12unconfirmedBalance\x12Y\
    \n\x0faccount_balance\x18\x04\x20\x03(\x0b20.lnrpc.WalletBalanceResponse\
    .AccountBalanceEntryR\x0eaccountBalance\x1a^\n\x13AccountBalanceEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x121\n\x05value\x18\x02\x20\
    \x01(\x0b2\x1b.lnrpc.WalletAccountBalanceR\x05value:\x028\x01\".\n\x06Am\
    ount\x12\x10\n\x03sat\x18\x01\x20\x01(\x04R\x03sat\x12\x12\n\x04msat\x18\
    \x02\x20\x01(\x04R\x04msat\"\x17\n\x15ChannelBalanceRequest\"\x80\x04\n\
    \x16ChannelBalanceResponse\x12\x1c\n\x07balance\x18\x01\x20\x01(\x03R\
    \x07balanceB\x02\x18\x01\x124\n\x14pending_open_balance\x18\x02\x20\x01(\
    \x03R\x12pendingOpenBalanceB\x02\x18\x01\x122\n\rlocal_balance\x18\x03\
    \x20\x01(\x0b2\r.lnrpc.AmountR\x0clocalBalance\x124\n\x0eremote_balance\
    \x18\x04\x20\x01(\x0b2\r.lnrpc.AmountR\rremoteBalance\x12E\n\x17unsettle\
    d_local_balance\x18\x05\x20\x01(\x0b2\r.lnrpc.AmountR\x15unsettledLocalB\
    alance\x12G\n\x18unsettled_remote_balance\x18\x06\x20\x01(\x0b2\r.lnrpc.\
    AmountR\x16unsettledRemoteBalance\x12J\n\x1apending_open_local_balance\
    \x18\x07\x20\x01(\x0b2\r.lnrpc.AmountR\x17pendingOpenLocalBalance\x12L\n\
    \x1bpending_open_remote_balance\x18\x08\x20\x01(\x0b2\r.lnrpc.AmountR\
    \x18pendingOpenRemoteBalance\"\xae\x06\n\x12QueryRoutesRequest\x12\x17\n\
    \x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\x12\x10\n\x03amt\x18\x02\x20\
    \x01(\x03R\x03amt\x12\x19\n\x08amt_msat\x18\x0c\x20\x01(\x03R\x07amtMsat\
    \x12(\n\x10final_cltv_delta\x18\x04\x20\x01(\x05R\x0efinalCltvDelta\x12,\
    \n\tfee_limit\x18\x05\x20\x01(\x0b2\x0f.lnrpc.FeeLimitR\x08feeLimit\x12#\
    \n\rignored_nodes\x18\x06\x20\x03(\x0cR\x0cignoredNodes\x12;\n\rignored_\
    edges\x18\x07\x20\x03(\x0b2\x12.lnrpc.EdgeLocatorR\x0cignoredEdgesB\x02\
    \x18\x01\x12$\n\x0esource_pub_key\x18\x08\x20\x01(\tR\x0csourcePubKey\
    \x12.\n\x13use_mission_control\x18\t\x20\x01(\x08R\x11useMissionControl\
    \x124\n\rignored_pairs\x18\n\x20\x03(\x0b2\x0f.lnrpc.NodePairR\x0cignore\
    dPairs\x12\x1d\n\ncltv_limit\x18\x0b\x20\x01(\rR\tcltvLimit\x12`\n\x13de\
    st_custom_records\x18\r\x20\x03(\x0b20.lnrpc.QueryRoutesRequest.DestCust\
    omRecordsEntryR\x11destCustomRecords\x12,\n\x10outgoing_chan_id\x18\x0e\
    \x20\x01(\x04R\x0eoutgoingChanIdB\x020\x01\x12&\n\x0flast_hop_pubkey\x18\
    \x0f\x20\x01(\x0cR\rlastHopPubkey\x121\n\x0broute_hints\x18\x10\x20\x03(\
    \x0b2\x10.lnrpc.RouteHintR\nrouteHints\x126\n\rdest_features\x18\x11\x20\
    \x03(\x0e2\x11.lnrpc.FeatureBitR\x0cdestFeatures\x1aD\n\x16DestCustomRec\
    ordsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\x0cR\x05value:\x028\x01J\x04\x08\x03\x10\x04\".\n\
    \x08NodePair\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\x04from\x12\x0e\n\
    \x02to\x18\x02\x20\x01(\x0cR\x02to\"]\n\x0bEdgeLocator\x12!\n\nchannel_i\
    d\x18\x01\x20\x01(\x04R\tchannelIdB\x020\x01\x12+\n\x11direction_reverse\
    \x18\x02\x20\x01(\x08R\x10directionReverse\"^\n\x13QueryRoutesResponse\
    \x12$\n\x06routes\x18\x01\x20\x03(\x0b2\x0c.lnrpc.RouteR\x06routes\x12!\
    \n\x0csuccess_prob\x18\x02\x20\x01(\x01R\x0bsuccessProb\"\x91\x04\n\x03H\
    op\x12\x1b\n\x07chan_id\x18\x01\x20\x01(\x04R\x06chanIdB\x020\x01\x12'\n\
    \rchan_capacity\x18\x02\x20\x01(\x03R\x0cchanCapacityB\x02\x18\x01\x12(\
    \n\x0eamt_to_forward\x18\x03\x20\x01(\x03R\x0camtToForwardB\x02\x18\x01\
    \x12\x14\n\x03fee\x18\x04\x20\x01(\x03R\x03feeB\x02\x18\x01\x12\x16\n\
    \x06expiry\x18\x05\x20\x01(\rR\x06expiry\x12-\n\x13amt_to_forward_msat\
    \x18\x06\x20\x01(\x03R\x10amtToForwardMsat\x12\x19\n\x08fee_msat\x18\x07\
    \x20\x01(\x03R\x07feeMsat\x12\x17\n\x07pub_key\x18\x08\x20\x01(\tR\x06pu\
    bKey\x12\x1f\n\x0btlv_payload\x18\t\x20\x01(\x08R\ntlvPayload\x12/\n\nmp\
    p_record\x18\n\x20\x01(\x0b2\x10.lnrpc.MPPRecordR\tmppRecord\x12/\n\namp\
    _record\x18\x0c\x20\x01(\x0b2\x10.lnrpc.AMPRecordR\tampRecord\x12D\n\x0e\
    custom_records\x18\x0b\x20\x03(\x0b2\x1d.lnrpc.Hop.CustomRecordsEntryR\r\
    customRecords\x1a@\n\x12CustomRecordsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x04R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x02\
    8\x01\"T\n\tMPPRecord\x12!\n\x0cpayment_addr\x18\x0b\x20\x01(\x0cR\x0bpa\
    ymentAddr\x12$\n\x0etotal_amt_msat\x18\n\x20\x01(\x03R\x0ctotalAmtMsat\"\
    b\n\tAMPRecord\x12\x1d\n\nroot_share\x18\x01\x20\x01(\x0cR\trootShare\
    \x12\x15\n\x06set_id\x18\x02\x20\x01(\x0cR\x05setId\x12\x1f\n\x0bchild_i\
    ndex\x18\x03\x20\x01(\rR\nchildIndex\"\xe1\x01\n\x05Route\x12&\n\x0ftota\
    l_time_lock\x18\x01\x20\x01(\rR\rtotalTimeLock\x12!\n\ntotal_fees\x18\
    \x02\x20\x01(\x03R\ttotalFeesB\x02\x18\x01\x12\x1f\n\ttotal_amt\x18\x03\
    \x20\x01(\x03R\x08totalAmtB\x02\x18\x01\x12\x1e\n\x04hops\x18\x04\x20\
    \x03(\x0b2\n.lnrpc.HopR\x04hops\x12&\n\x0ftotal_fees_msat\x18\x05\x20\
    \x01(\x03R\rtotalFeesMsat\x12$\n\x0etotal_amt_msat\x18\x06\x20\x01(\x03R\
    \x0ctotalAmtMsat\"U\n\x0fNodeInfoRequest\x12\x17\n\x07pub_key\x18\x01\
    \x20\x01(\tR\x06pubKey\x12)\n\x10include_channels\x18\x02\x20\x01(\x08R\
    \x0fincludeChannels\"\xae\x01\n\x08NodeInfo\x12(\n\x04node\x18\x01\x20\
    \x01(\x0b2\x14.lnrpc.LightningNodeR\x04node\x12!\n\x0cnum_channels\x18\
    \x02\x20\x01(\rR\x0bnumChannels\x12%\n\x0etotal_capacity\x18\x03\x20\x01\
    (\x03R\rtotalCapacity\x12.\n\x08channels\x18\x04\x20\x03(\x0b2\x12.lnrpc\
    .ChannelEdgeR\x08channels\"\xb4\x02\n\rLightningNode\x12\x1f\n\x0blast_u\
    pdate\x18\x01\x20\x01(\rR\nlastUpdate\x12\x17\n\x07pub_key\x18\x02\x20\
    \x01(\tR\x06pubKey\x12\x14\n\x05alias\x18\x03\x20\x01(\tR\x05alias\x120\
    \n\taddresses\x18\x04\x20\x03(\x0b2\x12.lnrpc.NodeAddressR\taddresses\
    \x12\x14\n\x05color\x18\x05\x20\x01(\tR\x05color\x12>\n\x08features\x18\
    \x06\x20\x03(\x0b2\".lnrpc.LightningNode.FeaturesEntryR\x08features\x1aK\
    \n\rFeaturesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12$\n\x05\
    value\x18\x02\x20\x01(\x0b2\x0e.lnrpc.FeatureR\x05value:\x028\x01\";\n\
    \x0bNodeAddress\x12\x18\n\x07network\x18\x01\x20\x01(\tR\x07network\x12\
    \x12\n\x04addr\x18\x02\x20\x01(\tR\x04addr\"\x86\x02\n\rRoutingPolicy\
    \x12&\n\x0ftime_lock_delta\x18\x01\x20\x01(\rR\rtimeLockDelta\x12\x19\n\
    \x08min_htlc\x18\x02\x20\x01(\x03R\x07minHtlc\x12\"\n\rfee_base_msat\x18\
    \x03\x20\x01(\x03R\x0bfeeBaseMsat\x12-\n\x13fee_rate_milli_msat\x18\x04\
    \x20\x01(\x03R\x10feeRateMilliMsat\x12\x1a\n\x08disabled\x18\x05\x20\x01\
    (\x08R\x08disabled\x12\"\n\rmax_htlc_msat\x18\x06\x20\x01(\x04R\x0bmaxHt\
    lcMsat\x12\x1f\n\x0blast_update\x18\x07\x20\x01(\rR\nlastUpdate\"\xbc\
    \x02\n\x0bChannelEdge\x12!\n\nchannel_id\x18\x01\x20\x01(\x04R\tchannelI\
    dB\x020\x01\x12\x1d\n\nchan_point\x18\x02\x20\x01(\tR\tchanPoint\x12#\n\
    \x0blast_update\x18\x03\x20\x01(\rR\nlastUpdateB\x02\x18\x01\x12\x1b\n\t\
    node1_pub\x18\x04\x20\x01(\tR\x08node1Pub\x12\x1b\n\tnode2_pub\x18\x05\
    \x20\x01(\tR\x08node2Pub\x12\x1a\n\x08capacity\x18\x06\x20\x01(\x03R\x08\
    capacity\x127\n\x0cnode1_policy\x18\x07\x20\x01(\x0b2\x14.lnrpc.RoutingP\
    olicyR\x0bnode1Policy\x127\n\x0cnode2_policy\x18\x08\x20\x01(\x0b2\x14.l\
    nrpc.RoutingPolicyR\x0bnode2Policy\"F\n\x13ChannelGraphRequest\x12/\n\
    \x13include_unannounced\x18\x01\x20\x01(\x08R\x12includeUnannounced\"d\n\
    \x0cChannelGraph\x12*\n\x05nodes\x18\x01\x20\x03(\x0b2\x14.lnrpc.Lightni\
    ngNodeR\x05nodes\x12(\n\x05edges\x18\x02\x20\x03(\x0b2\x12.lnrpc.Channel\
    EdgeR\x05edges\"A\n\x12NodeMetricsRequest\x12+\n\x05types\x18\x01\x20\
    \x03(\x0e2\x15.lnrpc.NodeMetricTypeR\x05types\"\xe1\x01\n\x13NodeMetrics\
    Response\x12l\n\x16betweenness_centrality\x18\x01\x20\x03(\x0b25.lnrpc.N\
    odeMetricsResponse.BetweennessCentralityEntryR\x15betweennessCentrality\
    \x1a\\\n\x1aBetweennessCentralityEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.lnrpc.FloatMetricR\
    \x05value:\x028\x01\"N\n\x0bFloatMetric\x12\x14\n\x05value\x18\x01\x20\
    \x01(\x01R\x05value\x12)\n\x10normalized_value\x18\x02\x20\x01(\x01R\x0f\
    normalizedValue\".\n\x0fChanInfoRequest\x12\x1b\n\x07chan_id\x18\x01\x20\
    \x01(\x04R\x06chanIdB\x020\x01\"\x14\n\x12NetworkInfoRequest\"\xd5\x03\n\
    \x0bNetworkInfo\x12%\n\x0egraph_diameter\x18\x01\x20\x01(\rR\rgraphDiame\
    ter\x12$\n\x0eavg_out_degree\x18\x02\x20\x01(\x01R\x0cavgOutDegree\x12$\
    \n\x0emax_out_degree\x18\x03\x20\x01(\rR\x0cmaxOutDegree\x12\x1b\n\tnum_\
    nodes\x18\x04\x20\x01(\rR\x08numNodes\x12!\n\x0cnum_channels\x18\x05\x20\
    \x01(\rR\x0bnumChannels\x124\n\x16total_network_capacity\x18\x06\x20\x01\
    (\x03R\x14totalNetworkCapacity\x12(\n\x10avg_channel_size\x18\x07\x20\
    \x01(\x01R\x0eavgChannelSize\x12(\n\x10min_channel_size\x18\x08\x20\x01(\
    \x03R\x0eminChannelSize\x12(\n\x10max_channel_size\x18\t\x20\x01(\x03R\
    \x0emaxChannelSize\x125\n\x17median_channel_size_sat\x18\n\x20\x01(\x03R\
    \x14medianChannelSizeSat\x12(\n\x10num_zombie_chans\x18\x0b\x20\x01(\x04\
    R\x0enumZombieChans\"\r\n\x0bStopRequest\"\x0e\n\x0cStopResponse\"\x1b\n\
    \x19GraphTopologySubscription\"\xcd\x01\n\x13GraphTopologyUpdate\x124\n\
    \x0cnode_updates\x18\x01\x20\x03(\x0b2\x11.lnrpc.NodeUpdateR\x0bnodeUpda\
    tes\x12A\n\x0fchannel_updates\x18\x02\x20\x03(\x0b2\x18.lnrpc.ChannelEdg\
    eUpdateR\x0echannelUpdates\x12=\n\x0cclosed_chans\x18\x03\x20\x03(\x0b2\
    \x1a.lnrpc.ClosedChannelUpdateR\x0bclosedChans\"\xef\x02\n\nNodeUpdate\
    \x12\x20\n\taddresses\x18\x01\x20\x03(\tR\taddressesB\x02\x18\x01\x12!\n\
    \x0cidentity_key\x18\x02\x20\x01(\tR\x0bidentityKey\x12+\n\x0fglobal_fea\
    tures\x18\x03\x20\x01(\x0cR\x0eglobalFeaturesB\x02\x18\x01\x12\x14\n\x05\
    alias\x18\x04\x20\x01(\tR\x05alias\x12\x14\n\x05color\x18\x05\x20\x01(\t\
    R\x05color\x129\n\x0enode_addresses\x18\x07\x20\x03(\x0b2\x12.lnrpc.Node\
    AddressR\rnodeAddresses\x12;\n\x08features\x18\x06\x20\x03(\x0b2\x1f.lnr\
    pc.NodeUpdate.FeaturesEntryR\x08features\x1aK\n\rFeaturesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\rR\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\
    \x0e.lnrpc.FeatureR\x05value:\x028\x01\"\x91\x02\n\x11ChannelEdgeUpdate\
    \x12\x1b\n\x07chan_id\x18\x01\x20\x01(\x04R\x06chanIdB\x020\x01\x122\n\n\
    chan_point\x18\x02\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tchanPoint\x12\
    \x1a\n\x08capacity\x18\x03\x20\x01(\x03R\x08capacity\x12;\n\x0erouting_p\
    olicy\x18\x04\x20\x01(\x0b2\x14.lnrpc.RoutingPolicyR\rroutingPolicy\x12)\
    \n\x10advertising_node\x18\x05\x20\x01(\tR\x0fadvertisingNode\x12'\n\x0f\
    connecting_node\x18\x06\x20\x01(\tR\x0econnectingNode\"\xa7\x01\n\x13Clo\
    sedChannelUpdate\x12\x1b\n\x07chan_id\x18\x01\x20\x01(\x04R\x06chanIdB\
    \x020\x01\x12\x1a\n\x08capacity\x18\x02\x20\x01(\x03R\x08capacity\x12#\n\
    \rclosed_height\x18\x03\x20\x01(\rR\x0cclosedHeight\x122\n\nchan_point\
    \x18\x04\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tchanPoint\"\xcf\x01\n\
    \x07HopHint\x12\x17\n\x07node_id\x18\x01\x20\x01(\tR\x06nodeId\x12\x1b\n\
    \x07chan_id\x18\x02\x20\x01(\x04R\x06chanIdB\x020\x01\x12\"\n\rfee_base_\
    msat\x18\x03\x20\x01(\rR\x0bfeeBaseMsat\x12>\n\x1bfee_proportional_milli\
    onths\x18\x04\x20\x01(\rR\x19feeProportionalMillionths\x12*\n\x11cltv_ex\
    piry_delta\x18\x05\x20\x01(\rR\x0fcltvExpiryDelta\"8\n\tRouteHint\x12+\n\
    \thop_hints\x18\x01\x20\x03(\x0b2\x0e.lnrpc.HopHintR\x08hopHints\"\x96\
    \x08\n\x07Invoice\x12\x12\n\x04memo\x18\x01\x20\x01(\tR\x04memo\x12\x1d\
    \n\nr_preimage\x18\x03\x20\x01(\x0cR\trPreimage\x12\x15\n\x06r_hash\x18\
    \x04\x20\x01(\x0cR\x05rHash\x12\x14\n\x05value\x18\x05\x20\x01(\x03R\x05\
    value\x12\x1d\n\nvalue_msat\x18\x17\x20\x01(\x03R\tvalueMsat\x12\x1c\n\
    \x07settled\x18\x06\x20\x01(\x08R\x07settledB\x02\x18\x01\x12#\n\rcreati\
    on_date\x18\x07\x20\x01(\x03R\x0ccreationDate\x12\x1f\n\x0bsettle_date\
    \x18\x08\x20\x01(\x03R\nsettleDate\x12'\n\x0fpayment_request\x18\t\x20\
    \x01(\tR\x0epaymentRequest\x12)\n\x10description_hash\x18\n\x20\x01(\x0c\
    R\x0fdescriptionHash\x12\x16\n\x06expiry\x18\x0b\x20\x01(\x03R\x06expiry\
    \x12#\n\rfallback_addr\x18\x0c\x20\x01(\tR\x0cfallbackAddr\x12\x1f\n\x0b\
    cltv_expiry\x18\r\x20\x01(\x04R\ncltvExpiry\x121\n\x0broute_hints\x18\
    \x0e\x20\x03(\x0b2\x10.lnrpc.RouteHintR\nrouteHints\x12\x18\n\x07private\
    \x18\x0f\x20\x01(\x08R\x07private\x12\x1b\n\tadd_index\x18\x10\x20\x01(\
    \x04R\x08addIndex\x12!\n\x0csettle_index\x18\x11\x20\x01(\x04R\x0bsettle\
    Index\x12\x1d\n\x08amt_paid\x18\x12\x20\x01(\x03R\x07amtPaidB\x02\x18\
    \x01\x12\x20\n\x0camt_paid_sat\x18\x13\x20\x01(\x03R\namtPaidSat\x12\"\n\
    \ramt_paid_msat\x18\x14\x20\x01(\x03R\x0bamtPaidMsat\x121\n\x05state\x18\
    \x15\x20\x01(\x0e2\x1b.lnrpc.Invoice.InvoiceStateR\x05state\x12(\n\x05ht\
    lcs\x18\x16\x20\x03(\x0b2\x12.lnrpc.InvoiceHTLCR\x05htlcs\x128\n\x08feat\
    ures\x18\x18\x20\x03(\x0b2\x1c.lnrpc.Invoice.FeaturesEntryR\x08features\
    \x12\x1d\n\nis_keysend\x18\x19\x20\x01(\x08R\tisKeysend\x12!\n\x0cpaymen\
    t_addr\x18\x1a\x20\x01(\x0cR\x0bpaymentAddr\x12\x15\n\x06is_amp\x18\x1b\
    \x20\x01(\x08R\x05isAmp\x1aK\n\rFeaturesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\rR\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\x0e.lnrpc.Feat\
    ureR\x05value:\x028\x01\"A\n\x0cInvoiceState\x12\x08\n\x04OPEN\x10\0\x12\
    \x0b\n\x07SETTLED\x10\x01\x12\x0c\n\x08CANCELED\x10\x02\x12\x0c\n\x08ACC\
    EPTED\x10\x03J\x04\x08\x02\x10\x03\"\xfc\x03\n\x0bInvoiceHTLC\x12\x1b\n\
    \x07chan_id\x18\x01\x20\x01(\x04R\x06chanIdB\x020\x01\x12\x1d\n\nhtlc_in\
    dex\x18\x02\x20\x01(\x04R\thtlcIndex\x12\x19\n\x08amt_msat\x18\x03\x20\
    \x01(\x04R\x07amtMsat\x12#\n\raccept_height\x18\x04\x20\x01(\x05R\x0cacc\
    eptHeight\x12\x1f\n\x0baccept_time\x18\x05\x20\x01(\x03R\nacceptTime\x12\
    !\n\x0cresolve_time\x18\x06\x20\x01(\x03R\x0bresolveTime\x12#\n\rexpiry_\
    height\x18\x07\x20\x01(\x05R\x0cexpiryHeight\x12-\n\x05state\x18\x08\x20\
    \x01(\x0e2\x17.lnrpc.InvoiceHTLCStateR\x05state\x12L\n\x0ecustom_records\
    \x18\t\x20\x03(\x0b2%.lnrpc.InvoiceHTLC.CustomRecordsEntryR\rcustomRecor\
    ds\x12+\n\x12mpp_total_amt_msat\x18\n\x20\x01(\x04R\x0fmppTotalAmtMsat\
    \x12\x1c\n\x03amp\x18\x0b\x20\x01(\x0b2\n.lnrpc.AMPR\x03amp\x1a@\n\x12Cu\
    stomRecordsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\"\x8c\x01\n\x03AMP\
    \x12\x1d\n\nroot_share\x18\x01\x20\x01(\x0cR\trootShare\x12\x15\n\x06set\
    _id\x18\x02\x20\x01(\x0cR\x05setId\x12\x1f\n\x0bchild_index\x18\x03\x20\
    \x01(\rR\nchildIndex\x12\x12\n\x04hash\x18\x04\x20\x01(\x0cR\x04hash\x12\
    \x1a\n\x08preimage\x18\x05\x20\x01(\x0cR\x08preimage\"\x94\x01\n\x12AddI\
    nvoiceResponse\x12\x15\n\x06r_hash\x18\x01\x20\x01(\x0cR\x05rHash\x12'\n\
    \x0fpayment_request\x18\x02\x20\x01(\tR\x0epaymentRequest\x12\x1b\n\tadd\
    _index\x18\x10\x20\x01(\x04R\x08addIndex\x12!\n\x0cpayment_addr\x18\x11\
    \x20\x01(\x0cR\x0bpaymentAddr\"F\n\x0bPaymentHash\x12\x20\n\nr_hash_str\
    \x18\x01\x20\x01(\tR\x08rHashStrB\x02\x18\x01\x12\x15\n\x06r_hash\x18\
    \x02\x20\x01(\x0cR\x05rHash\"\xa0\x01\n\x12ListInvoiceRequest\x12!\n\x0c\
    pending_only\x18\x01\x20\x01(\x08R\x0bpendingOnly\x12!\n\x0cindex_offset\
    \x18\x04\x20\x01(\x04R\x0bindexOffset\x12(\n\x10num_max_invoices\x18\x05\
    \x20\x01(\x04R\x0enumMaxInvoices\x12\x1a\n\x08reversed\x18\x06\x20\x01(\
    \x08R\x08reversed\"\x9b\x01\n\x13ListInvoiceResponse\x12*\n\x08invoices\
    \x18\x01\x20\x03(\x0b2\x0e.lnrpc.InvoiceR\x08invoices\x12*\n\x11last_ind\
    ex_offset\x18\x02\x20\x01(\x04R\x0flastIndexOffset\x12,\n\x12first_index\
    _offset\x18\x03\x20\x01(\x04R\x10firstIndexOffset\"U\n\x13InvoiceSubscri\
    ption\x12\x1b\n\tadd_index\x18\x01\x20\x01(\x04R\x08addIndex\x12!\n\x0cs\
    ettle_index\x18\x02\x20\x01(\x04R\x0bsettleIndex\"\x8a\x05\n\x07Payment\
    \x12!\n\x0cpayment_hash\x18\x01\x20\x01(\tR\x0bpaymentHash\x12\x18\n\x05\
    value\x18\x02\x20\x01(\x03R\x05valueB\x02\x18\x01\x12'\n\rcreation_date\
    \x18\x03\x20\x01(\x03R\x0ccreationDateB\x02\x18\x01\x12\x14\n\x03fee\x18\
    \x05\x20\x01(\x03R\x03feeB\x02\x18\x01\x12)\n\x10payment_preimage\x18\
    \x06\x20\x01(\tR\x0fpaymentPreimage\x12\x1b\n\tvalue_sat\x18\x07\x20\x01\
    (\x03R\x08valueSat\x12\x1d\n\nvalue_msat\x18\x08\x20\x01(\x03R\tvalueMsa\
    t\x12'\n\x0fpayment_request\x18\t\x20\x01(\tR\x0epaymentRequest\x124\n\
    \x06status\x18\n\x20\x01(\x0e2\x1c.lnrpc.Payment.PaymentStatusR\x06statu\
    s\x12\x17\n\x07fee_sat\x18\x0b\x20\x01(\x03R\x06feeSat\x12\x19\n\x08fee_\
    msat\x18\x0c\x20\x01(\x03R\x07feeMsat\x12(\n\x10creation_time_ns\x18\r\
    \x20\x01(\x03R\x0ecreationTimeNs\x12(\n\x05htlcs\x18\x0e\x20\x03(\x0b2\
    \x12.lnrpc.HTLCAttemptR\x05htlcs\x12#\n\rpayment_index\x18\x0f\x20\x01(\
    \x04R\x0cpaymentIndex\x12B\n\x0efailure_reason\x18\x10\x20\x01(\x0e2\x1b\
    .lnrpc.PaymentFailureReasonR\rfailureReason\"F\n\rPaymentStatus\x12\x0b\
    \n\x07UNKNOWN\x10\0\x12\r\n\tIN_FLIGHT\x10\x01\x12\r\n\tSUCCEEDED\x10\
    \x02\x12\n\n\x06FAILED\x10\x03J\x04\x08\x04\x10\x05\"\xd5\x02\n\x0bHTLCA\
    ttempt\x12\x1d\n\nattempt_id\x18\x07\x20\x01(\x04R\tattemptId\x125\n\x06\
    status\x18\x01\x20\x01(\x0e2\x1d.lnrpc.HTLCAttempt.HTLCStatusR\x06status\
    \x12\"\n\x05route\x18\x02\x20\x01(\x0b2\x0c.lnrpc.RouteR\x05route\x12&\n\
    \x0fattempt_time_ns\x18\x03\x20\x01(\x03R\rattemptTimeNs\x12&\n\x0fresol\
    ve_time_ns\x18\x04\x20\x01(\x03R\rresolveTimeNs\x12(\n\x07failure\x18\
    \x05\x20\x01(\x0b2\x0e.lnrpc.FailureR\x07failure\x12\x1a\n\x08preimage\
    \x18\x06\x20\x01(\x0cR\x08preimage\"6\n\nHTLCStatus\x12\r\n\tIN_FLIGHT\
    \x10\0\x12\r\n\tSUCCEEDED\x10\x01\x12\n\n\x06FAILED\x10\x02\"\xa6\x01\n\
    \x13ListPaymentsRequest\x12-\n\x12include_incomplete\x18\x01\x20\x01(\
    \x08R\x11includeIncomplete\x12!\n\x0cindex_offset\x18\x02\x20\x01(\x04R\
    \x0bindexOffset\x12!\n\x0cmax_payments\x18\x03\x20\x01(\x04R\x0bmaxPayme\
    nts\x12\x1a\n\x08reversed\x18\x04\x20\x01(\x08R\x08reversed\"\x9c\x01\n\
    \x14ListPaymentsResponse\x12*\n\x08payments\x18\x01\x20\x03(\x0b2\x0e.ln\
    rpc.PaymentR\x08payments\x12,\n\x12first_index_offset\x18\x02\x20\x01(\
    \x04R\x10firstIndexOffset\x12*\n\x11last_index_offset\x18\x03\x20\x01(\
    \x04R\x0flastIndexOffset\"x\n\x18DeleteAllPaymentsRequest\x120\n\x14fail\
    ed_payments_only\x18\x01\x20\x01(\x08R\x12failedPaymentsOnly\x12*\n\x11f\
    ailed_htlcs_only\x18\x02\x20\x01(\x08R\x0ffailedHtlcsOnly\"\x1b\n\x19Del\
    eteAllPaymentsResponse\"\xbf\x01\n\x15AbandonChannelRequest\x128\n\rchan\
    nel_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\x0cchannelPoint\
    \x129\n\x19pending_funding_shim_only\x18\x02\x20\x01(\x08R\x16pendingFun\
    dingShimOnly\x121\n\x16i_know_what_i_am_doing\x18\x03\x20\x01(\x08R\x11i\
    KnowWhatIAmDoing\"\x18\n\x16AbandonChannelResponse\"F\n\x11DebugLevelReq\
    uest\x12\x12\n\x04show\x18\x01\x20\x01(\x08R\x04show\x12\x1d\n\nlevel_sp\
    ec\x18\x02\x20\x01(\tR\tlevelSpec\"5\n\x12DebugLevelResponse\x12\x1f\n\
    \x0bsub_systems\x18\x01\x20\x01(\tR\nsubSystems\"'\n\x0cPayReqString\x12\
    \x17\n\x07pay_req\x18\x01\x20\x01(\tR\x06payReq\"\xb0\x04\n\x06PayReq\
    \x12\x20\n\x0bdestination\x18\x01\x20\x01(\tR\x0bdestination\x12!\n\x0cp\
    ayment_hash\x18\x02\x20\x01(\tR\x0bpaymentHash\x12!\n\x0cnum_satoshis\
    \x18\x03\x20\x01(\x03R\x0bnumSatoshis\x12\x1c\n\ttimestamp\x18\x04\x20\
    \x01(\x03R\ttimestamp\x12\x16\n\x06expiry\x18\x05\x20\x01(\x03R\x06expir\
    y\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12)\n\x10\
    description_hash\x18\x07\x20\x01(\tR\x0fdescriptionHash\x12#\n\rfallback\
    _addr\x18\x08\x20\x01(\tR\x0cfallbackAddr\x12\x1f\n\x0bcltv_expiry\x18\t\
    \x20\x01(\x03R\ncltvExpiry\x121\n\x0broute_hints\x18\n\x20\x03(\x0b2\x10\
    .lnrpc.RouteHintR\nrouteHints\x12!\n\x0cpayment_addr\x18\x0b\x20\x01(\
    \x0cR\x0bpaymentAddr\x12\x19\n\x08num_msat\x18\x0c\x20\x01(\x03R\x07numM\
    sat\x127\n\x08features\x18\r\x20\x03(\x0b2\x1b.lnrpc.PayReq.FeaturesEntr\
    yR\x08features\x1aK\n\rFeaturesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\r\
    R\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\x0e.lnrpc.FeatureR\x05val\
    ue:\x028\x01\"Y\n\x07Feature\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04na\
    me\x12\x1f\n\x0bis_required\x18\x03\x20\x01(\x08R\nisRequired\x12\x19\n\
    \x08is_known\x18\x04\x20\x01(\x08R\x07isKnown\"\x12\n\x10FeeReportReques\
    t\"\xb3\x01\n\x10ChannelFeeReport\x12\x1b\n\x07chan_id\x18\x05\x20\x01(\
    \x04R\x06chanIdB\x020\x01\x12#\n\rchannel_point\x18\x01\x20\x01(\tR\x0cc\
    hannelPoint\x12\"\n\rbase_fee_msat\x18\x02\x20\x01(\x03R\x0bbaseFeeMsat\
    \x12\x1e\n\x0bfee_per_mil\x18\x03\x20\x01(\x03R\tfeePerMil\x12\x19\n\x08\
    fee_rate\x18\x04\x20\x01(\x01R\x07feeRate\"\xb5\x01\n\x11FeeReportRespon\
    se\x12:\n\x0cchannel_fees\x18\x01\x20\x03(\x0b2\x17.lnrpc.ChannelFeeRepo\
    rtR\x0bchannelFees\x12\x1e\n\x0bday_fee_sum\x18\x02\x20\x01(\x04R\tdayFe\
    eSum\x12\x20\n\x0cweek_fee_sum\x18\x03\x20\x01(\x04R\nweekFeeSum\x12\"\n\
    \rmonth_fee_sum\x18\x04\x20\x01(\x04R\x0bmonthFeeSum\"\xd4\x02\n\x13Poli\
    cyUpdateRequest\x12\x18\n\x06global\x18\x01\x20\x01(\x08H\0R\x06global\
    \x124\n\nchan_point\x18\x02\x20\x01(\x0b2\x13.lnrpc.ChannelPointH\0R\tch\
    anPoint\x12\"\n\rbase_fee_msat\x18\x03\x20\x01(\x03R\x0bbaseFeeMsat\x12\
    \x19\n\x08fee_rate\x18\x04\x20\x01(\x01R\x07feeRate\x12&\n\x0ftime_lock_\
    delta\x18\x05\x20\x01(\rR\rtimeLockDelta\x12\"\n\rmax_htlc_msat\x18\x06\
    \x20\x01(\x04R\x0bmaxHtlcMsat\x12\"\n\rmin_htlc_msat\x18\x07\x20\x01(\
    \x04R\x0bminHtlcMsat\x125\n\x17min_htlc_msat_specified\x18\x08\x20\x01(\
    \x08R\x14minHtlcMsatSpecifiedB\x07\n\x05scope\"\x16\n\x14PolicyUpdateRes\
    ponse\"\x9d\x01\n\x18ForwardingHistoryRequest\x12\x1d\n\nstart_time\x18\
    \x01\x20\x01(\x04R\tstartTime\x12\x19\n\x08end_time\x18\x02\x20\x01(\x04\
    R\x07endTime\x12!\n\x0cindex_offset\x18\x03\x20\x01(\rR\x0bindexOffset\
    \x12$\n\x0enum_max_events\x18\x04\x20\x01(\rR\x0cnumMaxEvents\"\xbb\x02\
    \n\x0fForwardingEvent\x12\x20\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimest\
    ampB\x02\x18\x01\x12\x20\n\nchan_id_in\x18\x02\x20\x01(\x04R\x08chanIdIn\
    B\x020\x01\x12\"\n\x0bchan_id_out\x18\x04\x20\x01(\x04R\tchanIdOutB\x020\
    \x01\x12\x15\n\x06amt_in\x18\x05\x20\x01(\x04R\x05amtIn\x12\x17\n\x07amt\
    _out\x18\x06\x20\x01(\x04R\x06amtOut\x12\x10\n\x03fee\x18\x07\x20\x01(\
    \x04R\x03fee\x12\x19\n\x08fee_msat\x18\x08\x20\x01(\x04R\x07feeMsat\x12\
    \x1e\n\x0bamt_in_msat\x18\t\x20\x01(\x04R\tamtInMsat\x12\x20\n\x0camt_ou\
    t_msat\x18\n\x20\x01(\x04R\namtOutMsat\x12!\n\x0ctimestamp_ns\x18\x0b\
    \x20\x01(\x04R\x0btimestampNs\"\x8c\x01\n\x19ForwardingHistoryResponse\
    \x12C\n\x11forwarding_events\x18\x01\x20\x03(\x0b2\x16.lnrpc.ForwardingE\
    ventR\x10forwardingEvents\x12*\n\x11last_offset_index\x18\x02\x20\x01(\r\
    R\x0flastOffsetIndex\"P\n\x1aExportChannelBackupRequest\x122\n\nchan_poi\
    nt\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tchanPoint\"d\n\rChanne\
    lBackup\x122\n\nchan_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\
    \tchanPoint\x12\x1f\n\x0bchan_backup\x18\x02\x20\x01(\x0cR\nchanBackup\"\
    s\n\x0fMultiChanBackup\x124\n\x0bchan_points\x18\x01\x20\x03(\x0b2\x13.l\
    nrpc.ChannelPointR\nchanPoints\x12*\n\x11multi_chan_backup\x18\x02\x20\
    \x01(\x0cR\x0fmultiChanBackup\"\x19\n\x17ChanBackupExportRequest\"\x9f\
    \x01\n\x12ChanBackupSnapshot\x12E\n\x13single_chan_backups\x18\x01\x20\
    \x01(\x0b2\x15.lnrpc.ChannelBackupsR\x11singleChanBackups\x12B\n\x11mult\
    i_chan_backup\x18\x02\x20\x01(\x0b2\x16.lnrpc.MultiChanBackupR\x0fmultiC\
    hanBackup\"I\n\x0eChannelBackups\x127\n\x0cchan_backups\x18\x01\x20\x03(\
    \x0b2\x14.lnrpc.ChannelBackupR\x0bchanBackups\"\x8e\x01\n\x18RestoreChan\
    BackupRequest\x12:\n\x0cchan_backups\x18\x01\x20\x01(\x0b2\x15.lnrpc.Cha\
    nnelBackupsH\0R\x0bchanBackups\x12,\n\x11multi_chan_backup\x18\x02\x20\
    \x01(\x0cH\0R\x0fmultiChanBackupB\x08\n\x06backup\"\x17\n\x15RestoreBack\
    upResponse\"\x1b\n\x19ChannelBackupSubscription\"\x1a\n\x18VerifyChanBac\
    kupResponse\"D\n\x12MacaroonPermission\x12\x16\n\x06entity\x18\x01\x20\
    \x01(\tR\x06entity\x12\x16\n\x06action\x18\x02\x20\x01(\tR\x06action\"r\
    \n\x13BakeMacaroonRequest\x12;\n\x0bpermissions\x18\x01\x20\x03(\x0b2\
    \x19.lnrpc.MacaroonPermissionR\x0bpermissions\x12\x1e\n\x0broot_key_id\
    \x18\x02\x20\x01(\x04R\trootKeyId\"2\n\x14BakeMacaroonResponse\x12\x1a\n\
    \x08macaroon\x18\x01\x20\x01(\tR\x08macaroon\"\x18\n\x16ListMacaroonIDsR\
    equest\";\n\x17ListMacaroonIDsResponse\x12\x20\n\x0croot_key_ids\x18\x01\
    \x20\x03(\x04R\nrootKeyIds\"9\n\x17DeleteMacaroonIDRequest\x12\x1e\n\x0b\
    root_key_id\x18\x01\x20\x01(\x04R\trootKeyId\"4\n\x18DeleteMacaroonIDRes\
    ponse\x12\x18\n\x07deleted\x18\x01\x20\x01(\x08R\x07deleted\"U\n\x16Maca\
    roonPermissionList\x12;\n\x0bpermissions\x18\x01\x20\x03(\x0b2\x19.lnrpc\
    .MacaroonPermissionR\x0bpermissions\"\x18\n\x16ListPermissionsRequest\"\
    \xe4\x01\n\x17ListPermissionsResponse\x12d\n\x12method_permissions\x18\
    \x01\x20\x03(\x0b25.lnrpc.ListPermissionsResponse.MethodPermissionsEntry\
    R\x11methodPermissions\x1ac\n\x16MethodPermissionsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x123\n\x05value\x18\x02\x20\x01(\x0b2\x1d.ln\
    rpc.MacaroonPermissionListR\x05value:\x028\x01\"\xb0\x08\n\x07Failure\
    \x12.\n\x04code\x18\x01\x20\x01(\x0e2\x1a.lnrpc.Failure.FailureCodeR\x04\
    code\x12;\n\x0echannel_update\x18\x03\x20\x01(\x0b2\x14.lnrpc.ChannelUpd\
    ateR\rchannelUpdate\x12\x1b\n\thtlc_msat\x18\x04\x20\x01(\x04R\x08htlcMs\
    at\x12\"\n\ronion_sha_256\x18\x05\x20\x01(\x0cR\x0bonionSha256\x12\x1f\n\
    \x0bcltv_expiry\x18\x06\x20\x01(\rR\ncltvExpiry\x12\x14\n\x05flags\x18\
    \x07\x20\x01(\rR\x05flags\x120\n\x14failure_source_index\x18\x08\x20\x01\
    (\rR\x12failureSourceIndex\x12\x16\n\x06height\x18\t\x20\x01(\rR\x06heig\
    ht\"\xef\x05\n\x0bFailureCode\x12\x0c\n\x08RESERVED\x10\0\x12(\n$INCORRE\
    CT_OR_UNKNOWN_PAYMENT_DETAILS\x10\x01\x12\x1c\n\x18INCORRECT_PAYMENT_AMO\
    UNT\x10\x02\x12\x1f\n\x1bFINAL_INCORRECT_CLTV_EXPIRY\x10\x03\x12\x1f\n\
    \x1bFINAL_INCORRECT_HTLC_AMOUNT\x10\x04\x12\x19\n\x15FINAL_EXPIRY_TOO_SO\
    ON\x10\x05\x12\x11\n\rINVALID_REALM\x10\x06\x12\x13\n\x0fEXPIRY_TOO_SOON\
    \x10\x07\x12\x19\n\x15INVALID_ONION_VERSION\x10\x08\x12\x16\n\x12INVALID\
    _ONION_HMAC\x10\t\x12\x15\n\x11INVALID_ONION_KEY\x10\n\x12\x18\n\x14AMOU\
    NT_BELOW_MINIMUM\x10\x0b\x12\x14\n\x10FEE_INSUFFICIENT\x10\x0c\x12\x19\n\
    \x15INCORRECT_CLTV_EXPIRY\x10\r\x12\x14\n\x10CHANNEL_DISABLED\x10\x0e\
    \x12\x1d\n\x19TEMPORARY_CHANNEL_FAILURE\x10\x0f\x12!\n\x1dREQUIRED_NODE_\
    FEATURE_MISSING\x10\x10\x12$\n\x20REQUIRED_CHANNEL_FEATURE_MISSING\x10\
    \x11\x12\x15\n\x11UNKNOWN_NEXT_PEER\x10\x12\x12\x1a\n\x16TEMPORARY_NODE_\
    FAILURE\x10\x13\x12\x1a\n\x16PERMANENT_NODE_FAILURE\x10\x14\x12\x1d\n\
    \x19PERMANENT_CHANNEL_FAILURE\x10\x15\x12\x12\n\x0eEXPIRY_TOO_FAR\x10\
    \x16\x12\x0f\n\x0bMPP_TIMEOUT\x10\x17\x12\x19\n\x15INVALID_ONION_PAYLOAD\
    \x10\x18\x12\x15\n\x10INTERNAL_FAILURE\x10\xe5\x07\x12\x14\n\x0fUNKNOWN_\
    FAILURE\x10\xe6\x07\x12\x17\n\x12UNREADABLE_FAILURE\x10\xe7\x07J\x04\x08\
    \x02\x10\x03\"\xb3\x03\n\rChannelUpdate\x12\x1c\n\tsignature\x18\x01\x20\
    \x01(\x0cR\tsignature\x12\x1d\n\nchain_hash\x18\x02\x20\x01(\x0cR\tchain\
    Hash\x12\x1b\n\x07chan_id\x18\x03\x20\x01(\x04R\x06chanIdB\x020\x01\x12\
    \x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestamp\x12#\n\rmessage_flags\
    \x18\n\x20\x01(\rR\x0cmessageFlags\x12#\n\rchannel_flags\x18\x05\x20\x01\
    (\rR\x0cchannelFlags\x12&\n\x0ftime_lock_delta\x18\x06\x20\x01(\rR\rtime\
    LockDelta\x12*\n\x11htlc_minimum_msat\x18\x07\x20\x01(\x04R\x0fhtlcMinim\
    umMsat\x12\x19\n\x08base_fee\x18\x08\x20\x01(\rR\x07baseFee\x12\x19\n\
    \x08fee_rate\x18\t\x20\x01(\rR\x07feeRate\x12*\n\x11htlc_maximum_msat\
    \x18\x0b\x20\x01(\x04R\x0fhtlcMaximumMsat\x12*\n\x11extra_opaque_data\
    \x18\x0c\x20\x01(\x0cR\x0fextraOpaqueData\"]\n\nMacaroonId\x12\x14\n\x05\
    nonce\x18\x01\x20\x01(\x0cR\x05nonce\x12\x1c\n\tstorageId\x18\x02\x20\
    \x01(\x0cR\tstorageId\x12\x1b\n\x03ops\x18\x03\x20\x03(\x0b2\t.lnrpc.OpR\
    \x03ops\"6\n\x02Op\x12\x16\n\x06entity\x18\x01\x20\x01(\tR\x06entity\x12\
    \x18\n\x07actions\x18\x02\x20\x03(\tR\x07actions*}\n\x0bAddressType\x12\
    \x17\n\x13WITNESS_PUBKEY_HASH\x10\0\x12\x16\n\x12NESTED_PUBKEY_HASH\x10\
    \x01\x12\x1e\n\x1aUNUSED_WITNESS_PUBKEY_HASH\x10\x02\x12\x1d\n\x19UNUSED\
    _NESTED_PUBKEY_HASH\x10\x03*^\n\x0eCommitmentType\x12\n\n\x06LEGACY\x10\
    \0\x12\x15\n\x11STATIC_REMOTE_KEY\x10\x01\x12\x0b\n\x07ANCHORS\x10\x02\
    \x12\x1c\n\x17UNKNOWN_COMMITMENT_TYPE\x10\xe7\x07*a\n\tInitiator\x12\x15\
    \n\x11INITIATOR_UNKNOWN\x10\0\x12\x13\n\x0fINITIATOR_LOCAL\x10\x01\x12\
    \x14\n\x10INITIATOR_REMOTE\x10\x02\x12\x12\n\x0eINITIATOR_BOTH\x10\x03*`\
    \n\x0eResolutionType\x12\x10\n\x0cTYPE_UNKNOWN\x10\0\x12\n\n\x06ANCHOR\
    \x10\x01\x12\x11\n\rINCOMING_HTLC\x10\x02\x12\x11\n\rOUTGOING_HTLC\x10\
    \x03\x12\n\n\x06COMMIT\x10\x04*q\n\x11ResolutionOutcome\x12\x13\n\x0fOUT\
    COME_UNKNOWN\x10\0\x12\x0b\n\x07CLAIMED\x10\x01\x12\r\n\tUNCLAIMED\x10\
    \x02\x12\r\n\tABANDONED\x10\x03\x12\x0f\n\x0bFIRST_STAGE\x10\x04\x12\x0b\
    \n\x07TIMEOUT\x10\x05*9\n\x0eNodeMetricType\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\x1a\n\x16BETWEENNESS_CENTRALITY\x10\x01*;\n\x10InvoiceHTLCState\x12\
    \x0c\n\x08ACCEPTED\x10\0\x12\x0b\n\x07SETTLED\x10\x01\x12\x0c\n\x08CANCE\
    LED\x10\x02*\xd9\x01\n\x14PaymentFailureReason\x12\x17\n\x13FAILURE_REAS\
    ON_NONE\x10\0\x12\x1a\n\x16FAILURE_REASON_TIMEOUT\x10\x01\x12\x1b\n\x17F\
    AILURE_REASON_NO_ROUTE\x10\x02\x12\x18\n\x14FAILURE_REASON_ERROR\x10\x03\
    \x12,\n(FAILURE_REASON_INCORRECT_PAYMENT_DETAILS\x10\x04\x12'\n#FAILURE_\
    REASON_INSUFFICIENT_BALANCE\x10\x05*\xcf\x04\n\nFeatureBit\x12\x18\n\x14\
    DATALOSS_PROTECT_REQ\x10\0\x12\x18\n\x14DATALOSS_PROTECT_OPT\x10\x01\x12\
    \x17\n\x13INITIAL_ROUING_SYNC\x10\x03\x12\x1f\n\x1bUPFRONT_SHUTDOWN_SCRI\
    PT_REQ\x10\x04\x12\x1f\n\x1bUPFRONT_SHUTDOWN_SCRIPT_OPT\x10\x05\x12\x16\
    \n\x12GOSSIP_QUERIES_REQ\x10\x06\x12\x16\n\x12GOSSIP_QUERIES_OPT\x10\x07\
    \x12\x11\n\rTLV_ONION_REQ\x10\x08\x12\x11\n\rTLV_ONION_OPT\x10\t\x12\x1a\
    \n\x16EXT_GOSSIP_QUERIES_REQ\x10\n\x12\x1a\n\x16EXT_GOSSIP_QUERIES_OPT\
    \x10\x0b\x12\x19\n\x15STATIC_REMOTE_KEY_REQ\x10\x0c\x12\x19\n\x15STATIC_\
    REMOTE_KEY_OPT\x10\r\x12\x14\n\x10PAYMENT_ADDR_REQ\x10\x0e\x12\x14\n\x10\
    PAYMENT_ADDR_OPT\x10\x0f\x12\x0b\n\x07MPP_REQ\x10\x10\x12\x0b\n\x07MPP_O\
    PT\x10\x11\x12\x16\n\x12WUMBO_CHANNELS_REQ\x10\x12\x12\x16\n\x12WUMBO_CH\
    ANNELS_OPT\x10\x13\x12\x0f\n\x0bANCHORS_REQ\x10\x14\x12\x0f\n\x0bANCHORS\
    _OPT\x10\x15\x12\x1d\n\x19ANCHORS_ZERO_FEE_HTLC_REQ\x10\x16\x12\x1d\n\
    \x19ANCHORS_ZERO_FEE_HTLC_OPT\x10\x17\x12\x0b\n\x07AMP_REQ\x10\x1e\x12\
    \x0b\n\x07AMP_OPT\x10\x1f2\xc9!\n\tLightning\x12J\n\rWalletBalance\x12\
    \x1b.lnrpc.WalletBalanceRequest\x1a\x1c.lnrpc.WalletBalanceResponse\x12M\
    \n\x0eChannelBalance\x12\x1c.lnrpc.ChannelBalanceRequest\x1a\x1d.lnrpc.C\
    hannelBalanceResponse\x12K\n\x0fGetTransactions\x12\x1d.lnrpc.GetTransac\
    tionsRequest\x1a\x19.lnrpc.TransactionDetails\x12D\n\x0bEstimateFee\x12\
    \x19.lnrpc.EstimateFeeRequest\x1a\x1a.lnrpc.EstimateFeeResponse\x12>\n\t\
    SendCoins\x12\x17.lnrpc.SendCoinsRequest\x1a\x18.lnrpc.SendCoinsResponse\
    \x12D\n\x0bListUnspent\x12\x19.lnrpc.ListUnspentRequest\x1a\x1a.lnrpc.Li\
    stUnspentResponse\x12L\n\x15SubscribeTransactions\x12\x1d.lnrpc.GetTrans\
    actionsRequest\x1a\x12.lnrpc.Transaction0\x01\x12;\n\x08SendMany\x12\x16\
    .lnrpc.SendManyRequest\x1a\x17.lnrpc.SendManyResponse\x12A\n\nNewAddress\
    \x12\x18.lnrpc.NewAddressRequest\x1a\x19.lnrpc.NewAddressResponse\x12D\n\
    \x0bSignMessage\x12\x19.lnrpc.SignMessageRequest\x1a\x1a.lnrpc.SignMessa\
    geResponse\x12J\n\rVerifyMessage\x12\x1b.lnrpc.VerifyMessageRequest\x1a\
    \x1c.lnrpc.VerifyMessageResponse\x12D\n\x0bConnectPeer\x12\x19.lnrpc.Con\
    nectPeerRequest\x1a\x1a.lnrpc.ConnectPeerResponse\x12M\n\x0eDisconnectPe\
    er\x12\x1c.lnrpc.DisconnectPeerRequest\x1a\x1d.lnrpc.DisconnectPeerRespo\
    nse\x12>\n\tListPeers\x12\x17.lnrpc.ListPeersRequest\x1a\x18.lnrpc.ListP\
    eersResponse\x12G\n\x13SubscribePeerEvents\x12\x1c.lnrpc.PeerEventSubscr\
    iption\x1a\x10.lnrpc.PeerEvent0\x01\x128\n\x07GetInfo\x12\x15.lnrpc.GetI\
    nfoRequest\x1a\x16.lnrpc.GetInfoResponse\x12P\n\x0fGetRecoveryInfo\x12\
    \x1d.lnrpc.GetRecoveryInfoRequest\x1a\x1e.lnrpc.GetRecoveryInfoResponse\
    \x12P\n\x0fPendingChannels\x12\x1d.lnrpc.PendingChannelsRequest\x1a\x1e.\
    lnrpc.PendingChannelsResponse\x12G\n\x0cListChannels\x12\x1a.lnrpc.ListC\
    hannelsRequest\x1a\x1b.lnrpc.ListChannelsResponse\x12V\n\x16SubscribeCha\
    nnelEvents\x12\x1f.lnrpc.ChannelEventSubscription\x1a\x19.lnrpc.ChannelE\
    ventUpdate0\x01\x12M\n\x0eClosedChannels\x12\x1c.lnrpc.ClosedChannelsReq\
    uest\x1a\x1d.lnrpc.ClosedChannelsResponse\x12A\n\x0fOpenChannelSync\x12\
    \x19.lnrpc.OpenChannelRequest\x1a\x13.lnrpc.ChannelPoint\x12C\n\x0bOpenC\
    hannel\x12\x19.lnrpc.OpenChannelRequest\x1a\x17.lnrpc.OpenStatusUpdate0\
    \x01\x12L\n\x10FundingStateStep\x12\x1b.lnrpc.FundingTransitionMsg\x1a\
    \x1b.lnrpc.FundingStateStepResp\x12P\n\x0fChannelAcceptor\x12\x1c.lnrpc.\
    ChannelAcceptResponse\x1a\x1b.lnrpc.ChannelAcceptRequest(\x010\x01\x12F\
    \n\x0cCloseChannel\x12\x1a.lnrpc.CloseChannelRequest\x1a\x18.lnrpc.Close\
    StatusUpdate0\x01\x12M\n\x0eAbandonChannel\x12\x1c.lnrpc.AbandonChannelR\
    equest\x1a\x1d.lnrpc.AbandonChannelResponse\x12?\n\x0bSendPayment\x12\
    \x12.lnrpc.SendRequest\x1a\x13.lnrpc.SendResponse\"\x03\x88\x02\x01(\x01\
    0\x01\x12:\n\x0fSendPaymentSync\x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.\
    SendResponse\x12F\n\x0bSendToRoute\x12\x19.lnrpc.SendToRouteRequest\x1a\
    \x13.lnrpc.SendResponse\"\x03\x88\x02\x01(\x010\x01\x12A\n\x0fSendToRout\
    eSync\x12\x19.lnrpc.SendToRouteRequest\x1a\x13.lnrpc.SendResponse\x127\n\
    \nAddInvoice\x12\x0e.lnrpc.Invoice\x1a\x19.lnrpc.AddInvoiceResponse\x12E\
    \n\x0cListInvoices\x12\x19.lnrpc.ListInvoiceRequest\x1a\x1a.lnrpc.ListIn\
    voiceResponse\x123\n\rLookupInvoice\x12\x12.lnrpc.PaymentHash\x1a\x0e.ln\
    rpc.Invoice\x12A\n\x11SubscribeInvoices\x12\x1a.lnrpc.InvoiceSubscriptio\
    n\x1a\x0e.lnrpc.Invoice0\x01\x122\n\x0cDecodePayReq\x12\x13.lnrpc.PayReq\
    String\x1a\r.lnrpc.PayReq\x12G\n\x0cListPayments\x12\x1a.lnrpc.ListPayme\
    ntsRequest\x1a\x1b.lnrpc.ListPaymentsResponse\x12V\n\x11DeleteAllPayment\
    s\x12\x1f.lnrpc.DeleteAllPaymentsRequest\x1a\x20.lnrpc.DeleteAllPayments\
    Response\x12@\n\rDescribeGraph\x12\x1a.lnrpc.ChannelGraphRequest\x1a\x13\
    .lnrpc.ChannelGraph\x12G\n\x0eGetNodeMetrics\x12\x19.lnrpc.NodeMetricsRe\
    quest\x1a\x1a.lnrpc.NodeMetricsResponse\x129\n\x0bGetChanInfo\x12\x16.ln\
    rpc.ChanInfoRequest\x1a\x12.lnrpc.ChannelEdge\x126\n\x0bGetNodeInfo\x12\
    \x16.lnrpc.NodeInfoRequest\x1a\x0f.lnrpc.NodeInfo\x12D\n\x0bQueryRoutes\
    \x12\x19.lnrpc.QueryRoutesRequest\x1a\x1a.lnrpc.QueryRoutesResponse\x12?\
    \n\x0eGetNetworkInfo\x12\x19.lnrpc.NetworkInfoRequest\x1a\x12.lnrpc.Netw\
    orkInfo\x125\n\nStopDaemon\x12\x12.lnrpc.StopRequest\x1a\x13.lnrpc.StopR\
    esponse\x12W\n\x15SubscribeChannelGraph\x12\x20.lnrpc.GraphTopologySubsc\
    ription\x1a\x1a.lnrpc.GraphTopologyUpdate0\x01\x12A\n\nDebugLevel\x12\
    \x18.lnrpc.DebugLevelRequest\x1a\x19.lnrpc.DebugLevelResponse\x12>\n\tFe\
    eReport\x12\x17.lnrpc.FeeReportRequest\x1a\x18.lnrpc.FeeReportResponse\
    \x12N\n\x13UpdateChannelPolicy\x12\x1a.lnrpc.PolicyUpdateRequest\x1a\x1b\
    .lnrpc.PolicyUpdateResponse\x12V\n\x11ForwardingHistory\x12\x1f.lnrpc.Fo\
    rwardingHistoryRequest\x1a\x20.lnrpc.ForwardingHistoryResponse\x12N\n\
    \x13ExportChannelBackup\x12!.lnrpc.ExportChannelBackupRequest\x1a\x14.ln\
    rpc.ChannelBackup\x12T\n\x17ExportAllChannelBackups\x12\x1e.lnrpc.ChanBa\
    ckupExportRequest\x1a\x19.lnrpc.ChanBackupSnapshot\x12N\n\x10VerifyChanB\
    ackup\x12\x19.lnrpc.ChanBackupSnapshot\x1a\x1f.lnrpc.VerifyChanBackupRes\
    ponse\x12V\n\x15RestoreChannelBackups\x12\x1f.lnrpc.RestoreChanBackupReq\
    uest\x1a\x1c.lnrpc.RestoreBackupResponse\x12X\n\x17SubscribeChannelBacku\
    ps\x12\x20.lnrpc.ChannelBackupSubscription\x1a\x19.lnrpc.ChanBackupSnaps\
    hot0\x01\x12G\n\x0cBakeMacaroon\x12\x1a.lnrpc.BakeMacaroonRequest\x1a\
    \x1b.lnrpc.BakeMacaroonResponse\x12P\n\x0fListMacaroonIDs\x12\x1d.lnrpc.\
    ListMacaroonIDsRequest\x1a\x1e.lnrpc.ListMacaroonIDsResponse\x12S\n\x10D\
    eleteMacaroonID\x12\x1e.lnrpc.DeleteMacaroonIDRequest\x1a\x1f.lnrpc.Dele\
    teMacaroonIDResponse\x12P\n\x0fListPermissions\x12\x1d.lnrpc.ListPermiss\
    ionsRequest\x1a\x1e.lnrpc.ListPermissionsResponseB'Z%github.com/lightnin\
    gnetwork/lnd/lnrpcb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
